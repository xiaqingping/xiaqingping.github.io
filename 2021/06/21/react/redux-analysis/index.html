<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>redux解析 - Scott&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Scott_xia"><meta name="msapplication-TileImage" content="https://scott_xia.gitee.io/static-resources/img/header.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Scott_xia"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="Redux&amp;#x2F;react-redux&amp;#x2F;redux 中间件设计实现剖析其实笔者本来没有 redux 相关的行文计划，不过公司内部最近有同事作了 redux 相关的技术分享,而笔者承担了一部分文章评审的任务，在评审的过程中，笔者花了相当的精力时间来查阅资料和实现代码，前后积攒了几千字的笔记，对 redux 也有了一份心得见解，于是顺手写就本文，希望能给大家带来些一些启发和思考 Thanks♪(･ω·)ﾉ"><meta property="og:type" content="article"><meta property="og:title" content="redux解析"><meta property="og:url" content="http://scott_xia.gitee.io/2021/06/21/react/redux-analysis/"><meta property="og:site_name" content="Scott&#039;s blog"><meta property="og:description" content="Redux&amp;#x2F;react-redux&amp;#x2F;redux 中间件设计实现剖析其实笔者本来没有 redux 相关的行文计划，不过公司内部最近有同事作了 redux 相关的技术分享,而笔者承担了一部分文章评审的任务，在评审的过程中，笔者花了相当的精力时间来查阅资料和实现代码，前后积攒了几千字的笔记，对 redux 也有了一份心得见解，于是顺手写就本文，希望能给大家带来些一些启发和思考 Thanks♪(･ω·)ﾉ"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://scott_xia.gitee.io/images/bgi/vector_landscape_1.svg"><meta property="article:published_time" content="2021-06-21T06:48:35.000Z"><meta property="article:modified_time" content="2021-06-24T06:21:39.943Z"><meta property="article:author" content="Scott_xia"><meta property="article:tag" content="scott_xia"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/bgi/vector_landscape_1.svg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://scott_xia.gitee.io/2021/06/21/react/redux-analysis/"},"headline":"Scott's blog","image":[],"datePublished":"2021-06-21T06:48:35.000Z","dateModified":"2021-06-24T06:21:39.943Z","author":{"@type":"Person","name":"Scott_xia"},"description":"Redux&#x2F;react-redux&#x2F;redux 中间件设计实现剖析其实笔者本来没有 redux 相关的行文计划，不过公司内部最近有同事作了 redux 相关的技术分享,而笔者承担了一部分文章评审的任务，在评审的过程中，笔者花了相当的精力时间来查阅资料和实现代码，前后积攒了几千字的笔记，对 redux 也有了一份心得见解，于是顺手写就本文，希望能给大家带来些一些启发和思考 Thanks♪(･ω·)ﾉ"}</script><link rel="canonical" href="http://scott_xia.gitee.io/2021/06/21/react/redux-analysis/"><link rel="icon" href="https://scott_xia.gitee.io/static-resources/img/header.jpg"><link rel="stylesheet" href="https://at.alicdn.com/t/font_2285034_8c7bvyy7fhj.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.1/css/all.css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://scott_xia.gitee.io/static-resources/img/header.jpg" alt="Scott&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener external nofollow noreferrer" title="Download on GitHub" href="https://github.com/xiaqingping"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;" rel="external nofollow noreferrer"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;" rel="external nofollow noreferrer"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/images/bgi/vector_landscape_1.svg" alt="redux解析"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-21T06:48:35.000Z" title="2021/6/21 下午2:48:35">2021-06-21</time>发表</span><span class="level-item"><time dateTime="2021-06-24T06:21:39.943Z" title="2021/6/24 下午2:21:39">2021-06-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/react/">react</a></span></div></div><h1 class="title is-3 is-size-4-mobile">redux解析</h1><div class="content"><h1 id="Redux-react-redux-redux-中间件设计实现剖析"><a href="#Redux-react-redux-redux-中间件设计实现剖析" class="headerlink" title="Redux/react-redux/redux 中间件设计实现剖析"></a>Redux/react-redux/redux 中间件设计实现剖析</h1><p>其实笔者本来没有 redux 相关的行文计划，不过公司内部最近有同事作了 redux 相关的技术分享,而笔者承担了一部分文章评审的任务，在评审的过程中，笔者花了相当的精力时间来查阅资料和实现代码，前后积攒了几千字的笔记，对 redux 也有了一份心得见解，于是顺手写就本文，希望能给大家带来些一些启发和思考 Thanks♪(･ω·)ﾉ经过本文的学习，读者应该能够学习理解：</p>
<ol>
<li><code>redux</code>的设计思路及实现原理</li>
<li><code>react-redux</code>的设计思路及实现原理</li>
<li><code>redux中间件</code>的设计思路及实现原理</li>
</ol>
<a id="more"></a>

<h2 id="一-redux-的实现"><a href="#一-redux-的实现" class="headerlink" title="一. redux 的实现"></a>一. redux 的实现</h2><p>在一切开始之前，我们首先要回答一个问题：为什么我们需要 redux，redux 为我们解决了什么问题？只有回答了这个问题，我们才能把握 redux 的设计思路。</p>
<p>React 作为一个组件化开发框架，组件之间存在大量通信，有时这些通信跨越多个组件，或者多个组件之间共享一套数据，简单的父子组件间传值不能满足我们的需求，自然而然地，我们需要有一个地方存取和操作这些公共状态。而 redux 就为我们提供了一种管理公共状态的方案，我们后续的设计实现也将围绕这个需求来展开。</p>
<p>我们思考一下如何管理公共状态：既然是公共状态，那么就直接把公共状态提取出来好了。我们创建一个 store.js 文件，然后直接在里边存放公共的 state，其他组件只要引入这个 store 就可以存取共用状态了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const state &#x3D; &#123;</span><br><span class="line">    count: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 store 里存放一个公共状态 count，组件在 import 了 store 后就可以操作这个 count。这是最直接的 store，当然我们的 store 肯定不能这么设计，原因主要是两点：</p>
<p><strong>1. 容易误操作</strong></p>
<p>比如说，有人一个不小心把 store 赋值了{}，清空了 store，或者误修改了其他组件的数据，那显然不太安全，出错了也很难排查，因此我们需要<strong>有条件地</strong>操作 store，防止使用者直接修改 store 的数据。</p>
<p><strong>2. 可读性很差</strong></p>
<p>JS 是一门极其依赖语义化的语言，试想如果在代码中不经注释直接修改了公用的 state，以后其他人维护代码得多懵逼，为了搞清楚修改 state 的含义还得根据上下文推断，所以我们最好是给每个操作<strong>起个名字</strong>。</p>
<blockquote>
<p>项目交接</p>
</blockquote>
<p>我们重新思考一下如何设计这个<strong>公共状态管理器</strong>，根据我们上面的分析，我们希望公共状态既能够被全局访问到，又是私有的不能被直接修改，思考一下，<strong>闭包</strong>是不是就就正好符合这两条要求，因此我们会把公共状态设计成闭包（对闭包理解有困难的同学也可以跳过闭包，这并不影响后续理解）</p>
<p>既然我们要存取状态，那么肯定要有<strong>getter</strong>和<strong>setter</strong>，此外当状态发生改变时，我们得进行广播，通知组件状态发生了变更。这不就和 redux 的三个 API：<code>getState、dispatch、subscribe</code>对应上了吗。我们用几句代码勾勒出 store 的大致形状：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export const createStore &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    let currentState &#x3D; &#123;&#125;       &#x2F;&#x2F; 公共状态</span><br><span class="line">    function getState() &#123;&#125;      &#x2F;&#x2F; getter</span><br><span class="line">    function dispatch() &#123;&#125;      &#x2F;&#x2F; setter</span><br><span class="line">    function subscribe() &#123;&#125;     &#x2F;&#x2F; 发布订阅</span><br><span class="line">    return &#123; getState, dispatch, subscribe &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-getState-实现"><a href="#1-getState-实现" class="headerlink" title="1. getState 实现"></a>1. getState 实现</h3><p><code>getState()</code>的实现非常简单，返回当前状态即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export const createStore &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    let currentState &#x3D; &#123;&#125;       &#x2F;&#x2F; 公共状态</span><br><span class="line">    function getState() &#123;       &#x2F;&#x2F; getter</span><br><span class="line">        return currentState</span><br><span class="line">    &#125;</span><br><span class="line">    function dispatch() &#123;&#125;      &#x2F;&#x2F; setter</span><br><span class="line">    function subscribe() &#123;&#125;     &#x2F;&#x2F; 发布订阅</span><br><span class="line">    return &#123; getState, dispatch, subscribe &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-dispatch-实现"><a href="#2-dispatch-实现" class="headerlink" title="2.dispatch 实现"></a>2.dispatch 实现</h3><p>但是<code>dispatch()</code>的实现我们得思考一下，经过上面的分析，我们的目标是<strong>有条件地、具名地</strong>修改 store 的数据，那么我们要如何实现这两点呢？我们已经知道，在使用 dispatch 的时候，我们会给 dispatch()传入一个 action 对象，这个对象包括我们要修改的 state 以及这个操作的名字(actionType)，根据 type 的不同，store 会修改对应的 state。我们这里也沿用这种设计：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export const createStore &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    let currentState &#x3D; &#123;&#125;</span><br><span class="line">    function getState() &#123;</span><br><span class="line">        return currentState</span><br><span class="line">    &#125;</span><br><span class="line">    function dispatch(action) &#123;</span><br><span class="line">        switch (action.type) &#123;</span><br><span class="line">            case &#39;plus&#39;:</span><br><span class="line">            currentState &#x3D; &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                count: currentState.count + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function subscribe() &#123;&#125;</span><br><span class="line">    return &#123; getState, subscribe, dispatch &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把对 actionType 的判断写在了 dispatch 中，这样显得很臃肿，也很笨拙，于是我们想到把这部分修改 state 的规则抽离出来放到外面，这就是我们熟悉的**<code>reducer</code>。**我们修改一下代码，让 reducer 从外部传入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reducer &#125; from &#39;.&#x2F;reducer&#39;</span><br><span class="line">export const createStore &#x3D; (reducer) &#x3D;&gt; &#123;</span><br><span class="line">    let currentState &#x3D; &#123;&#125;</span><br><span class="line">    function getState() &#123;</span><br><span class="line">        return currentState</span><br><span class="line">    &#125;</span><br><span class="line">    function dispatch(action) &#123;</span><br><span class="line">        currentState &#x3D; reducer(currentState, action)</span><br><span class="line">    &#125;</span><br><span class="line">    function subscribe() &#123;&#125;</span><br><span class="line">    return &#123; getState, dispatch, subscribe &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们创建一个 reducer.js 文件，写我们的 reducer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;reducer.js</span><br><span class="line">const initialState &#x3D; &#123;</span><br><span class="line">    count: 0</span><br><span class="line">&#125;</span><br><span class="line">export function reducer(state &#x3D; initialState, action) &#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">        case &#39;plus&#39;:</span><br><span class="line">        return &#123;</span><br><span class="line">            ...state,</span><br><span class="line">            count: state.count + 1</span><br><span class="line">        &#125;</span><br><span class="line">        case &#39;subtract&#39;:</span><br><span class="line">        return &#123;</span><br><span class="line">            ...state,</span><br><span class="line">            count: state.count - 1</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">        return initialState</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码写到这里，我们可以验证一下<code>getState</code>和<code>dispatch</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;store.js</span><br><span class="line">import &#123; reducer &#125; from &#39;.&#x2F;reducer&#39;</span><br><span class="line">export const createStore &#x3D; (reducer) &#x3D;&gt; &#123;</span><br><span class="line">    let currentState &#x3D; &#123;&#125;</span><br><span class="line">    function getState() &#123;</span><br><span class="line">        return currentState</span><br><span class="line">    &#125;</span><br><span class="line">    function dispatch(action) &#123;</span><br><span class="line">        currentState &#x3D; reducer(currentState, action)</span><br><span class="line">    &#125;</span><br><span class="line">    function subscribe() &#123;&#125;</span><br><span class="line">    return &#123; getState, subscribe, dispatch &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store &#x3D; createStore(reducer)  &#x2F;&#x2F;创建store</span><br><span class="line">store.dispatch(&#123; type: &#39;plus&#39; &#125;)    &#x2F;&#x2F;执行加法操作,给count加1</span><br><span class="line">console.log(store.getState())       &#x2F;&#x2F;获取state</span><br></pre></td></tr></table></figure>
<p>运行代码，我们会发现，打印得到的 state 是：{ count: NaN }，这是由于 store 里初始数据为空，state.count + 1 实际上是 underfind+1，输出了 NaN，所以我们得先进行 store 数据初始化，我们在执行 dispatch({ type: ‘plus’ })之前先进行一次初始化的 dispatch，这个 dispatch 的 actionType 可以随便填，只要不和已有的 type 重复，让 reducer 里的 switch 能走到 default 去初始化 store 就行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reducer &#125; from &#39;.&#x2F;reducer&#39;</span><br><span class="line">export const createStore &#x3D; (reducer) &#x3D;&gt; &#123;</span><br><span class="line">    let currentState &#x3D; &#123;&#125;</span><br><span class="line">    function getState() &#123;</span><br><span class="line">        return currentState</span><br><span class="line">    &#125;</span><br><span class="line">    function dispatch(action) &#123;</span><br><span class="line">        currentState &#x3D; reducer(currentState, action)</span><br><span class="line">    &#125;</span><br><span class="line">    function subscribe() &#123;&#125;</span><br><span class="line">    dispatch(&#123; type: &#39;@@REDUX_INIT&#39; &#125;)  &#x2F;&#x2F;初始化store数据</span><br><span class="line">    return &#123; getState, subscribe, dispatch &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store &#x3D; createStore(reducer)      &#x2F;&#x2F;创建store</span><br><span class="line">store.dispatch(&#123; type: &#39;plus&#39; &#125;)        &#x2F;&#x2F;执行加法操作,给count加1</span><br><span class="line">console.log(store.getState())           &#x2F;&#x2F;获取state</span><br></pre></td></tr></table></figure>
<p>运行代码，我们就能打印到的正确的 state：{ count: 1 }</p>
<p><img src="/blog/images/react/16ef781577deb645.jpg"></p>
<h3 id="3-subscribe-实现"><a href="#3-subscribe-实现" class="headerlink" title="3.subscribe 实现"></a>3.subscribe 实现</h3><p>尽管我们已经能够存取公用 state，但 store 的变化并不会直接引起视图的更新，我们需要监听 store 的变化，这里我们应用一个设计模式——观察者模式，观察者模式被广泛运用于监听事件实现（有些地方写的是发布订阅模式，但我个人认为这里称为观察者模式更准确，有关观察者和发布订阅的区别，讨论有很多，读者可以搜一下）</p>
<p>所谓观察者模式，概念也很简单：观察者监听被观察者的变化，被观察者发生改变时，通知所有的观察者。那么我们如何实现这种监听-通知的功能呢，为了照顾还不熟悉观察者模式实现的同学，我们先跳出 redux，写一段简单的观察者模式实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;观察者</span><br><span class="line">class Observer &#123;        </span><br><span class="line">  constructor (fn) &#123;              </span><br><span class="line">    this.update &#x3D; fn        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;被观察者</span><br><span class="line">class Subject &#123;        </span><br><span class="line">  constructor() &#123;                </span><br><span class="line">    this.observers &#x3D; []          &#x2F;&#x2F;观察者队列        </span><br><span class="line">  &#125;        </span><br><span class="line">  </span><br><span class="line">  addObserver(observer) &#123;                  </span><br><span class="line">    this.observers.push(observer) &#x2F;&#x2F;往观察者队列添加观察者        </span><br><span class="line">  &#125;        </span><br><span class="line">  </span><br><span class="line">  notify() &#123;                       &#x2F;&#x2F;通知所有观察者,实际上是把观察者的update()都执行了一遍               </span><br><span class="line">    this.observers.forEach(observer &#x3D;&gt; &#123;                    </span><br><span class="line">      observer.update()            &#x2F;&#x2F;依次取出观察者,并执行观察者的update方法                </span><br><span class="line">    &#125;)        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  var subject &#x3D; new Subject()       &#x2F;&#x2F;被观察者</span><br><span class="line">  </span><br><span class="line">  const update &#x3D; () &#x3D;&gt; &#123; console.log(&#39;被观察者发出通知&#39;) &#125;  &#x2F;&#x2F;收到广播时要执行的方法</span><br><span class="line">  </span><br><span class="line">  var ob1 &#x3D; new Observer(update)    &#x2F;&#x2F;观察者1</span><br><span class="line">  var ob2 &#x3D; new Observer(update)    &#x2F;&#x2F;观察者2</span><br><span class="line">  subject.addObserver(ob1)          &#x2F;&#x2F;观察者1订阅subject的通知subject.addObserver(ob2)          </span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;观察者2订阅subject的通知subject.notify()                  &#x2F;&#x2F;发出广播,执行所有观察者的update方法</span><br></pre></td></tr></table></figure>
<p>解释一下上面的代码：观察者对象有一个<code>update</code>方法(收到通知后要执行的方法)，我们想要在被观察者发出通知后，执行该方法；被观察者拥有<code>addObserver</code>和<code>notify</code>方法，addObserver 用于收集观察者，其实就是将观察者们的 update 方法加入一个队列，而当 notify 被执行的时候，就从队列中取出所有观察者的 update 方法并执行，这样就实现了通知的功能。我们 redux 的监听-通知功能也将按照这种实现思路来实现 subscribe：</p>
<p>有了上面观察者模式的例子，subscribe 的实现应该很好理解，这里把 dispatch 和 notify 做了合并，我们每次 dispatch，都进行广播，通知组件 store 的状态发生了变更。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reducer &#125; from &#39;.&#x2F;reducer&#39;export const createStore &#x3D; (reducer) &#x3D;&gt; &#123;</span><br><span class="line">   let currentState &#x3D; &#123;&#125;</span><br><span class="line">   let observers &#x3D; []             &#x2F;&#x2F;观察者队列</span><br><span class="line">   function getState() &#123;</span><br><span class="line">     return currentState</span><br><span class="line">   &#125;</span><br><span class="line">  function dispatch(action) &#123;                        </span><br><span class="line">    currentState &#x3D; reducer(currentState, action)                        </span><br><span class="line">    observers.forEach(fn &#x3D;&gt; fn())            </span><br><span class="line">  &#125;            </span><br><span class="line">  </span><br><span class="line">  function subscribe(fn) &#123;                        </span><br><span class="line">    observers.push(fn)            </span><br><span class="line">  &#125;            </span><br><span class="line">  </span><br><span class="line">  dispatch(&#123; type: &#39;@@REDUX_INIT&#39; &#125;)  &#x2F;&#x2F;初始化store数据            </span><br><span class="line">  </span><br><span class="line">  return &#123; getState, subscribe, dispatch &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们来试一下这个 subscribe（这里就不创建组件再引入 store 再 subscribe 了，直接在 store.js 中模拟一下两个组件使用 subscribe 订阅 store 变化）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reducer &#125; from &#39;.&#x2F;reducer&#39;export const createStore &#x3D; (reducer) &#x3D;&gt; &#123;</span><br><span class="line">  let currentState &#x3D; &#123;&#125;</span><br><span class="line">  let observers &#x3D; []             &#x2F;&#x2F;观察者队列</span><br><span class="line">  function getState() &#123;</span><br><span class="line">    return currentState</span><br><span class="line">  &#125;</span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    currentState &#x3D; reducer(currentState, action)</span><br><span class="line">    observers.forEach(fn &#x3D;&gt; fn())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function subscribe(fn) &#123;</span><br><span class="line">    observers.push(fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dispatch(&#123; type: &#39;@@REDUX_INIT&#39; &#125;)  &#x2F;&#x2F;初始化store数据</span><br><span class="line"></span><br><span class="line">  return &#123; getState, subscribe, dispatch &#125;&#125;</span><br><span class="line"></span><br><span class="line">  const store &#x3D; createStore(reducer)       &#x2F;&#x2F;创建</span><br><span class="line"></span><br><span class="line">  storestore.subscribe(() &#x3D;&gt; &#123; console.log(&#39;组件1收到store的通知&#39;) &#125;)</span><br><span class="line">  store.subscribe(() &#x3D;&gt; &#123; console.log(&#39;组件2收到store的通知&#39;) &#125;)</span><br><span class="line"></span><br><span class="line">  store.dispatch(&#123; type: &#39;plus&#39; &#125;)         &#x2F;&#x2F;执行dispatch，触发store的通知</span><br></pre></td></tr></table></figure>
<p>控制台成功输出 store.subscribe()传入的回调的执行结果：<br><img src="/blog/images/react/16ef7aa713fe4f26.jpg"></p>
<p>到这里，一个简单的 redux 就已经完成，在 redux 真正的源码中还加入了入参校验等细节，但总体思路和上面的基本相同。</p>
<p>我们已经可以在组件里引入 store 进行状态的存取以及订阅 store 变化，数一下，正好十行代码(｀ ∀´)Ψ。但是我们看一眼右边的进度条，就会发现事情并不简单，篇幅到这里才过了三分之一。尽管说我们已经实现了 redux，但 coder 们并不满足于此，我们在使用 store 时，需要在每个组件中引入 store，然后 getState，然后 dispatch，还有 subscribe，代码比较冗余，我们需要合并一些重复操作，而其中一种简化合并的方案，就是我们熟悉的<strong>react-redux</strong>。</p>
<h2 id="二-react-redux-的实现"><a href="#二-react-redux-的实现" class="headerlink" title="二. react-redux 的实现"></a>二. react-redux 的实现</h2><p>上文我们说到，一个组件如果想从 store 存取公用状态，需要进行四步操作：import 引入 store、getState 获取状态、dispatch 修改状态、subscribe 订阅更新，代码相对冗余，我们想要合并一些重复的操作，而 react-redux 就提供了一种合并操作的方案：react-redux 提供<code>Provider</code>和<code>connect</code>两个 API，Provider 将 store 放进 this.context 里，省去了 import 这一步，connect 将 getState、dispatch 合并进了 this.props，并自动订阅更新，简化了另外三步，下面我们来看一下如何实现这两个 API：</p>
<h3 id="1-Provider-实现"><a href="#1-Provider-实现" class="headerlink" title="1. Provider 实现"></a>1. Provider 实现</h3><p>我们先从比较简单的<code>Provider</code>开始实现，Provider 是一个组件，接收 store 并放进全局的<code>context</code>对象，至于为什么要放进 context，后面我们实现 connect 的时候就会明白。下面我们创建 Provider 组件，并把 store 放进 context 里，使用 context 这个 API 时有一些固定写法(有关 context 的用法可以查看<a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.im/post/6844903566381940744">这篇文章</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;</span><br><span class="line">import PropTypes from &#39;prop-types&#39;</span><br><span class="line"></span><br><span class="line">export class Provider extends React.Component &#123;      &#x2F;&#x2F; 需要声明静态属性childContextTypes来指定context对象的属性,是context的固定写法</span><br><span class="line">  static childContextTypes &#x3D; &#123;</span><br><span class="line">    store: PropTypes.object</span><br><span class="line">  &#125;     &#x2F;&#x2F; 实现getChildContext方法,返回context对象,也是固定写法</span><br><span class="line"> getChildContext() &#123;</span><br><span class="line">   return &#123; store: this.store &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  constructor(props, context) &#123;</span><br><span class="line">    super(props, context)</span><br><span class="line">    this.store &#x3D; props.store</span><br><span class="line">  &#125;      &#x2F;&#x2F; 渲染被Provider包裹的组件</span><br><span class="line">  render() &#123;</span><br><span class="line">    return this.props.children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成 Provider 后，我们就能在组件中通过 this.context.store 这样的形式取到 store，不需要再单独 import store。</p>
<h3 id="2-connect-实现"><a href="#2-connect-实现" class="headerlink" title="2. connect 实现"></a>2. connect 实现</h3><p>下面我们来思考一下如何实现<code>connect</code>，我们先回顾一下 connect 的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(mapStateToProps, mapDispatchToProps)(App)</span><br></pre></td></tr></table></figure>
<p>我们已经知道，connect 接收 mapStateToProps、mapDispatchToProps 两个方法，然后返回一个高阶函数，这个高阶函数接收一个组件，返回一个高阶组件（其实就是给传入的组件增加一些属性和功能）connect 根据传入的 map，将 state 和 dispatch(action)挂载子组件的 props 上，我们直接放出 connect 的实现代码，寥寥几行，并不复杂：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">export function connect(mapStateToProps, mapDispatchToProps) &#123;</span><br><span class="line">  return function(Component) &#123;</span><br><span class="line">    class Connect extends React.Component &#123;</span><br><span class="line">      componentDidMount() &#123;                          &#x2F;&#x2F;从context获取store并订阅更新</span><br><span class="line">      this.context.store.subscribe(this.handleStoreChange.bind(this));</span><br><span class="line">      &#125;</span><br><span class="line">       handleStoreChange() &#123;                          &#x2F;&#x2F; 触发更新</span><br><span class="line">       &#x2F;&#x2F; 触发的方法有多种,这里为了简洁起见,直接forceUpdate强制更新,读者也可以通过setState来触发子组件更新</span><br><span class="line">       this.forceUpdate()</span><br><span class="line">       &#125;</span><br><span class="line">       render() &#123;</span><br><span class="line">          return (</span><br><span class="line">            &lt;Component                                              &#x2F;&#x2F; 传入该组件的props,需要由connect这个高阶组件原样传回原组件</span><br><span class="line">            &#123; ...this.props &#125;                                       &#x2F;&#x2F; 根据mapStateToProps把state挂到this.props上</span><br><span class="line">            &#123; ...mapStateToProps(this.context.store.getState()) &#125;   &#x2F;&#x2F; 根据mapDispatchToProps把dispatch(action)挂到this.props上</span><br><span class="line">            &#123; ...mapDispatchToProps(this.context.store.dispatch) &#125;</span><br><span class="line">          &#x2F;&gt;</span><br><span class="line">        )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;              &#x2F;&#x2F;接收context的固定写法</span><br><span class="line">      Connect.contextTypes &#x3D; &#123;</span><br><span class="line">        store: PropTypes.object</span><br><span class="line">      &#125;</span><br><span class="line">    return Connect</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写完了 connect 的代码，我们有两点需要解释一下：</p>
<p>\1. Provider 的意义：我们审视一下 connect 的代码，其实 context 不过是给 connect 提供了获取 store 的途径，我们在 connect 中直接 import store 完全可以取代 context。那么 Provider 存在的意义是什么，其实笔者也想过一阵子，后来才想起…上面这个 connect 是自己写的，当然可以直接 import store，但 react-redux 的 connect 是封装的，对外只提供 api，所以需要让 Provider 传入 store。</p>
<p>\2. connect 中的装饰器模式：回顾一下 connect 的调用方式：<code>connect(mapStateToProps, mapDispatchToProps)(App)</code>其实 connect 完全可以把 App 跟着 mapStateToProps 一起传进去，看似没必要 return 一个函数再传入 App，为什么 react-redux 要这样设计，react-redux 作为一个被广泛使用的模块，其设计肯定有它的深意。</p>
<p>其实 connect 这种设计，是<strong>装饰器模式</strong>的实现，所谓装饰器模式，简单地说就是对类的一个包装，动态地拓展类的功能。connect 以及 React 中的高阶组件（HoC）都是这一模式的实现。除此之外，也有更直接的原因：这种设计能够兼容 ES7 的<code>装饰器(Decorator)</code>，使得我们可以用@connect 这样的方式来简化代码，有关@connect 的使用可以看这篇<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jianshu.com/p/d07ccef9f4f0"></a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;普通connect使用</span><br><span class="line">class App extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;hello&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function mapStateToProps(state)&#123;</span><br><span class="line">    return state.main</span><br><span class="line">&#125;</span><br><span class="line">function mapDispatchToProps(dispatch)&#123;</span><br><span class="line">    return bindActionCreators(action,dispatch)</span><br><span class="line">&#125;</span><br><span class="line">export default connect(mapStateToProps,mapDispatchToProps)(App)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用装饰器简化</span><br><span class="line">@connect(</span><br><span class="line">  state&#x3D;&gt;state.main,</span><br><span class="line">  dispatch&#x3D;&gt;bindActionCreators(action,dispatch)</span><br><span class="line">)</span><br><span class="line">class App extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;hello&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写完了 react-redux，我们可以写个 demo 来测试一下：使用<code>create-react-app</code>创建一个项目，删掉无用的文件，并创建 store.js、reducer.js、react-redux.js 来分别写我们 redux 和 react-redux 的代码，index.js 是项目的入口文件，在 App.js 中我们简单的写一个计数器，点击按钮就派发一个 dispatch，让 store 中的 count 加一，页面上显示这个 count。最后文件目录和代码如下：<br><img src="/blog/images/react/16f21fb249ffba11.jpg"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; store.jsexport const createStore &#x3D; (reducer) &#x3D;&gt; &#123;</span><br><span class="line">  let currentState &#x3D; &#123;&#125;</span><br><span class="line">  let observers &#x3D; []             &#x2F;&#x2F;观察者队列</span><br><span class="line">  function getState() &#123;</span><br><span class="line">    return currentState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    currentState &#x3D; reducer(currentState, action)</span><br><span class="line">    observers.forEach(fn &#x3D;&gt; fn())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function subscribe(fn) &#123;</span><br><span class="line">    observers.push(fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dispatch(&#123; type: &#39;@@REDUX_INIT&#39; &#125;) &#x2F;&#x2F;初始化store数据</span><br><span class="line">  return &#123; getState, subscribe, dispatch &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;reducer.jsconst initialState &#x3D; &#123;</span><br><span class="line">  count: 0&#125;export function reducer(state &#x3D; initialState, action) &#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">      case &#39;plus&#39;:</span><br><span class="line">       return &#123;</span><br><span class="line">          ...state,</span><br><span class="line">          count: state.count + 1</span><br><span class="line">          &#125;</span><br><span class="line">      case &#39;subtract&#39;:</span><br><span class="line">      return &#123;</span><br><span class="line">        ...state,</span><br><span class="line">         count: state.count - 1</span><br><span class="line">      &#125;</span><br><span class="line">      default:</span><br><span class="line">        return initialState</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;react-redux.js</span><br><span class="line">import React from &#39;react&#39;</span><br><span class="line">import PropTypes from &#39;prop-types&#39;</span><br><span class="line">export class Provider extends React.Component &#123;</span><br><span class="line">    &#x2F;&#x2F; 需要声明静态属性childContextTypes来指定context对象的属性,是context的固定写法</span><br><span class="line">    static childContextTypes &#x3D; &#123;</span><br><span class="line">        store: PropTypes.object</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 实现getChildContext方法,返回context对象,也是固定写法</span><br><span class="line">    getChildContext() &#123;</span><br><span class="line">        return &#123; store: this.store &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(props, context) &#123;</span><br><span class="line">        super(props, context)</span><br><span class="line">        this.store &#x3D; props.store</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 渲染被Provider包裹的组件</span><br><span class="line">    render() &#123;</span><br><span class="line">        return this.props.children</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function connect(mapStateToProps, mapDispatchToProps) &#123;</span><br><span class="line">    return function(Component) &#123;</span><br><span class="line">    class Connect extends React.Component &#123;</span><br><span class="line">        componentDidMount() &#123;          &#x2F;&#x2F;从context获取store并订阅更新</span><br><span class="line">            this.context.store.subscribe(this.handleStoreChange.bind(this));</span><br><span class="line">        &#125;</span><br><span class="line">        handleStoreChange() &#123;</span><br><span class="line">            &#x2F;&#x2F; 触发更新</span><br><span class="line">            &#x2F;&#x2F; 触发的方法有多种,这里为了简洁起见,直接forceUpdate强制更新,读者也可以通过setState来触发子组件更新</span><br><span class="line">            this.forceUpdate()</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;Component</span><br><span class="line">                    &#x2F;&#x2F; 传入该组件的props,需要由connect这个高阶组件原样传回原组件</span><br><span class="line">                    &#123; ...this.props &#125;</span><br><span class="line">                    &#x2F;&#x2F; 根据mapStateToProps把state挂到this.props上</span><br><span class="line">                    &#123; ...mapStateToProps(this.context.store.getState()) &#125;</span><br><span class="line">                    &#x2F;&#x2F; 根据mapDispatchToProps把dispatch(action)挂到this.props上</span><br><span class="line">                    &#123; ...mapDispatchToProps(this.context.store.dispatch) &#125;</span><br><span class="line">                &#x2F;&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;接收context的固定写法</span><br><span class="line">    Connect.contextTypes &#x3D; &#123;</span><br><span class="line">        store: PropTypes.object</span><br><span class="line">    &#125;</span><br><span class="line">    return Connect</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;index.jsimport React from &#39;react&#39;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line">import &#123; Provider &#125; from &#39;.&#x2F;react-redux&#39;</span><br><span class="line">import &#123; createStore &#125; from &#39;.&#x2F;store&#39;</span><br><span class="line">import &#123; reducer &#125; from &#39;.&#x2F;reducer&#39;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store&#x3D;&#123;createStore(reducer)&#125;&gt;</span><br><span class="line">   &lt;App &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;Provider&gt;,</span><br><span class="line">  document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;App.js</span><br><span class="line">import React from &#39;react&#39;</span><br><span class="line">import &#123; connect &#125; from &#39;.&#x2F;react-redux&#39;</span><br><span class="line"></span><br><span class="line">const addCountAction &#x3D; &#123;</span><br><span class="line">    type: &#39;plus&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapStateToProps &#x3D; state &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        count: state.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps &#x3D; dispatch &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        addCount: () &#x3D;&gt; &#123;</span><br><span class="line">            dispatch(addCountAction)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className&#x3D;&quot;App&quot;&gt;</span><br><span class="line">                &#123; this.props.count &#125;</span><br><span class="line">                &lt;button onClick&#x3D;&#123; () &#x3D;&gt; this.props.addCount() &#125;&gt;增加&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(App)</span><br></pre></td></tr></table></figure>
<p>运行项目，点击增加按钮，能够正确的计数，OK 大成功，我们整个 redux、react-redux 的流程就走通了<br><img src="/blog/images/react/16f220600b322f69.jpg"></p>
<h2 id="三-redux-Middleware-实现"><a href="#三-redux-Middleware-实现" class="headerlink" title="三. redux Middleware 实现"></a>三. redux Middleware 实现</h2><p>上面 redux 和 react-redux 的实现都比较简单，下面我们来分析实现稍困难一些的<strong>redux 中间件</strong>。所谓中间件，我们可以理解为拦截器，用于对某些过程进行拦截和处理，且中间件之间能够串联使用。在 redux 中，我们中间件拦截的是 dispatch 提交到 reducer 这个过程，从而增强 dispatch 的功能。<br><img src="/blog/images/react/16f44c0ad62d8656.jpg"></p>
<p>我查阅了很多 redux 中间件相关的资料，但最后发现没有一篇写的比<a target="_blank" rel="noopener external nofollow noreferrer" href="https://redux.js.org/advanced/middleware/">官方文档</a>清晰，文档从中间件的需求到设计，从概念到实现，每一步都有清晰生动的讲解。下面我们就和文档一样，以一个记录日志的中间件为例，一步一步分析 redux 中间件的设计实现。</p>
<p>我们思考一下，如果我们想在每次 dispatch 之后，打印一下 store 的内容，我们会如何实现呢：</p>
<h3 id="1-在每次-dispatch-之后手动打印-store-的内容"><a href="#1-在每次-dispatch-之后手动打印-store-的内容" class="headerlink" title="1. 在每次 dispatch 之后手动打印 store 的内容"></a>1. 在每次 dispatch 之后手动打印 store 的内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(&#123; type: &#39;plus&#39; &#125;)</span><br><span class="line">console.log(&#39;next state&#39;, store.getState())</span><br></pre></td></tr></table></figure>
<p>这是最直接的方法，当然我们不可能在项目里每个 dispatch 后面都粘贴一段打印日志的代码，我们至少要把这部分功能提取出来。</p>
<h3 id="2-封装-dispatch"><a href="#2-封装-dispatch" class="headerlink" title="2. 封装 dispatch"></a>2. 封装 dispatch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function dispatchAndLog(store, action) &#123;</span><br><span class="line">  store.dispatch(action)</span><br><span class="line">  console.log(&#39;next state&#39;, store.getState())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以重新封装一个公用的新的 dispatch 方法，这样可以减少一部分重复的代码。不过每次使用这个新的 dispatch 都得从外部引一下，还是比较麻烦。</p>
<h3 id="3-替换-dispatch"><a href="#3-替换-dispatch" class="headerlink" title="3. 替换 dispatch"></a>3. 替换 dispatch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let next &#x3D; store.dispatchstore.dispatch &#x3D; function dispatchAndLog(action) &#123;</span><br><span class="line">  let result &#x3D; next(action)</span><br><span class="line">  console.log(&#39;next state&#39;, store.getState())</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们直接把 dispatch 给替换，这样每次使用的时候不就不需要再从外部引用一次了吗？对于单纯打印日志来说，这样就足够了，但是如果我们还有一个监控 dispatch 错误的需求呢，我们固然可以在打印日志的代码后面加上捕获错误的代码，但随着功能模块的增多，代码量会迅速膨胀，以后这个中间件就没法维护了，我们希望不同的功能是<strong>独立的可拔插的</strong>模块。</p>
<h3 id="4-模块化"><a href="#4-模块化" class="headerlink" title="4. 模块化"></a>4. 模块化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印日志中间件function patchStoreToAddLogging(store) &#123;</span><br><span class="line">  let next &#x3D; store.dispatch    &#x2F;&#x2F;此处也可以写成匿名函数</span><br><span class="line">  store.dispatch &#x3D; function dispatchAndLog(action) &#123;</span><br><span class="line">    let result &#x3D; next(action)</span><br><span class="line">    console.log(&#39;next state&#39;, store.getState())</span><br><span class="line">    return result</span><br><span class="line">  &#125;&#125;  &#x2F;&#x2F; 监控错误中间件</span><br><span class="line"></span><br><span class="line">  function patchStoreToAddCrashReporting(store) &#123;        &#x2F;&#x2F;这里取到的dispatch已经是被上一个中间件包装过的dispatch, 从而实现中间件串联</span><br><span class="line">  let next &#x3D; store.dispatch</span><br><span class="line">  store.dispatch &#x3D; function dispatchAndReportErrors(action) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return next(action)</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(&#39;捕获一个异常!&#39;, err)</span><br><span class="line">      throw err</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>我们把不同功能的模块拆分成不同的方法，通过在方法内<strong>获取上一个中间件包装过的 store.dispatch 实现链式调用</strong>。然后我们就能通过调用这些中间件方法，分别使用、组合这些中间件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchStoreToAddLogging(store)patchStoreToAddCrashReporting(store)</span><br></pre></td></tr></table></figure>
<p>到这里我们基本实现了可组合、拔插的中间件，但我们仍然可以把代码再写好看一点。我们注意到，我们当前写的中间件方法都是先获取 dispatch，然后在方法内替换 dispatch，这部分重复代码我们可以再稍微简化一下：我们不在方法内替换 dispatch，而是返回一个新的 dispatch，然后让循环来进行每一步的替换。</p>
<h3 id="5-applyMiddleware"><a href="#5-applyMiddleware" class="headerlink" title="5. applyMiddleware"></a>5. applyMiddleware</h3><p>改造一下中间件，使其返回新的 dispatch 而不是替换原 dispatch</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function logger(store) &#123;</span><br><span class="line">    let next &#x3D; store.dispatch</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 我们之前的做法(在方法内直接替换dispatch):</span><br><span class="line">    &#x2F;&#x2F; store.dispatch &#x3D; function dispatchAndLog(action) &#123;</span><br><span class="line">    &#x2F;&#x2F;         ...</span><br><span class="line">    &#x2F;&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">    return function dispatchAndLog(action) &#123;</span><br><span class="line">        let result &#x3D; next(action)</span><br><span class="line">        console.log(&#39;next state&#39;, store.getState())</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Redux 中增加一个辅助方法 applyMiddleware，用于添加中间件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function applyMiddleware(store, middlewares) &#123;</span><br><span class="line">  middlewares &#x3D; [ ...middlewares ]    &#x2F;&#x2F;浅拷贝数组, 避免下面reserve()影响原数组</span><br><span class="line">  middlewares.reverse()               &#x2F;&#x2F;由于循环替换dispatch时,前面的中间件在最里层,因此需要翻转数组才能保证中间件的调用顺序          &#x2F;&#x2F; 循环替换dispatch</span><br><span class="line">  middlewares.forEach(middleware &#x3D;&gt;</span><br><span class="line">    store.dispatch &#x3D; middleware(store)</span><br><span class="line">  )&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就能以这种形式增加中间件了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applyMiddleware(store, [ logger, crashReporter ])</span><br></pre></td></tr></table></figure>
<p>写到这里，我们可以简单地测试一下中间件。我创建了三个中间件，分别是 logger1、thunk、logger2，其作用也很简单，打印 logger1 -&gt; 执行异步 dispatch -&gt; 打印 logger2，我们通过这个例子观察中间件的执行顺序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;index.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;;</span><br><span class="line">import &#123; Provider &#125; from &#39;.&#x2F;react-redux&#39;</span><br><span class="line">import &#123; createStore &#125; from &#39;.&#x2F;store&#39;</span><br><span class="line">import &#123; reducer &#125; from &#39;.&#x2F;reducer&#39;</span><br><span class="line"></span><br><span class="line">let store &#x3D; createStore(reducer)</span><br><span class="line"></span><br><span class="line">function logger(store) &#123;</span><br><span class="line">    let next &#x3D; store.dispatch</span><br><span class="line">    return (action) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;logger1&#39;)</span><br><span class="line">        let result &#x3D; next(action)</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function thunk(store) &#123;</span><br><span class="line">    let next &#x3D; store.dispatch</span><br><span class="line">    return (action) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;thunk&#39;)</span><br><span class="line">        return typeof action &#x3D;&#x3D;&#x3D; &#39;function&#39; ? action(store.dispatch) : next(action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function logger2(store) &#123;</span><br><span class="line">    let next &#x3D; store.dispatch</span><br><span class="line">    return (action) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;logger2&#39;)</span><br><span class="line">        let result &#x3D; next(action)</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function applyMiddleware(store, middlewares) &#123;</span><br><span class="line">    middlewares &#x3D; [ ...middlewares ]</span><br><span class="line">    middlewares.reverse()</span><br><span class="line">    middlewares.forEach(middleware &#x3D;&gt;</span><br><span class="line">        store.dispatch &#x3D; middleware(store)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">applyMiddleware(store, [ logger, thunk, logger2 ])</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Provider store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">        &lt;App &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Provider&gt;,</span><br><span class="line">    document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>发出异步 dispatch</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function addCountAction(dispatch) &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    dispatch(&#123; type: &#39;plus&#39; &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(addCountAction)</span><br></pre></td></tr></table></figure>
<p>输出结果<br><img src="/blog/images/react/16f601ddb960c8ba.jpg"></p>
<p>可以看到，控制台先输出了中间件 logger1 的打印结果，然后进入 thunk 中间件打印了’thunk’，等待一秒后，异步 dispatch 被触发，又重新走了一遍 logger1 -&gt; thunk -&gt; logger2。到这里，我们就基本实现了可拔插、可组合的中间件机制，还顺便实现了 redux-thunk。</p>
<h3 id="6-纯函数"><a href="#6-纯函数" class="headerlink" title="6. 纯函数"></a>6. 纯函数</h3><p>之前的例子已经基本实现我们的需求，但我们还可以进一步改进，上面这个函数看起来仍然不够“纯”，函数在函数体内修改了 store 自身的 dispatch，产生了所谓的“副作用”，从函数式编程的规范出发，我们可以进行一些改造，借鉴 react-redux 的实现思路，我们可以把 applyMiddleware 作为高阶函数，用于增强 store，而不是替换 dispatch：</p>
<p>先对 createStore 进行一个小改造，传入 heightener（即 applyMiddleware），heightener 接收并强化 createStore。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; store.js</span><br><span class="line">export const createStore &#x3D; (reducer, heightener) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; heightener是一个高阶函数,用于增强createStore</span><br><span class="line">    &#x2F;&#x2F;如果存在heightener,则执行增强后的createStore</span><br><span class="line">    if (heightener) &#123;</span><br><span class="line">        return heightener(createStore)(reducer)</span><br><span class="line">    &#125;</span><br><span class="line">    let currentState &#x3D; &#123;&#125;</span><br><span class="line">    let observers &#x3D; []             &#x2F;&#x2F;观察者队列</span><br><span class="line">    function getState() &#123;</span><br><span class="line">        return currentState</span><br><span class="line">    &#125;</span><br><span class="line">    function dispatch(action) &#123;</span><br><span class="line">        currentState &#x3D; reducer(currentState, action);</span><br><span class="line">        observers.forEach(fn &#x3D;&gt; fn())</span><br><span class="line">    &#125;</span><br><span class="line">    function subscribe(fn) &#123;</span><br><span class="line">        observers.push(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(&#123; type: &#39;@@REDUX_INIT&#39; &#125;)&#x2F;&#x2F;初始化store数据</span><br><span class="line">    return &#123; getState, subscribe, dispatch &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中间件进一步柯里化，让 next 通过参数传入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const logger &#x3D; store &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;log1&#39;)</span><br><span class="line">    let result &#x3D; next(action)</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const thunk &#x3D; store &#x3D;&gt; next &#x3D;&gt;action &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;thunk&#39;)</span><br><span class="line">    const &#123; dispatch, getState &#125; &#x3D; store</span><br><span class="line">    return typeof action &#x3D;&#x3D;&#x3D; &#39;function&#39; ? action(store.dispatch) : next(action)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const logger2 &#x3D; store &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;log2&#39;)</span><br><span class="line">    let result &#x3D; next(action)</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改造 applyMiddleware</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const applyMiddleware &#x3D; (...middlewares) &#x3D;&gt; createStore &#x3D;&gt; reducer &#x3D;&gt; &#123;</span><br><span class="line">    const store &#x3D; createStore(reducer)</span><br><span class="line">    let &#123; getState, dispatch &#125; &#x3D; store</span><br><span class="line">    const params &#x3D; &#123;</span><br><span class="line">        getState,</span><br><span class="line">        dispatch: (action) &#x3D;&gt; dispatch(action)</span><br><span class="line">        &#x2F;&#x2F;解释一下这里为什么不直接 dispatch: dispatch</span><br><span class="line">        &#x2F;&#x2F;因为直接使用dispatch会产生闭包,导致所有中间件都共享同一个dispatch,如果有中间件修改了dispatch或者进行异步dispatch就可能出错</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const middlewareArr &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(params))</span><br><span class="line"></span><br><span class="line">    dispatch &#x3D; compose(...middlewareArr)(dispatch)</span><br><span class="line">    return &#123; ...store, dispatch &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;compose这一步对应了middlewares.reverse(),是函数式编程一种常见的组合方法</span><br><span class="line">function compose(...fns) &#123;</span><br><span class="line">    if (fns.length &#x3D;&#x3D;&#x3D; 0) return arg &#x3D;&gt; arg</span><br><span class="line">    if (fns.length &#x3D;&#x3D;&#x3D; 1) return fns[0]</span><br><span class="line">    return fns.reduce((res, cur) &#x3D;&gt;(...args) &#x3D;&gt; res(cur(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码应该不难看懂，在上一个例子的基础上，我们主要做了两个改造</p>
<p>\1. 使用 compose 方法取代了 middlewares.reverse()，compose 是函数式编程中常用的一种组合函数的方式，compose 内部使用 reduce 巧妙地组合了中间件函数，使传入的中间件函数变成<code>(...arg) =&gt; mid1(mid2(mid3(...arg)))</code>这种形式</p>
<p>\2. 不直接替换 dispatch，而是作为高阶函数增强 createStore，最后 return 的是一个新的 store</p>
<h3 id="7-洋葱圈模型"><a href="#7-洋葱圈模型" class="headerlink" title="7.洋葱圈模型"></a>7.洋葱圈模型</h3><p>之所以把洋葱圈模型放到后面来讲，是因为洋葱圈和前边中间件的实现并没有很紧密的关系，为了避免读者混淆，放到这里再提一下。我们直接放出三个打印日志的中间件，观察输出结果，就能很轻易地看懂洋葱圈模型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const logger1 &#x3D; store &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;进入log1&#39;)</span><br><span class="line">    let result &#x3D; next(action)</span><br><span class="line">    console.log(&#39;离开log1&#39;)</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const logger2 &#x3D; store &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;进入log2&#39;)</span><br><span class="line">    let result &#x3D; next(action)</span><br><span class="line">    console.log(&#39;离开log2&#39;)</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const logger3 &#x3D; store &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;进入log3&#39;)</span><br><span class="line">    let result &#x3D; next(action)</span><br><span class="line">    console.log(&#39;离开log3&#39;)</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果<br><img src="/blog/images/react/16f602b97933b126.jpg"></p>
<p>由于我们的中间件是这样的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">logger1(</span><br><span class="line">    console.log(&#39;进入logger1&#39;)</span><br><span class="line">        logger2(</span><br><span class="line">            console.log(&#39;进入logger2&#39;)</span><br><span class="line">                logger3(</span><br><span class="line">                    console.log(&#39;进入logger3&#39;)</span><br><span class="line">                    &#x2F;&#x2F;dispatch()</span><br><span class="line">                    console.log(&#39;离开logger3&#39;)</span><br><span class="line">                )</span><br><span class="line">            console.log(&#39;离开logger2&#39;)</span><br><span class="line">        )</span><br><span class="line">    console.log(&#39;离开logger1&#39;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>因此我们可以看到，中间件的执行顺序实际上是这样的：</p>
<p>进入 log1 -&gt; 执行 next -&gt; 进入 log2 -&gt; 执行 next -&gt; 进入 log3 -&gt; 执行 next -&gt; next 执行完毕 -&gt; 离开 log3 -&gt; 回到上一层中间件,执行上层中间件 next 之后的语句 -&gt; 离开 log2 -&gt; 回到中间件 log1, 执行 log1 的 next 之后的语句 -&gt; 离开 log1</p>
<blockquote>
<p>这就是所谓的“洋葱圈模型”<br><img src="/blog/images/react/16f60342f3c7758e.jpg"></p>
</blockquote>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/06/28/webpack/webpack/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">webpack</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/06/18/vue/mvvm/"><span class="level-item">mvvm实现</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="SOHUCS" sid="2021/06/21/react/redux-analysis/"></div><script charset="utf-8" src="https://changyan.sohu.com/upload/changyan.js"></script><script>window.changyan.api.config({appid: 'cyvf8qdnv',conf: '81e7eedb51850a20f9b383d2ba64740c'});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Redux-react-redux-redux-中间件设计实现剖析"><span class="level-left"><span class="level-item">Redux/react-redux/redux 中间件设计实现剖析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#一-redux-的实现"><span class="level-left"><span class="level-item">一. redux 的实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-getState-实现"><span class="level-left"><span class="level-item">1. getState 实现</span></span></a></li><li><a class="level is-mobile" href="#2-dispatch-实现"><span class="level-left"><span class="level-item">2.dispatch 实现</span></span></a></li><li><a class="level is-mobile" href="#3-subscribe-实现"><span class="level-left"><span class="level-item">3.subscribe 实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二-react-redux-的实现"><span class="level-left"><span class="level-item">二. react-redux 的实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-Provider-实现"><span class="level-left"><span class="level-item">1. Provider 实现</span></span></a></li><li><a class="level is-mobile" href="#2-connect-实现"><span class="level-left"><span class="level-item">2. connect 实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三-redux-Middleware-实现"><span class="level-left"><span class="level-item">三. redux Middleware 实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-在每次-dispatch-之后手动打印-store-的内容"><span class="level-left"><span class="level-item">1. 在每次 dispatch 之后手动打印 store 的内容</span></span></a></li><li><a class="level is-mobile" href="#2-封装-dispatch"><span class="level-left"><span class="level-item">2. 封装 dispatch</span></span></a></li><li><a class="level is-mobile" href="#3-替换-dispatch"><span class="level-left"><span class="level-item">3. 替换 dispatch</span></span></a></li><li><a class="level is-mobile" href="#4-模块化"><span class="level-left"><span class="level-item">4. 模块化</span></span></a></li><li><a class="level is-mobile" href="#5-applyMiddleware"><span class="level-left"><span class="level-item">5. applyMiddleware</span></span></a></li><li><a class="level is-mobile" href="#6-纯函数"><span class="level-left"><span class="level-item">6. 纯函数</span></span></a></li><li><a class="level is-mobile" href="#7-洋葱圈模型"><span class="level-left"><span class="level-item">7.洋葱圈模型</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/css/"><span class="tag">css</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/http/"><span class="tag">http</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js/"><span class="tag">js</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js-%E9%80%BB%E8%BE%91%E9%A2%98/"><span class="tag">js_逻辑题</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/react/"><span class="tag">react</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redux/"><span class="tag">redux</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webpack/"><span class="tag">webpack</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/websocket/"><span class="tag">websocket</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB%E5%88%B6%E5%BA%A6/"><span class="tag">中国政治制度</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AC%E5%85%B1%E6%94%BF%E7%AD%96/"><span class="tag">公共政策</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%AC%E5%8A%A1%E5%91%98%E5%88%B6%E5%BA%A6/"><span class="tag">公务员制度</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%B6%E4%BB%96/"><span class="tag">其他</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="tag">小程序</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A4%BE%E4%BC%9A%E5%AD%A6/"><span class="tag">社会学</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%85%8D%E7%BD%AE/"><span class="tag">配置</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">40</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener external nofollow noreferrer"><span class="level-left"><span class="level-item">ES6教程</span></span><span class="level-right"><span class="level-item tag">es6.ruanyifeng.com</span></span></a></li><li><a class="level is-mobile" href="https://react.html.cn/" target="_blank" rel="noopener external nofollow noreferrer"><span class="level-left"><span class="level-item">React</span></span><span class="level-right"><span class="level-item tag">react.html.cn</span></span></a></li><li><a class="level is-mobile" href="https://www.tslang.cn/docs/handbook/basic-types.html" target="_blank" rel="noopener external nofollow noreferrer"><span class="level-left"><span class="level-item">Typescript</span></span><span class="level-right"><span class="level-item tag">www.tslang.cn</span></span></a></li><li><a class="level is-mobile" href="https://www.iconfont.cn/" target="_blank" rel="noopener external nofollow noreferrer"><span class="level-left"><span class="level-item">iconfont</span></span><span class="level-right"><span class="level-item tag">www.iconfont.cn</span></span></a></li><li><a class="level is-mobile" href="https://dvajs.com/" target="_blank" rel="noopener external nofollow noreferrer"><span class="level-left"><span class="level-item">Dva</span></span><span class="level-right"><span class="level-item tag">dvajs.com</span></span></a></li><li><a class="level is-mobile" href="https://taro-docs.jd.com/taro/docs/apis/about/desc" target="_blank" rel="noopener external nofollow noreferrer"><span class="level-left"><span class="level-item">Taro</span></span><span class="level-right"><span class="level-item tag">taro-docs.jd.com</span></span></a></li><li><a class="level is-mobile" href="https://panjiachen.gitee.io/vue-element-admin-site/zh/" target="_blank" rel="noopener external nofollow noreferrer"><span class="level-left"><span class="level-item">vue-element-admin</span></span><span class="level-right"><span class="level-item tag">panjiachen.gitee.io</span></span></a></li><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener external nofollow noreferrer"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://scott_xia.gitee.io/static-resources/img/header.jpg" alt="Scott_xia"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Scott_xia</p><p class="is-size-6 is-block">Web Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>AnHui HeFei</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">79</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">16</p></a></div></div></nav></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/css/"><span class="level-start"><span class="level-item">css</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/html/"><span class="level-start"><span class="level-item">html</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/http/"><span class="level-start"><span class="level-item">http</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/js/"><span class="level-start"><span class="level-item">js</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/react/"><span class="level-start"><span class="level-item">react</span></span><span class="level-end"><span class="level-item tag">30</span></span></a></li><li><a class="level is-mobile" href="/categories/script/"><span class="level-start"><span class="level-item">script</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/vue/"><span class="level-start"><span class="level-item">vue</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/webpack/"><span class="level-start"><span class="level-item">webpack</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="level-start"><span class="level-item">小程序</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/"><span class="level-start"><span class="level-item">行政管理</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%85%8D%E7%BD%AE/"><span class="level-start"><span class="level-item">配置</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2021/12/13/js/gitcommit/"><img src="/images/bgi/snow.jpg" alt="git Commit"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-12-13T02:51:54.000Z">2021-12-13</time></p><p class="title"><a href="/2021/12/13/js/gitcommit/">git Commit</a></p><p class="categories"><a href="/categories/js/">js</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/09/07/typesctipt/ts_uitls/"><img src="/images/bgi/bluebg.jpg" alt="ts_泛型工具"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-09-07T07:59:55.000Z">2021-09-07</time></p><p class="title"><a href="/2021/09/07/typesctipt/ts_uitls/">ts_泛型工具</a></p><p class="categories"><a href="/categories/%E5%85%B6%E4%BB%96/">其他</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/09/02/js/d3/"><img src="/images/bgi/greenVue.jpg" alt="d3入门"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-09-02T04:01:28.000Z">2021-09-02</time></p><p class="title"><a href="/2021/09/02/js/d3/">d3入门</a></p><p class="categories"><a href="/categories/js/">js</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/08/30/js/generator/"><img src="/images/bgi/code.jpg" alt="Generator"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-08-30T08:05:11.000Z">2021-08-30</time></p><p class="title"><a href="/2021/08/30/js/generator/">Generator</a></p><p class="categories"><a href="/categories/js/">js</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/08/30/react/utils/"><img src="/images/bgi/book2.jpg" alt="utils"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-08-30T05:18:46.000Z">2021-08-30</time></p><p class="title"><a href="/2021/08/30/react/utils/">utils</a></p><p class="categories"><a href="/categories/js/">js</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://scott_xia.gitee.io/static-resources/img/header.jpg" alt="Scott&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Scott_xia</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener external nofollow noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener external nofollow noreferrer">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener external nofollow noreferrer" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener external nofollow noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener external nofollow noreferrer" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;" rel="external nofollow noreferrer"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;" rel="external nofollow noreferrer">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script type="text/javascript" src="https://cdn.staticfile.org/jquery/1.10.2/jquery.js"></script><script type="text/javascript" src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" color="34,139,34" opacity="0.7" zIndex="-2" count="50" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>