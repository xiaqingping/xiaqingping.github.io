{"pages":[{"title":"ABOUT","text":"Scott_Xia的博客关于本站 使用 Hexo 搭建 托管在 gitee Pages 主题 hexo-theme-icarus 图床为阿里云存储 关于本站搭建可参考借鉴于这里","link":"/about/index.html"},{"title":"","text":".table-c table { border-right: 1px solid #dbdbdb; border-bottom: 1px solid #dbdbdb; } .table-c table td { border-left: 1px solid #dbdbdb; border-top: 1px solid #dbdbdb; } .table-c table td.td1 { text-align: center; vertical-align: middle; }","link":"/styles/index.css"}],"posts":[{"title":"react-redux","text":"React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）。 一、UI 组件UI 组件有以下几个特征。 只负责 UI 的呈现，不带有任何业务逻辑 没有状态（即不使用this.state这个变量） 所有数据都由参数（this.props）提供 不使用任何 Redux 的 API 下面就是一个 UI 组件的例子。 12const Title = value =&gt; &lt;h1&gt;{value}&lt;/h1&gt;; 因为不含有状态，UI 组件又称为”纯组件”，即它纯函数一样，纯粹由参数决定它的值。 二、容器组件容器组件的特征恰恰相反。 负责管理数据和业务逻辑，不负责 UI 的呈现 带有内部状态 使用 Redux 的 API 总之，只要记住一句话就可以了：UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。 你可能会问，如果一个组件既有 UI 又有业务逻辑，那怎么办？回答是，将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。 React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。 三、connect()React-Redux 提供connect方法，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来。 12import { connect } from 'react-redux'const VisibleTodoList = connect()(TodoList); 上面代码中，TodoList是 UI 组件，VisibleTodoList就是由 React-Redux 通过connect方法自动生成的容器组件。 但是，因为没有定义业务逻辑，上面这个容器组件毫无意义，只是 UI 组件的一个单纯的包装层。为了定义业务逻辑，需要给出下面两方面的信息。 （1）输入逻辑：外部的数据（即state对象）如何转换为 UI 组件的参数 （2）输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。 因此，connect方法的完整 API 如下。 123456import { connect } from 'react-redux'const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList) 上面代码中，connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action 四、mapStateToProps()mapStateToProps是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。 作为函数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。请看下面的例子。 12345const mapStateToProps = (state) =&gt; { return { todos: getVisibleTodos(state.todos, state.visibilityFilter) }} 上面代码中，mapStateToProps是一个函数，它接受state作为参数，返回一个对象。这个对象有一个todos属性，代表 UI 组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出 todos 的值。 下面就是getVisibleTodos的一个例子，用来算出todos。 123456789101112const getVisibleTodos = (todos, filter) =&gt; { switch (filter) { case 'SHOW_ALL': return todos case 'SHOW_COMPLETED': return todos.filter(t =&gt; t.completed) case 'SHOW_ACTIVE': return todos.filter(t =&gt; !t.completed) default: throw new Error('Unknown filter: ' + filter) }} mapStateToProps会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。 mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。 12345678910// 容器组件的代码// &lt;FilterLink filter=&quot;SHOW_ALL&quot;&gt;// All// &lt;/FilterLink&gt;const mapStateToProps = (state, ownProps) =&gt; { return { active: ownProps.filter === state.visibilityFilter }} 使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。 connect方法可以省略mapStateToProps参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新。 五、mapDispatchToProps()mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。 如果mapDispatchToProps是一个函数，会得到dispatch和ownProps（容器组件的props对象）两个参数。 12345678910111213const mapDispatchToProps = ( dispatch, ownProps) =&gt; { return { onClick: () =&gt; { dispatch({ type: 'SET_VISIBILITY_FILTER', filter: ownProps.filter }); } };} 从上面代码可以看到，mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。 如果mapDispatchToProps是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。举例来说，上面的mapDispatchToProps写成对象就是下面这样。 123456const mapDispatchToProps = { onClick: (filter) =&gt; { type: 'SET_VISIBILITY_FILTER', filter: filter };}","link":"/2021/01/07/react/react-redux/"},{"title":"redux","text":"redux学习笔记 什么是redux Redux是一个流行的JavaScript框架，为应用程序提供一个可预测的状态容器。 redux的基本概念在标准的MVC框架中，数据可以在UI组件和存储之间双向流动，而Redux严格限制了数据只能在一个方向上流动。 在Redux中，所有的数据（比如state）被保存在一个被称为store的容器中 → 在一个应用程序中只能有一个。store本质上是一个状态树，保存了所有对象的状态。任何UI组件都可以直接从store访问特定对象的状态。要通过本地或远程组件更改状态，需要分发一个action。分发在这里意味着将可执行信息发送到store。当一个store接收到一个action，它将把这个action代理给相关的reducer。reducer是一个纯函数，它可以查看之前的状态，执行一个action并且返回一个新的状态。 配置redux123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// src/index.jsimport { createStore } from &quot;redux&quot;;import { combineReducers } from 'redux';const productsReducer = function(state=[], action) { return state;}const initialState = { cart: [ { product: 'bread 700g', quantity: 2, unitCost: 90 }, { product: 'milk 500ml', quantity: 1, unitCost: 47 } ]}const ADD_TO_CART = 'ADD_TO_CART';const cartReducer = function(state=initialState, action) { switch (action.type) { case ADD_TO_CART: { return { ...state, cart: [...state.cart, action.payload] } } default: return state; }}function addToCart(product, quantity, unitCost) { return { type: ADD_TO_CART, payload: { product, quantity, unitCost } }}const allReducers = { products: productsReducer, shoppingCart: cartReducer}const rootReducer = combineReducers(allReducers);let store = createStore(rootReducer);console.log(&quot;initial state: &quot;, store.getState());let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));store.dispatch(addToCart('Coffee 500gm', 1, 250));store.dispatch(addToCart('Flour 1kg', 2, 110));store.dispatch(addToCart('Juice 2L', 1, 250));unsubscribe(); 组织Redux代码123456789src/├── actions│ └── cart-actions.js├── index.js├── reducers│ ├── cart-reducer.js│ ├── index.js│ └── products-reducer.js└── store.js 然后，我们把index.js中的代码进行整理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// src/actions/cart-actions.jsexport const ADD_TO_CART = 'ADD_TO_CART';export function addToCart(product, quantity, unitCost) { return { type: ADD_TO_CART, payload: { product, quantity, unitCost } }}// src/reducers/products-reducer.jsexport default function(state=[], action) { return state;}// src/reducers/cart-reducer.jsimport { ADD_TO_CART } from '../actions/cart-actions';const initialState = { cart: [ { product: 'bread 700g', quantity: 2, unitCost: 90 }, { product: 'milk 500ml', quantity: 1, unitCost: 47 } ]}export default function(state=initialState, action) { switch (action.type) { case ADD_TO_CART: { return { ...state, cart: [...state.cart, action.payload] } } default: return state; }}// src/reducers/index.jsimport { combineReducers } from 'redux';import productsReducer from './products-reducer';import cartReducer from './cart-reducer';const allReducers = { products: productsReducer, shoppingCart: cartReducer}const rootReducer = combineReducers(allReducers);export default rootReducer;// src/store.jsimport { createStore } from &quot;redux&quot;;import rootReducer from './reducers';let store = createStore(rootReducer);export default store;// src/index.jsimport store from './store.js';import { addToCart } from './actions/cart-actions';console.log(&quot;initial state: &quot;, store.getState());let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));store.dispatch(addToCart('Coffee 500gm', 1, 250));store.dispatch(addToCart('Flour 1kg', 2, 110));store.dispatch(addToCart('Juice 2L', 1, 250));unsubscribe(); 整理完代码之后，程序依然会正常运行。现在我们来添加修改和删除购物车中商品的逻辑。修改cart-actions.js和cart-reducer.js文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// src/reducers/cart-actions.js…export const UPDATE_CART = 'UPDATE_CART';export const DELETE_FROM_CART = 'DELETE_FROM_CART';…export function updateCart(product, quantity, unitCost) { return { type: UPDATE_CART, payload: { product, quantity, unitCost } }}export function deleteFromCart(product) { return { type: DELETE_FROM_CART, payload: { product } }}// src/reducers/cart-reducer.js…export default function(state=initialState, action) { switch (action.type) { case ADD_TO_CART: { return { ...state, cart: [...state.cart, action.payload] } } case UPDATE_CART: { return { ...state, cart: state.cart.map(item =&gt; item.product === action.payload.product ? action.payload : item) } } case DELETE_FROM_CART: { return { ...state, cart: state.cart.filter(item =&gt; item.product !== action.payload.product) } } default: return state; }} 最后，我们在index.js中分发这两个action： 12345678// src/index.js…// Update Cartstore.dispatch(updateCart('Flour 1kg', 5, 110));// Delete from Cartstore.dispatch(deleteFromCart('Coffee 500gm'));… 保存完代码之后，可以在浏览器的控制台中检查修改和删除的结果。","link":"/2021/01/06/react/redux/"},{"title":"伊卡洛斯的配置","text":"_config.xml这里首先要知道在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml，它们均是用于站点配置使用的。其中，一份位于站点根目录下（比如我的：D:\\h2pl.github.io_config.yml），主要包含 Hexo 本身整站的配置；另一份位于主题目录（D:\\hexo\\themes\\icaurs_config.yml）下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。下面我们先来看看站点配置文件的配置修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 程序员江湖 #主页标题subtitle: 黄小斜的博客 #副标题description: 大厂程序员，互联网行业新知，终身学习践行者 # 网站描述，可以加一句自己喜欢的座右铭author: 黄小斜 #作者，左下角显示avatar: /images/hxx.jpg #设置头像，放在\\themes\\next\\source\\images里language: zh-Hans # 选择中文简体timezone:since: 2018 #建站日期，左下角显示# 多说 ShortNamebusuanzi: enable: true#duoshuo_shortname: your_username # 多说评论，后面填写用户名# 百度分析baidu_analytics: 2289335dd443797b5867abbd156e7575 # 填写自己获得的id#Social linkslinks: 我的简书: https://www.jianshu.com/users/9ab8d7b38c4e Github: https://github.com/h2pl Email: mailto:362294931@qq.com 知乎: https://www.zhihu.com/people/h2pl CSDN: https://blog.csdn.net/a724888 # URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://h2pl.github.io/ #填自己的github pages网址root: /permalink: :year/:month/:day/:title/permalink_defaults:# 本地搜索search: path: search.xml field: post# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: true# 语法高亮highlight: enable: true line_number: true auto_detect: true tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/# 百度网站地图plugins:#busuanzi:# enable: truebaidusitemap: # 需要安装插件 npm install hexo-generator-baidu-sitemap@0.1.1 --save path: baidusitemap.xml# 主题切换theme: icarus# RSS订阅feed: type: atom path: atom.xml limit: 0# ---------------下面选项需要对应插件的支持---------------# npm install hexo-generator-index --save# npm install hexo-generator-archive --save# npm install hexo-generator-category --save# npm install hexo-generator-tag --saveindex_generator: per_page: 10 ##首页默认10篇文章标题 如果值为0不分页archive_generator: per_page: 20 ##归档页面默认20篇文章标题 yearly: true ##生成年视图 monthly: true ##生成月视图tag_generator: per_page: 10 ##标签分类页面默认10篇文章category_generator: per_page: 10 ###分类页面默认10篇文章# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git# 填上你自己的仓库名，注意后面有`.git` repository: git@github.com:h2pl/h2pl.github.io.git branch: master- type: git repo: git@github.com:h2pl/h2pl.github.io.git branch: src extend_dirs: / ignore_hidden: false ignore_pattern: public: . icarus的主题配置文件.config_xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247# Version of the Icarus theme that is currently usedversion: 2.6.0# 你的网站图标，可以搜索在线图标制作，并将其放在images文件夹中favicon: /images/favicon.svg# Additional HTML meta tags in an array.meta: # Path or URL to RSS atom.xmlrss: /atom.xml# 显示在导航栏左侧的网站logo，同样可以自己制作logo: /images/hxx.jpg# Open Graph metadata# https://hexo.io/docs/helpers.html#open-graphopen_graph: # Facebook App ID fb_app_id: # Facebook Admin ID fb_admins: # Twitter ID twitter_id: # Twitter site twitter_site: # Google+ profile link google_plus: # Navigation bar link settingsnavbar: #菜单（显示名称：对应文件夹） menu: 主页: / 归档: /archives 分类: /categories 标签: /tags 关于: /about # 导航栏右侧图标链接 links: My GitHub: icon: fab fa-github url: 'https://github.com/h2pl/'# Footer section link settingsfooter: # 页脚图标链接 links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Download on GitHub: icon: fab fa-github url: 'https://github.com/ppoffice/hexo-theme-icarus'# 文章显示设置article: #代码主题atom-one-light亮色，atom-one-dark暗色 highlight: # Code highlight themes # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-dark # Show code copying button clipboard: true # Default folding status of the code blocks. Can be &quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded # 是否显示文章主图 thumbnail: true # 是否显示估算阅读时间 readtime: true# 搜索插件设置# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Searchsearch: # Name of the search plugin type: insight# 评论插件设置# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Commentcomment: #可选valine，disqus（科学上网）等 # Name of the comment plugin avatar: retro # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide placeholder: 要不要说点啥... # Comment Box placeholder type: valine shortname: 黄小斜# 打赏功能# https://ppoffice.github.io/hexo-theme-icarus/categories/Donation/donate: - # 阿里巴巴支付宝 type: alipay # 二维码图片 qrcode: '/images/hxx.jpg' - # 微信 type: wechat # 二维码图片 qrcode: '/images/hxx.jpg'# 分享插件设置# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Shareshare: # Share plugin name type: sharejs# Sidebar settings.# Please be noted that a sidebar is only visible when it has at least one widgetsidebar: # 左侧边栏设置 left: # 是否不随页面滚动 # https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false # right sidebar settings right: # 是否不随页面滚动 # https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false# 边栏小部件设置# https://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: - # Widget name type: profile # Where should the widget be placed, left or right position: left # Author name to be shown in the profile widget author: 黄小斜 # Title of the author to be shown in the profile widget author_title: 蚂蚁金服Java工程师 # Author's current location to be shown in the profile widget location: 浙江 杭州 # Path or URL to the avatar to be shown in the profile widget avatar: /images/gzh.jpg # Email address for the Gravatar to be shown in the profile widget gravatar: # Whether to show avatar image rounded or square avatar_rounded: false # 关注我的链接，可设为你的GitHub主页 follow_link: 'https://github.com/h2pl/' # 个人介绍部件底部图标社交链接 social_links: Github: icon: fab fa-github url: 'https://github.com/h2pl' RSS: icon: fas fa-rss url: / - # Widget name type: toc # Where should the widget be placed, left or right position: left - # Widget name type: links # Where should the widget be placed, left or right position: left # Links to be shown in the links widget links: CSDN: 'https://blog.csdn.net/a724888' 知乎: 'https://www.zhihu.com/people/h2pl/activities' 简书: 'https://www.zhihu.com/people/h2pl/activities' - # Widget name type: category # Where should the widget be placed, left or right position: left - # Widget name type: tagcloud # Where should the widget be placed, left or right position: left - # Widget name type: recent_posts # Where should the widget be placed, left or right position: right - # Widget name type: archive # Where should the widget be placed, left or right position: right - # Widget name type: tag # Where should the widget be placed, left or right position: right# Other plugin settingsplugins: # Enable page animations animejs: true # Enable the lightGallery and Justified Gallery plugins # https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/gallery-plugin/ gallery: true # Enable the Outdated Browser plugin # http://outdatedbrowser.com/ outdated-browser: true # Enable the MathJax plugin # https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/mathjax-plugin/ mathjax: true # Show the back to top button on mobile devices back-to-top: true # Google Analytics plugin settings # https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Google-Analytics google-analytics: # Google Analytics tracking id tracking_id: # Baidu Analytics plugin settings # https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Baidu-Analytics baidu-analytics: # Baidu Analytics tracking id tracking_id: 2289335dd443797b5867abbd156e7575 # Hotjar user feedback plugin # https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Hotjar hotjar: # Hotjar site id site_id: # Show a loading progress bar at top of the page progressbar: true # BuSuanZi site/page view counter # https://busuanzi.ibruce.info busuanzi: truebusuanzi: enable: true# CDN provider settings# https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/speed-up-your-site-with-custom-cdn/# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 访客数 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 阅读数 page_pv_footer:providers: # Name or URL of the JavaScript and/or stylesheet CDN provider cdn: jsdelivr # Name or URL of the webfont CDN provider fontcdn: google # Name or URL of the webfont Icon CDN provider iconcdn: fontawesome","link":"/2019/06/12/settings/%E4%BC%8A%E5%8D%A1%E6%B4%9B%E6%96%AF%E7%9A%84%E9%85%8D%E7%BD%AE/"},{"title":"伊卡洛斯配置指南","text":"Icarus用户指南 - 主题配置Icarus的默认主题配置文件为_config.icarus.yml。 此文件定义了站点全局的布局与样式设置，同时也控制了例如插件与挂件等外部功能的配置。 本文详细介绍了本主题的一般配置，并且解释了Icarus使用哪些配置文件和它是如何生成并验证这些配置。 一般主题配置配置文件版本这个版本号与主题版本号相关却不总是相同。 Icarus使用此版本号来决定是否升级默认主题配置文件。 请不要自己更改这个版本号。 123_config.icarus.ymlversion: 4.0.0 主题变体通过此设置为Icarus更换”皮肤“。 此设置目前支持”default“和”cyberpunk“两种值。 你可以在此处查看Cyberpunk变体的效果。 123_config.icarus.ymlvariant: default Logo设置你站点的logo。 此logo会显示在导航栏和页脚。 logo配置的值既可以是你的logo图片的路径或URL地址： 123_config.icarus.ymllogo: /img/logo.svg 也可以像下面这样设置成文字： 1234_config.icarus.ymllogo: text: My Beautiful Site Favicon你可以在head配置中指定你的网站favicon的路径或URL地址。 1234_config.icarus.ymlhead: favicon: /img/favicon.svg Web App ManifestIcarus支持基本的PWAmanifest.json的生成与Meta标签。 要开启web app manifest，请再主题配置中使用如下的配置。 你也可以参考MDN来了解每个配置项的详情。 1_config.icarus.yml Open Graph你可以在head配置中设置Open Graph。 你应该在配置文件中将绝大部分配置留空。 仅在需要的时候在文章的front-matter中为这些设置赋值。 请参考Hexo文档来详细了解每个配置项。 1_config.icarus.yml Google Structured Data你可以在head配置中设置Google Structured Data。 你应该在配置文件中将绝大部分配置留空。 仅在需要的时候在文章的front-matter中为这些设置赋值。 请参考Search for Developers来详细了解每个配置项。 1_config.icarus.yml 页面元信息你可以通过head部分的meta设置来向生成的HTML中添加自定义&lt;meta&gt;标签。 每一个meta标签应作为meta数组中的一个元素出现。 meta设置每一个元素的值应为&lt;属性名&gt;=&lt;属性值&gt;的格式，其中属性名和属性值分别代表着&lt;meta&gt;标签的属性和值。 如果&lt;meta&gt;标签有多个属性和值，请使用;来分隔&lt;属性名&gt;=&lt;属性值&gt;。 123456_config.icarus.ymlhead: meta: - 'name=theme-color;content=#123456' - 'name=generator;content=&quot;Hexo 4.2.0&quot;' RSS你可以通过head部分的rss设置来添加RSS链接信息。 1234_config.icarus.ymlhead: rss: /path/to/atom.xml 导航栏navbar部分定义了导航栏中的菜单与链接。 你可以通过向menu设置项中添加&lt;链接名&gt;: &lt;链接URL&gt;的方式添加任意导航栏菜单链接。 如要向导航栏右侧添加链接，请向links设置项中添加&lt;链接名&gt;: &lt;链接URL&gt;。 12345678910111213141516_config.icarus.ymlnavbar: # 导航栏菜单项 menu: Home: / Archives: /archives Categories: /categories Tags: /tags About: /about # 导航栏右侧的链接 links: GitHub: 'https://github.com' Download on GitHub: icon: fab fa-github url: 'https://github.com/ppoffice/hexo-theme-icarus' 你也可以使用FontAwesome图标来作为纯文字链接的替换，格式如下： 12345链接格式&lt;链接名&gt;: icon: &lt;FontAwesome图标的class名&gt; url: &lt;链接URL&gt; 页脚footer部分定义了页脚右侧的链接。 链接的配置格式与navbar中links的配置格式完全一致。 12345678910111213_config.icarus.ymlfooter: links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Download on GitHub: icon: fab fa-github url: 'https://github.com/ppoffice/hexo-theme-icarus' 代码高亮如果你已在Hexo中启用了代码高亮功能，你可以通过article中的highlight设置来自定义代码块。 请从highlight.js/src/styles下列出的所有主题中 选择一个主题。 然后，复制文件名(不带.css后缀)到theme设置项中。 如要隐藏复制代码按钮，将clipboard设置为false。 如果你希望折叠或展开所有代码块，将fold设置为&quot;folded&quot;或&quot;unfolded&quot;。 你也可以将fold设置为空来禁止代码块折叠。 1234567891011_config.icarus.ymlarticle: highlight: # 代码高亮主题 # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # 显示复制代码按钮 clipboard: true # 代码块的默认折叠状态。可以是&quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded 此外，你可以在Markdown文件中使用下面的语法来折叠单独的代码块： 123{% codeblock &quot;可选文件名&quot; lang:代码语言 &gt;folded %}...代码块内容...{% endcodeblock %} 封面 &amp; 缩略图若要为文章添加封面图，请在文章的front-matter中添加cover选项： 123456post.mdtitle: Icarus快速上手cover: /gallery/covers/cover.jpg---Post content... 类似地，你也可以在文章的front-matter中为文章设置缩略图： 123456post.mdtitle: Icarus快速上手thumbnail: /gallery/thumbnails/thumbnail.jpg---Post content... 文章的缩略图会显示在归档页面和最新文章挂件中。 如果你在front-matter中使用的是图片的路径，你需要确保它是绝对或者相对于你的source目录的路径。 例如，为使用&lt;your blog&gt;/source/gallery/image.jpg作为缩略图，你需要在front-matter中使用/gallery/image.jpg作为图片路径。 文章阅读时间你可以将article部分的readtime设置为true来显示文章字数统计以及预计阅读时间。 1234_config.icarus.ymlarticle: readtime: true 文章许可协议你可以在你的文章/页面的底部展示你的作品的使用许可，许可链接可以是文字或者图标。 这里的配置与导航栏或者页脚的links配置一致： 123456789_config.icarus.ymlarticle: # 文章许可协议 licenses: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' 'CC BY-NC-SA 4.0': 'https://creativecommons.org/licenses/by-nc-sa/4.0/' 侧边栏设置sidebar中某个侧边栏的sticky为true来让它的位置固定而不跟随页面滚动。 1234567_config.icarus.ymlsidebar: left: sticky: false right: sticky: true 其他配置你可以参考Icarus用户指南来了解更多第三方的插件、挂件、以及CDN提供商的配置。 配置文件与优先级除了在_config.icarus.yml的默认主题配置文件外，Icarus也会从如下位置获取替代配置： 位于_config.yml的站点配置文件 位于_config.post.yml和_config.page.yml的布局配置文件 文章/页面的front-matter (已弃用) 位于themes/icarus/_config.yml的旧主题配置文件 (已弃用) 位于themes/icarus/_config.post.yml和themes/icarus/_config.page.yml的旧布局配置文件 布局配置文件布局配置文件遵循着与主题配置文件相同的格式和定义。 _config.post.yml中的配置对所有文章生效，而_config.page.yml中的配置对所有自定义页面生效。 这两个文件将覆盖主题配置文件中的配置。 例如，你可以在_config.post.yml中把所有文章变为两栏布局： 123456789101112_config.post.ymlwidgets: - type: recent_posts position: left - type: categories position: left - type: tags position: left 同时所有其他页面仍保持三栏布局： 123456789101112_config.icarus.ymlwidgets: - type: recent_posts position: left - type: categories position: right - type: tags position: right 文章/页面的Front-matter如果你只想要在某个文章/页面中覆盖主题配置，你可以在那个文章/页面的front-matter中写下配置。 例如，你可以像下面这样在一篇文章的front-matter中更改某篇文章的代码高亮主题： 123456789source/_post/some-post.mdtitle: 我的第一篇文章date: '2015-01-01 00:00:01'article: highlight: theme: atom-one-dark---# 文章标题 上面的配置会为那篇文章覆盖掉_config.post.yml和_config.icarus.yml中的article.highlight。 这种层次化的配置系统对于页面个性化和不同访客间的差异化优化十分有效。 比如，你可以为根据你页面目标访客的国家和语言来开启更快的CDN或本地化的评论服务。 然而需要注意的是，一些Hexo定义的文章或页面属性不会覆盖掉其他配置源中的同名配置，如 title, date, updated, comments (not comment), layout, source, photos, 和excerpt。 站点配置文件上面列出的所有配置源，包括主题配置文件，布局配置文件，和文章/页面的front-matter，会覆盖掉站点配置文件中Icarus使用到的配置。 例如，_config.icarus.yml中的title设置会覆盖掉_config.yml中的title，但new_post_name却不会，因为 Icarus没有用到这个配置项。 另外，主题配置文件中的theme_config选项会与主题配置文件中的主题配置合并并覆盖掉同名配置。 然而，我们非常不推荐使用这个配置选项。 总结总而言之，配置源的作用范围和优先级如下： 对于某个文章或页面 文章/页面的front-matter覆盖所有下面的配置源。 布局配置文件覆盖所有下面的配置源。 站点配置文件中的theme_config选项覆盖所有下面的配置源。 主题配置文件覆盖所有下面的配置源。 站点配置文件。 对于所有的文章或页面 布局配置文件覆盖所有下面的配置源。 站点配置文件中的theme_config选项覆盖所有下面的配置源。 主题配置文件覆盖所有下面的配置源。 站点配置文件。 对于所有的文章，页面，和索引页 站点配置文件中的theme_config选项覆盖所有下面的配置源。 主题配置文件覆盖所有下面的配置源。 站点配置文件。 配置生成与校验所有的Icarus主题配置均使用YAML语言编写。 如果配置文件不存在，Icarus会通过一系列JSON Schema来自动生成默认的配置文件_config.icarus.yml。 这也是为什么你在主题目录下找不到示例配置文件(如_config.yml.example)。 大多数的JSON Schema存放在&lt;icarus_directory&gt;/include/schema目录下，而其他的则存放在 ppoffice/hexo-component-inferno仓库中。 你可以在你的hexo命令后附上--icarus-dont-generate-config来避免配置文件的自动生成。 当你每次运行hexo命令时，主题也会对比JSON Schema来校验你的配置文件。 如果校验中出现任何错误，Icarus会将错误位置与错误类型打印在屏幕上。 例如，如下的错误信息告诉我们logo配置值应该为字符串或是对象，而不是一个整型数。 你可以在你的hexo命令后附上--icarus-dont-check-config来跳过校验，但并不推荐这么做。 12345678910111213141516hexo日志INFO === Checking package dependencies ===INFO === Checking the configuration file ===WARN Configuration file failed one or more checks.WARN Icarus may still run, but you will encounter unexcepted results.WARN Here is some information for you to correct the configuration file.WARN [ { keyword: 'type', dataPath: '.logo', schemaPath: '#/properties/logo/type', params: { type: 'string,object' }, message: 'should be string,object' }] 此外，如果你的默认主题配置文件不是最新版本的话，Icarus会运行迁移脚本将它升级到最新版本。 这些脚本存放在&lt;icarus_directory&gt;/include/migration目录。 你可以在你的hexo命令后附上--icarus-dont-upgrade-config来禁止配置升级。 最后，Icarus也会检查主题依赖的Node.js库是否安装并提醒你安装缺失的库。","link":"/2019/01/07/settings/%E4%BC%8A%E5%8D%A1%E6%B4%9B%E6%96%AF%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"},{"title":"看板娘模板","text":"1、安装模块 在hexo根目录下用Git执行命令 123npm install --save hexo-helper-live2d// 没有纸飞机的小伙伴建议在前面加个c，像这样，下面的下载模型也一样我就不再说了cnpm install --save hexo-helper-live2d 2、模型下载 模型仓库 使用 npm install {packagename}命令进行下载 模型预览：https://huaji8.top/post/live2d-plugin-2.0/ 12345// 这里我下载的是 live2d-widget-model-haru/01// 这个模型比较特殊，因为存在两个同名的模型，我们得使用下面这个命令进行下载，不加后面的/01// 其他的模型直接 npm install 包名 即可npm install live2d-widget-model-haru1234 live2d-widget-model-chitose live2d-widget-model-epsilon2_1 live2d-widget-model-gf live2d-widget-model-haru/01 live2d-widget-model-haru/02 live2d-widget-model-haruto live2d-widget-model-hibiki live2d-widget-model-hijiki live2d-widget-model-izumi live2d-widget-model-koharu live2d-widget-model-miku live2d-widget-model-ni-j live2d-widget-model-nico live2d-widget-model-nietzsche live2d-widget-model-nipsilon live2d-widget-model-nito live2d-widget-model-shizuku live2d-widget-model-tororo live2d-widget-model-tsumiki live2d-widget-model-unitychan live2d-widget-model-wanko live2d-widget-model-z16 3、相关配置 在Hexo的_config.yml文件或者主题下的_config.yml文件下添加配置，这里建议在Hexo根目录下的_config.yml下进行配置，当我们进行主题更换时也不用重新配置 复制以下代码，添加到文件的最后即可。 相关配置可以查看该网站：https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init 123456789101112131415161718192021222324252627282930313233343536# Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true # enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-haru scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 # use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url display: superSample: 2 width: 150 height: 300 position: right hOffset: 0 vOffset: -20 mobile: show: true # 是否在移动设备上显示 scale: 0.5 # 移动设备上的缩放 react: opacityDefault: 0.7 opacityOnHover: 0.8","link":"/2020/12/30/settings/%E7%9C%8B%E6%9D%BF%E5%A8%98%E6%A8%A1%E6%9D%BF/"},{"title":"perfect","text":"[对代码接触的越多，我越来越想让写出的代码更加perfect，更加高可读性，其中各个函数的代码注释就是非常关键的一步：] 123456789101112131415161718192021222324252627282930/** * 函数功能 * @name 名字 * @abstract 申明变量/类/方法 * @access 指明这个变量、类、函数/方法的存取权限 * @author 函数作者的名字和邮箱地址 * @category 组织packages * @copyright 指明版权信息 * @const 指明常量 * @deprecate 指明不推荐或者是废弃的信息MyEclipse编码设置 * @example 示例 * @exclude 指明当前的注释将不进行分析，不出现在文挡中 * @final 指明这是一个最终的类、方法、属性，禁止派生、修改。 * @global 指明在此函数中引用的全局变量 * @include 指明包含的文件的信息 * @link 定义在线连接 * @module 定义归属的模块信息 * @modulegroup 定义归属的模块组 * @package 定义归属的包的信息 * @param 定义函数或者方法的参数信息 * @return 定义函数或者方法的返回信息 * @see 定义需要参考的函数、变量，并加入相应的超级连接。 * @since 指明该api函数或者方法是从哪个版本开始引入的 * @static 指明变量、类、函数是静态的。 * @throws 指明此函数可能抛出的错误异常,极其发生的情况 * @var 定义说明变量/属性。 * @version 定义版本信息 */","link":"/2021/05/10/scripts/perfect/"},{"title":"js_逻辑题","text":"js逻辑题收集的一些面试题 1.写一个 mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b 的时间，然后写一个 myClear，停止上面的 mySetInterVal 123456789101112131415161718function mySetInterVal() { this.time = 0; this.handle = -1; this.start = (fn, a, b) =&gt; { this.handle = setTimeout(() =&gt; { console.log(fn); fn(); this.time++; this.start(fn, a, b); console.log(a + this.time * b) }, a + this.time * b); }; this.stop = () =&gt; { clearTimeout(this.handle); this.time = 0; }; }","link":"/2021/03/01/LogicQuestions/index/"},{"title":"vue-happyfri知识点","text":"[happyfri 知识点] 获取移动端屏幕是否翻转resizeEvt = ‘orientationchange’ in window ? ‘orientationchange’ : ‘resize’, 这段是为了获取移动端屏幕是否翻转（手机重力感应等引起屏幕长宽变化之类的） ‘orientationchange’ in window 这个是判断在 window 对象中是否有 orientationchange 属性，因为 orientationchange 会遇到兼容性问题，有的浏览器不支持，所以这边做了判断来决定是用 orientationchange 还是 resize（思路就是用 resizeEvt 这个变量来控制用哪个，后面只要用 resizeEvt 这个变量来监听屏幕是否被调整） 这里面“？”和“：”是一个 if 判断。如果问号前面的判断（’orientationchange’ in window ）结果为 true 则执行冒号前的内容结果为’orientationchange’（同时因为在 js 中等号的优先级低于三目运算符“？：”，所以还会在这之后执行赋值，把’orientationchange’赋值给 resizeEvt 变量），如果为 false 则得到冒号后的 ‘resize’并赋值给 resizeEvt。 移动端 rem 配置12345678910111213141516(function (doc, win) { var docEl = doc.documentElement; var resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize'; var recalc = function () { var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 20 * (clientWidth / 320) + 'px'; console.log(docEl.style.fontSize); }; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);})(document, window);","link":"/2021/05/18/vue/happyfri/"},{"title":"Vuex 学习手记","text":"[Vuex]Vuex学习手记 一、序言本篇文章更像是我学习vuex的一个笔记，学习的资源主要是来自官方文档教程，官方教程已经讲的比较细致了，部分地方也有自己不理解的地方，所以也查过其他资料来辅助自己理解，本手记在官方的教程上加了一些自己的补充内容，希望能给你带来一些参考价值，另外也感谢互联网上其他分享知识的大佬，让我少走了些弯路！如果文章有理解不到位的地方，还请各位多批评指正！ 二、初识 Vuex1、为何使用Vuex使用Vue开发的过程中，我们经常会遇到一个状态可能会在多个组件之间使用，比如我们在做项目时使用到的用户的信息，什么昵称、头像这些，这些信息会在不同的组件用到，一旦改变这些状态，我们希望其他组件也跟随变化，比如用户充值了100元，或者改变了昵称，所以这个时候就需要状态管理模式来集中管理，关于Vuex的详细介绍可以移步到官网。 2、学习之前的准备本次我的学习都是在官方提供的脚手架搭建的项目下学习的，关于脚手架的使用本次就不再赘述，可以移步到Vue CLI，在使用Vue CLI生成的项目时会让你选择store，选择了后会在页面给你生成一个store.js，这就是最初的store，里面结构如下： 1234567891011121314151617import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store({ state: { }, mutations: { }, actions: { }}) 三、StateVuex的核心就是仓库store，这个store实例会被注入到所有子组件里面，里面的state属性保存着我们的状态，比如我们定义一个状态count： 123456export default new Vuex.Store({ state: { count: 10 },}) 这样我们就有一个集中管理的状态count，那其他组件如何取到这个count呢，可以计算属性来获得： 1234567891011export default { data() { }, computed: { count() { return this.$store.state.count; } }} 因为根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。通过计算属性，我们就可以在模板里面使用模板语法来调用count了，如下： 123456&lt;template&gt; &lt;div&gt; &lt;p&gt;{{ count }}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; mapState有时候需要获取多个状态，但是使用计算属性会调用多次，显得麻烦，这里借助mapState方法来获取state。 使用mapState需要引入该方法 12import { mapState } from 'vuex'; 注意：这里使用了mapState方法后，computed的写法有点区别，比如默认情况你的computed属性是这样写的： 1234567891011data(){ return{ msg: 'hello ' }}computed: { msg() { return this.msg + 'world!'; }} 那么你使用了mapState后需要这样写computed，把msg()放入mapState，不然会报错。 12345678910111213141516171819202122data(){ return{ msg: 'hello ', localCount: 20 }}computed: mapState({ msg() { // 最初的 return this.msg + 'world!'; }, // 使用mapState从store中引入state count(state) { return state.count; }, name(state) { return state.firstName + ' ' + state.lastName; }, mixCount(state) { // 结合store和组件状态进行计算 return state.count + this.localCount; },}) 如果你使用了展开运算符…，那么computed属性不需要改造，按正常写法写 123456789computed: { // 使用展开的话可以按这种方式写，否则要使用另外一种方式，不然要报错 msg() { return this.$store.state.msg; }, // 这里返回一个状态count， // 返回多个你可以这样写...mapState(['count', 'firstName', 'lastName']) ...mapState(['count'])}, 四、Gettergetter就是对状态进行处理的提取出来的公共部分，当状态要进行筛选这些操作时，我们可以通过getter处理过后再返回给组件使用，比如我们在state部分定义了一个list数组： 123456export default new Vuex.Store({ state: { list: [1, 2, 3, 4, 5, 6, 7, 8] },}); 我们想要筛选出数组里面的偶数然后再在组件里面使用，那么筛选的这个工作可以放在getter里面来完成。 123456789101112131415export default new Vuex.Store({ state: { list: [1, 2, 3, 4, 5, 6, 7, 8] }, getters: { // 这个主要是对状态的处理，相当于把状态处理的方法抽成公共部分来管理了 modifyArr(state) { // 一般化getter return state.list.filter((item, index, arr) =&gt; { return item % 2 == 0; }) }, getLength(state, getter) { // 方法里面传getter，调用modifyArr来计算长度 return getter.modifyArr.length; }}); 之后再在其他组件的computed里面去调用getter来获取想要的状态 123456computed: { list() { return this.$store.getters.modifyArr; },} mapGettersmapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性，当我们想在组件里面引入多个getter时，可以使用mapGetter： 12import {mapGetters} from 'vuex'; 比如像刚才在在上面定义的modifyArr，getLength。我们想引入这个两个并获取其值： 1234computed: { ...mapGetter(['modifyArr', 'getLength'])} 你当然可以为其指定别名，不一定非得用store里面getters定义的名字： 1234567computed: { mapGetter({ arr: 'modifyArr', // 把 `this.arr` 映射为 `this.$store.getters.modifyArr`,下面同理 length: 'getLength' })} 如果你的computed属性包含其他计算方法，那你就只能使用展开运算符的写法，这里跟mapState有点区别，其他计算属性如果写在mapGetter里面会报错，说不存在的getter，所以用以下的写法： 12345678910computed: { msg() { return this.num * 10; }, ...mapGetters([ 'modifyArr', 'getLength' ])} 或者指定别名 12345678910computed: { msg() { return this.num * 10; }, ...mapGetters({ getList: 'modifyArr', length: 'getLength' })} 然后再模板里面调用： 1234567891011&lt;template&gt; &lt;div&gt; &lt;h2&gt;mapGetters的使用演示&lt;/h2&gt; &lt;p&gt;你的数字：{{ msg }}&lt;/p&gt; &lt;p&gt;你的数组长度为：{{ length }}&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in getList&quot; :key=&quot;index&quot;&gt;{{ item }}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 五、Mutation当我们需要修改store里面的状态时，我们不是在组件里面直接去修改它们，而是通过mutation里面的方法来进行修改，这样有利于追踪状态的改变。 比如state里面有一个count变量，我们点击加减按钮来控制它的值： 123456789mutations: { add(state) { state.count++; }, reduce(state) { state.count--; }}, 在其他组件里面，我们通过定义methods并绑定时间来触发改变，这里需要使用commit： 123456789methods: { add() { this.$store.commit('add'); }, reduce() { this.$store.commit('reduce'); }} 提交载荷这个就是在commit时提交额外的参数，比如我传了额外的值加到count上面： 123456mutations: { loadAdd(state, payload) { // 提交载荷，额外参数 state.count += payload; }}, 然后再组件里面使用： 123456methods: { loadAdd() { this.$store.commit('loadAdd', 100); // 传递额外参数 }} 再这里官方文档建议载荷（也就是那个额外参数）最好使用对象来传，这样可以包含多个字段并且记录的 mutation 会更易读，像这样： 1234this.$store.commit('loadAdd', { extraCount: 100}); // 传递额外参数 调用commit时我们也可以把所有参数写在一个对象里面： 12345this.$store.commit( { type: 'addLoad' extraCount: 100}); // 传递额外参数 Mutation 需遵守 Vue 的响应规则这个主要是说你再开发过程中需要向state里面添加额外数据时，需要遵循响应准则。 这里我直接照搬官方文档的说明： Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项： 最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该使用 Vue.set(obj, ‘newProp’, 123), 或者以新对象替换老对象。例如，利用 stage-3 的对象展开运算符 我们可以这样写： 12state.obj = { ...state.obj, newProp: 123 } 还是举个栗子： 我在mutation里面声明了一个方法 1234567addNewState(state, payload) { // 我打算再这儿添加新的属性到state // Vue.set(state, 'newProp', '添加一个新值！'); // 这是一种写法 // 这种写法用新对象替换老对象 // state= {...state, newProp: '添加一个新值！'} // 这个玩意儿不管用了，用下面的replaceState()方法 this.replaceState({...state, newProp: '添加一个新值！'})} 然后再组件里面去调用，定义一个method： 1234addNewProp() { this.$store.commit('addNewState', {});} 这样再执行了这个方法后，会及时更新到state，再组件的computed属性里面定义： 1234newMsg() { return this.$store.state.newProp || '还没添加新值';} 在模板里面即时展示，并且不会影响其他状态： 123&lt;p&gt;添加的新值：{{ newMsg }}&lt;/p&gt;&lt;div&gt;&lt;button @click=&quot;addNewProp&quot;&gt;添加新值&lt;/button&gt;&lt;/div&gt; Mutation 必须是同步函数下面这种写法必须避免（直接官方例子加持）： 12345678mutations: { someMutation (state) { api.callAsyncMethod(() =&gt; { state.count++ }) }} mapMutations这个跟前面的那几个函数一个道理，都是为了简化调用，使用方法如下： 12import {mapMutations} from 'vuex'; 然后在组件的methods里面使用，这里使用官方代码： 123456789101112131415export default { // ... methods: { ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` }) }} 六、ActionAction 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 前面说过mutation只能包含同步事务，所以在处理异步事务就需要Action，通过Action控制了异步这一过程，之后再去调用mutation里面的方法来改变状态。 这里我直接贴代码来一目了然，首先我定义了一个状态product： 1234state: { product: 'car'} 然后再mutation中定义一个方法： 1234changeProduct(state, payload) { state.product = payload.change;} 在action中定义： 12345678910111213141516actions: { changeProduct(context, payload) { // 这个context是一个与 store 实例具有相同方法和属性的对象 // 调用mutation里的changeProduct方法 // context.commit('changeProduct', {change: 'ship'}); // 改成异步方式 // setTimeout(() =&gt; { // context.commit('changeProduct', {change: 'ship'}); // }, 1500) // 使用载荷 let temp = 'ship+' + payload.extraInfo; setTimeout(() =&gt; { context.commit('changeProduct', {change: temp}); }, 1500) }} 在组件methods中定义事件触发分发： 123456789101112131415methods: { selectProduct() { // this.$store.dispatch('changeProduct') // 载荷方式分发 // this.$store.dispatch('changeProduct', { // extraInfo: 'sportcar' // }) // 或者这种 this.$store.dispatch({ type: 'changeProduct', extraInfo: '-&gt;sportcar' }) }}, 这样一个简易的action就完成了！ mapActions这里就不再赘述了，看名字就知道跟前面几个叫map开头的辅助函数类似，用来映射action里面的方法，这里也直接贴官方代码了： 1234567891011121314151617import {mapActions} from 'vuex';export default { // ... methods: { ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` }) }} 有时候我们想知道action里面异步执行后的状态然后再去修改其他信息，这个可以借助Promise来实现。这里在state里面声明一个状态： 1234567state: { userInfo: { // 这个变量用来测试组合变量 name: 'lee', age: 23 }} 接着声明mutation: 1234567mutations: { // 以下用来测试组合action changeInfo(state, payload) { state.userInfo.name = 'lee haha'; }} 声明action： 1234567891011actions: { changeInfo(context, payload) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { context.commit('changeInfo'); resolve(); }, 2000) }) }} 这时我们在组件里面定义方法去派发这个action： 12345678910111213data() { return { status: '信息还没修改！' }}methods: { modifyInfo() { this.$store.dispatch('changeInfo').then(() =&gt; { this.status = '信息修改成功'; }); }} 模板展示： 12345678910&lt;template&gt; &lt;div&gt; &lt;h2&gt;组合action&lt;/h2&gt; &lt;p&gt;{{ status }}&lt;/p&gt; &lt;p&gt;{{ info.name }}&lt;/p&gt; &lt;div&gt;&lt;button @click=&quot;modifyInfo&quot;&gt;修改信息&lt;/button&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 当我们点击修改信息后，就会派发action，当修改成功的时候会同步修改上面说的展示信息。 当然其他定义的action方法也可以互相使用，这里直接贴官方代码了： 12345678910111213141516actions: { actionA ({ commit }) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { commit('someMutation') resolve() }, 1000) }) }, actionB ({ dispatch, commit }) { return dispatch('actionA').then(() =&gt; { commit('someOtherMutation') }) }} 七、Module模块这部分正如其名，当所有状态集中在一个对象中时，会变的相当臃肿，这个时候就需要模块的管理办法。这里我还是用代码来说明，比如我在store里面定义了两个模块： 12345678910111213141516171819202122232425262728293031323334// 定义的模块Aconst moduleA = { state: { name: 'lee', age: 23, }, mutations: { }, getters: { }, actions: { }};// 定义模块Bconst moduleB = { state: { name: 'wang', age: 22 }, mutations: { }, getters: { }, actions: { }} 然后再Vuex里面声明模块： 12345678910export default new Vuex.Store({ modules: { ma: moduleA, mb: moduleB }, state: { ........... // 其他状态 }}); 这样一来，如果我们想要在组件里面访问其他模块的状态，可以这样，比如这里我想调用B模块里的状态： 123456computed: { msg() { return this.$store.mb; // 这里返回的是：{name: 'wang', age: 22} }} 关于模块内部的局部状态，这里跟普通的store用法没有多大的区别，主要区别以下外部传进来的状态，比如对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState，这里截取官方代码： 123456789101112const moduleA = { // ... actions: { incrementIfOddOnRootSum ({ state, commit, rootState }) { if ((state.count + rootState.count) % 2 === 1) { commit('increment') } } }} 对于模块内部的 getter，根节点状态会作为第三个参数暴露出来： 12345678910const moduleA = { // ... getters: { sumWithRootCount (state, getters, rootState) { return state.count + rootState.count } }} 那么对于getters、mutations、actions里面的方法我们像基本的store那样调用就可以了，不存在作用域限制，还是贴代码栗子吧，下面是我在store.js里面定义的模块B： 12345678910111213141516171819const moduleB = { state: { name: 'wang', age: 22, desc: 'nope' }, mutations: { modifyDesc(state, payload) { state.desc = payload.newMsg; } }, getters: { }, actions: { }} 在组件里面，我定义了以下内容： 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div&gt; &lt;h2&gt;7、module使用示例&lt;/h2&gt; &lt;div&gt; &lt;p&gt;名字：{{ name }}&lt;/p&gt; &lt;p&gt;描述：{{ desc }}&lt;/p&gt; &lt;button @click=&quot;handleClick&quot;&gt;修改描述&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { name: this.$store.state.mb.name, // desc: this.$store.state.mb.desc 注意这个如果涉及到要在store里面会被改变的状态，一定要写在 // computed属性里面，不然不能及时反馈到视图上 } }, computed: { desc() { return this.$store.state.mb.desc; } }, methods: { handleClick() { this.$store.commit('modifyDesc', {newMsg: 'lao wang is beautiful!'}); } },}&lt;/script&gt; 这样，就可以调用mutation里面的方法了，getters和actions同理 2019/09/09 补充余下内容 命名空间模块默认情况下，mutations、actions、getters这些都是注册在全局上面的，你可以直接调用，如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。 首先我新建一个js文件用来声明模块C： 12345678910111213141516171819202122232425262728/* * 这个文件用来声明模块C*/export const moduleC = { namespaced: true, state: { name: 'moduleC', desc: '这是模块C，用来测试命名空间的！', list: [1, 2, 3, 4] }, getters: { filterList(state) { return state.list.filter((item, index, arrSelf) =&gt; { return item % 2 !== 0; }); } }, mutations: { modifyName(state, payload) { state.name = payload.newName; } }, actions: { }} 然后在store.js里面引入： 12345678import { moduleC } from './module_c.js';export default new Vuex.Store({ modules: { mc: moduleC },}); 要想这个模块成为带有命名空间的模块，在上面声明属性namespaced: true就可以了，那么里面的mutations、getters和actions里面的方法的调用就要多走一层路径，比如我在组件里面去调用mutations里面的方法（getters和actions同理）： 123456789101112methods: { modify() { // this.$store.commit('mc/modifyName', { // newName: '命名空间模块C' // }) this.$store.commit({ type: 'mc/modifyName', newName: '命名空间模块C' }) }} 当然模块里面再嵌套模块也可以，路径要不要多走一层主要看你的namespaced: true有没有声明，这里贴一下官方的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041const store = new Vuex.Store({ modules: { account: { namespaced: true, // 模块内容（module assets） state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响 getters: { isAdmin () { ... } // -&gt; getters['account/isAdmin'] }, actions: { login () { ... } // -&gt; dispatch('account/login') }, mutations: { login () { ... } // -&gt; commit('account/login') }, // 嵌套模块 modules: { // 继承父模块的命名空间 myPage: { state: { ... }, getters: { profile () { ... } // -&gt; getters['account/profile'] } }, // 进一步嵌套命名空间 posts: { namespaced: true, state: { ... }, getters: { popular () { ... } // -&gt; getters['account/posts/popular'] } } } } }}) 在带命名空间的模块内访问全局内容如果想要在模块内部的getters、mutations和actions里面访问到全局的内容，这儿Vuex已经封装好了，你只需要多传几个参数即可。官方演示来一波，简单明了： 1234567891011121314151617181920212223242526272829303132modules: { foo: { namespaced: true, getters: { // 在这个模块的 getter 中，`getters` 被局部化了 // 你可以使用 getter 的第四个参数来调用 `rootGetters` someGetter (state, getters, rootState, rootGetters) { getters.someOtherGetter // -&gt; 'foo/someOtherGetter' rootGetters.someOtherGetter // -&gt; 'someOtherGetter' }, someOtherGetter: state =&gt; { ... } }, actions: { // 在这个模块中， dispatch 和 commit 也被局部化了 // 他们可以接受 `root` 属性以访问根 dispatch 或 commit someAction ({ dispatch, commit, getters, rootGetters }) { getters.someGetter // -&gt; 'foo/someGetter' rootGetters.someGetter // -&gt; 'someGetter' dispatch('someOtherAction') // -&gt; 'foo/someOtherAction' dispatch('someOtherAction', null, { root: true }) // -&gt; 'someOtherAction' commit('someMutation') // -&gt; 'foo/someMutation' commit('someMutation', null, { root: true }) // -&gt; 'someMutation' }, someOtherAction (ctx, payload) { ... } } }} 在模块里面使用辅助函数mapState、mapGetters、mapMutations和mapActions由于存在命名空间，在组件里面采用上面的写法会出现问题，这里要想使用辅助函数来映射模块里面的东西需要指定空间名称来告诉辅助函数应该去哪儿找这些。 这儿我以上面我的C模块为例，首先对于mapSatate函数可以这样玩，我在全局的modules里面声明了mc，那我的空间名称就是mc： 1234computed: { ...mapState('mc', ['name', 'desc']) // 这里模块里面要使用辅助函数的话要多传一个参数才行} 然后在模版里面写name，desc即可，或者可以这样： 1234567891011computed: { ...mapState('mc', { name(state) { return state.name; }, desc(state) { return state.desc; } })}, 对于actions、mutations和getters方式类似，主要是要指定空间名称，比如对于声明的mutations： 1234methods: { ...mapMutations('mc', ['modifyName'])} 如果你确实不想在每个辅助函数里写空间名称，Vuex也提供了其它办法，使用createNamespacedHelpers创建基于某个命名空间辅助函数，它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数： 1234import { createNamespacedHelpers } from 'vuex';const { mapState, mapMutations } = createNamespacedHelpers('mc'); 这样你在写辅助函数的时候就不需要单独指定空间名称了。 其它类似，恕我就不再赘述了！ 八、结语本篇相当于基础入门篇，其他内容大家有兴趣进官网浏览即可。相关的代码我已经传到github上了，感兴趣就下载来看看吧！ 演示代码 作者：CookiePool来源：掘金","link":"/2021/05/18/vue/vuex/"},{"title":"mock数据","text":"[vue引入Mock.js] vue中引入Mock.js1234npm install mockjs --save-dev或yarn add mockjs 新建Mock文件夹，创建index.js文件index.js文件如下123456789101112131415161718192021222324import Mock from 'mockjs'// 设置响应延时Mock.setup({ timeout: '200-600'//可以是整数，也可以是‘-’字符串});let configArray = [];//使用webpack的require.context()遍历所有的mock文件const files = require.context('.', true, /\\.js$/);files.keys().forEach((key) =&gt; { if(key === './index.js') return; configArray = configArray.concat(files(key).default);});//注册所有的mock服务configArray.forEach((item) =&gt; { for(let [path, target] of Object.entries(item)){ let protocol = path.split('|'); Mock.mock(new RegExp('^' + protocol[1]), protocol[0],target); }}) main.js文件12345678910111213141516171819202122import Vue from &quot;vue&quot;;import App from &quot;./App&quot;;import router from &quot;./router&quot;;import store from &quot;./vuex/store&quot;;//引入store.jsimport axios from 'axios';if (process.env.NODE_ENV !== 'production') require('./mock')Vue.config.productionTip = false;Vue.prototype.$axios = axios;/* eslint-disable no-new */new Vue({ el: &quot;#app&quot;, router, store,//相当于store:store,注册后，子组件时可以使用this.$store访问 components: { App }, template: &quot;&lt;App/&gt;&quot;}); 接下来就可以创建数据文件，例如demoList.js1234567891011121314151617let demoList = [ { id: 1, text: &quot;测试1&quot; }];export default { &quot;get|/parameter/query&quot;: option =&gt; { return { status: 200, message: &quot;success&quot;, data: demoList }; }}; 之后就可以引用了。例如：12345678getMock(){//mock调用 this.$axios({ url:'/parameter/query', method: &quot;get&quot;, }).then(res =&gt;{ console.log(res.data); });},","link":"/2021/05/19/vue/mockjs/"},{"title":"useAnimation","text":"This hook allows you to smoothly animate any value using an easing function (linear, elastic, etc). In the example we call the useAnimation hook three times to animated three balls on to the screen at different intervals. Additionally we show how easy it is to compose hooks. Our useAnimation hook doesn’t actual make use of useState or useEffect itself, but instead serves as a wrapper around the useAnimationTimer hook. Having the timer logic abstracted out into its own hook gives us better code readability and the ability to use timer logic in other contexts. Be sure to check out the CodeSandbox Demo for this one. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import { useState, useEffect } from &quot;react&quot;;// Usagefunction App() { // Call hook multiple times to get animated values with different start delays const animation1 = useAnimation(&quot;elastic&quot;, 600, 0); const animation2 = useAnimation(&quot;elastic&quot;, 600, 150); const animation3 = useAnimation(&quot;elastic&quot;, 600, 300); return ( &lt;div style={{ display: &quot;flex&quot;, justifyContent: &quot;center&quot; }}&gt; &lt;Ball innerStyle={{ marginTop: animation1 * 200 - 100, }} /&gt; &lt;Ball innerStyle={{ marginTop: animation2 * 200 - 100, }} /&gt; &lt;Ball innerStyle={{ marginTop: animation3 * 200 - 100, }} /&gt; &lt;/div&gt; );}const Ball = ({ innerStyle }) =&gt; ( &lt;div style={{ width: 100, height: 100, marginRight: &quot;40px&quot;, borderRadius: &quot;50px&quot;, backgroundColor: &quot;#4dd5fa&quot;, ...innerStyle, }} /&gt;);// Hookfunction useAnimation(easingName = &quot;linear&quot;, duration = 500, delay = 0) { // The useAnimationTimer hook calls useState every animation frame ... // ... giving us elapsed time and causing a rerender as frequently ... // ... as possible for a smooth animation. const elapsed = useAnimationTimer(duration, delay); // Amount of specified duration elapsed on a scale from 0 - 1 const n = Math.min(1, elapsed / duration); // Return altered value based on our specified easing function return easing[easingName](n);}// Some easing functions copied from:// https://github.com/streamich/ts-easing/blob/master/src/index.ts// Hardcode here or pull in a dependencyconst easing = { linear: (n) =&gt; n, elastic: (n) =&gt; n * (33 * n * n * n * n - 106 * n * n * n + 126 * n * n - 67 * n + 15), inExpo: (n) =&gt; Math.pow(2, 10 * (n - 1)),};function useAnimationTimer(duration = 1000, delay = 0) { const [elapsed, setTime] = useState(0); useEffect( () =&gt; { let animationFrame, timerStop, start; // Function to be executed on each animation frame function onFrame() { setTime(Date.now() - start); loop(); } // Call onFrame() on next animation frame function loop() { animationFrame = requestAnimationFrame(onFrame); } function onStart() { // Set a timeout to stop things when duration time elapses timerStop = setTimeout(() =&gt; { cancelAnimationFrame(animationFrame); setTime(Date.now() - start); }, duration); // Start the loop start = Date.now(); loop(); } // Start after specified delay (defaults to 0) const timerDelay = setTimeout(onStart, delay); // Clean things up return () =&gt; { clearTimeout(timerStop); clearTimeout(timerDelay); cancelAnimationFrame(animationFrame); }; }, [duration, delay] // Only re-run effect if duration or delay changes ); return elapsed;}","link":"/2021/01/19/react/useHooks/useAnimation/"},{"title":"useAsync","text":"It’s generally a good practice to indicate to users the status of any async request. An example would be fetching data from an API and displaying a loading indicator before rendering the results. Another example would be a form where you want to disable the submit button when the submission is pending and then display either a success or error message when it completes.Rather than litter your components with a bunch of useState calls to keep track of the state of an async function, you can use our custom hook which takes an async function as an input and returns the value, error, and status values we need to properly update our UI. Possible values for status prop are: “idle”, “pending”, “success”, “error”. As you’ll see in the code below, our hook allows both immediate execution and delayed execution using the returned execute function. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import React, { useState, useEffect, useCallback } from &quot;react&quot;;// Usagefunction App() { const { execute, status, value, error } = useAsync(myFunction, false); return ( &lt;div&gt; {status === &quot;idle&quot; &amp;&amp; &lt;div&gt;Start your journey by clicking a button&lt;/div&gt;} {status === &quot;success&quot; &amp;&amp; &lt;div&gt;{value}&lt;/div&gt;} {status === &quot;error&quot; &amp;&amp; &lt;div&gt;{error}&lt;/div&gt;} &lt;button onClick={execute} disabled={status === &quot;pending&quot;}&gt; {status !== &quot;pending&quot; ? &quot;Click me&quot; : &quot;Loading...&quot;} &lt;/button&gt; &lt;/div&gt; );}// An async function for testing our hook.// Will be successful 50% of the time.const myFunction = () =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { const rnd = Math.random() * 10; rnd &lt;= 5 ? resolve(&quot;Submitted successfully 🙌&quot;) : reject(&quot;Oh no there was an error 😞&quot;); }, 2000); });};// Hookconst useAsync = (asyncFunction, immediate = true) =&gt; { const [status, setStatus] = useState(&quot;idle&quot;); const [value, setValue] = useState(null); const [error, setError] = useState(null); // The execute function wraps asyncFunction and // handles setting state for pending, value, and error. // useCallback ensures the below useEffect is not called // on every render, but only if asyncFunction changes. const execute = useCallback(() =&gt; { setStatus(&quot;pending&quot;); setValue(null); setError(null); return asyncFunction() .then((response) =&gt; { setValue(response); setStatus(&quot;success&quot;); }) .catch((error) =&gt; { setError(error); setStatus(&quot;error&quot;); }); }, [asyncFunction]); // Call execute if we want to fire it right away. // Otherwise execute can be called later, such as // in an onClick handler. useEffect(() =&gt; { if (immediate) { execute(); } }, [execute, immediate]); return { execute, status, value, error };}; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import React, { useState, useEffect, useCallback } from &quot;react&quot;;// Usagefunction App() { const { execute, status, value, error } = useAsync&lt;string&gt;(myFunction, false); return ( &lt;div&gt; {status === &quot;idle&quot; &amp;&amp; &lt;div&gt;Start your journey by clicking a button&lt;/div&gt;} {status === &quot;success&quot; &amp;&amp; &lt;div&gt;{value}&lt;/div&gt;} {status === &quot;error&quot; &amp;&amp; &lt;div&gt;{error}&lt;/div&gt;} &lt;button onClick={execute} disabled={status === &quot;pending&quot;}&gt; {status !== &quot;pending&quot; ? &quot;Click me&quot; : &quot;Loading...&quot;} &lt;/button&gt; &lt;/div&gt; );}// An async function for testing our hook.// Will be successful 50% of the time.const myFunction = (): Promise&lt;string&gt; =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { const rnd = Math.random() * 10; rnd &lt;= 5 ? resolve(&quot;Submitted successfully 🙌&quot;) : reject(&quot;Oh no there was an error 😞&quot;); }, 2000); });};// Hookconst useAsync = &lt;T, E = string&gt;( asyncFunction: () =&gt; Promise&lt;T&gt;, immediate = true) =&gt; { const [status, setStatus] = useState&lt; &quot;idle&quot; | &quot;pending&quot; | &quot;success&quot; | &quot;error&quot; &gt;(&quot;idle&quot;); const [value, setValue] = useState&lt;T | null&gt;(null); const [error, setError] = useState&lt;E | null&gt;(null); // The execute function wraps asyncFunction and // handles setting state for pending, value, and error. // useCallback ensures the below useEffect is not called // on every render, but only if asyncFunction changes. const execute = useCallback(() =&gt; { setStatus(&quot;pending&quot;); setValue(null); setError(null); return asyncFunction() .then((response: any) =&gt; { setValue(response); setStatus(&quot;success&quot;); }) .catch((error: any) =&gt; { setError(error); setStatus(&quot;error&quot;); }); }, [asyncFunction]); // Call execute if we want to fire it right away. // Otherwise execute can be called later, such as // in an onClick handler. useEffect(() =&gt; { if (immediate) { execute(); } }, [execute, immediate]); return { execute, status, value, error };};","link":"/2021/01/19/react/useHooks/useAsync/"},{"title":"useAuth","text":"A very common scenario is you have a bunch of components that need to render different depending on whether the current user is logged in and sometimes call authentication methods like signin, signout, sendPasswordResetEmail, etc.This is a perfect use-case for a useAuth hook that enables any component to get the current auth state and re-render if it changes. Rather than have each instance of the useAuth hook fetch the current user, the hook simply calls useContext to get the data from farther up in the component tree. The real magic happens in our &lt;ProvideAuth&gt; component and our useProvideAuth hook which wraps all our authentication methods (in this case we’re using Firebase) and then uses React Context to make the current auth object available to all child components that call useAuth. Whew, that was a mouthfull…Hopefully as you read through the code below it should all make sense. Another reason I like this method is it neatly abstracts away our actual auth provider (Firebase), making it super easy to change providers in the future. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150// Top level App componentimport React from &quot;react&quot;;import { ProvideAuth } from &quot;./use-auth.js&quot;;function App(props) { return ( &lt;ProvideAuth&gt; {/* Route components here, depending on how your app is structured. If using Next.js this would be /pages/_app.js */} &lt;/ProvideAuth&gt; );}// Any component that wants auth stateimport React from &quot;react&quot;;import { useAuth } from &quot;./use-auth.js&quot;;function Navbar(props) { // Get auth state and re-render anytime it changes const auth = useAuth(); return ( &lt;NavbarContainer&gt; &lt;Logo /&gt; &lt;Menu&gt; &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt; &lt;Link to=&quot;/contact&quot;&gt;Contact&lt;/Link&gt; {auth.user ? ( &lt;Fragment&gt; &lt;Link to=&quot;/account&quot;&gt;Account ({auth.user.email})&lt;/Link&gt; &lt;Button onClick={() =&gt; auth.signout()}&gt;Signout&lt;/Button&gt; &lt;/Fragment&gt; ) : ( &lt;Link to=&quot;/signin&quot;&gt;Signin&lt;/Link&gt; )} &lt;/Menu&gt; &lt;/NavbarContainer&gt; );}// Hook (use-auth.js)import React, { useState, useEffect, useContext, createContext } from &quot;react&quot;;import * as firebase from &quot;firebase/app&quot;;import &quot;firebase/auth&quot;;// Add your Firebase credentialsfirebase.initializeApp({ apiKey: &quot;&quot;, authDomain: &quot;&quot;, projectId: &quot;&quot;, appID: &quot;&quot;,});const authContext = createContext();// Provider component that wraps your app and makes auth object ...// ... available to any child component that calls useAuth().export function ProvideAuth({ children }) { const auth = useProvideAuth(); return &lt;authContext.Provider value={auth}&gt;{children}&lt;/authContext.Provider&gt;;}// Hook for child components to get the auth object ...// ... and re-render when it changes.export const useAuth = () =&gt; { return useContext(authContext);};// Provider hook that creates auth object and handles statefunction useProvideAuth() { const [user, setUser] = useState(null); // Wrap any Firebase methods we want to use making sure ... // ... to save the user to state. const signin = (email, password) =&gt; { return firebase .auth() .signInWithEmailAndPassword(email, password) .then((response) =&gt; { setUser(response.user); return response.user; }); }; const signup = (email, password) =&gt; { return firebase .auth() .createUserWithEmailAndPassword(email, password) .then((response) =&gt; { setUser(response.user); return response.user; }); }; const signout = () =&gt; { return firebase .auth() .signOut() .then(() =&gt; { setUser(false); }); }; const sendPasswordResetEmail = (email) =&gt; { return firebase .auth() .sendPasswordResetEmail(email) .then(() =&gt; { return true; }); }; const confirmPasswordReset = (code, password) =&gt; { return firebase .auth() .confirmPasswordReset(code, password) .then(() =&gt; { return true; }); }; // Subscribe to user on mount // Because this sets state in the callback it will cause any ... // ... component that utilizes this hook to re-render with the ... // ... latest auth object. useEffect(() =&gt; { const unsubscribe = firebase.auth().onAuthStateChanged((user) =&gt; { if (user) { setUser(user); } else { setUser(false); } }); // Cleanup subscription on unmount return () =&gt; unsubscribe(); }, []); // Return the user object and auth methods return { user, signin, signup, signout, sendPasswordResetEmail, confirmPasswordReset, };}","link":"/2021/01/19/react/useHooks/useAuth/"},{"title":"useDarkMode","text":"This hook handles all the stateful logic required to add a ☾ dark mode toggle to your website. It utilizes localStorage to remember the user’s chosen mode, defaults to their browser or OS level setting using the prefers-color-scheme media query and manages the setting of a .dark-mode className on body to apply your styles.This post also helps illustrate the power of hook composition. The syncing of state to localStorage is handled by our useLocalStorage hook. Detecting the user’s dark mode preference is handled by our useMedia hook. Both of these hooks were created for other use-cases, but here we’ve composed them to create a super useful hook in relatively few lines of code. It’s almost as if hooks bring the compositional power of React components to stateful logic! 🤯 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Usagefunction App() { const [darkMode, setDarkMode] = useDarkMode(); return ( &lt;div&gt; &lt;div className=&quot;navbar&quot;&gt; &lt;Toggle darkMode={darkMode} setDarkMode={setDarkMode} /&gt; &lt;/div&gt; &lt;Content /&gt; &lt;/div&gt; );}// Hookfunction useDarkMode() { // Use our useLocalStorage hook to persist state through a page refresh. // Read the recipe for this hook to learn more: usehooks.com/useLocalStorage const [enabledState, setEnabledState] = useLocalStorage(&quot;dark-mode-enabled&quot;); // See if user has set a browser or OS preference for dark mode. // The usePrefersDarkMode hook composes a useMedia hook (see code below). const prefersDarkMode = usePrefersDarkMode(); // If enabledState is defined use it, otherwise fallback to prefersDarkMode. // This allows user to override OS level setting on our website. const enabled = typeof enabledState !== &quot;undefined&quot; ? enabledState : prefersDarkMode; // Fire off effect that add/removes dark mode class useEffect( () =&gt; { const className = &quot;dark-mode&quot;; const element = window.document.body; if (enabled) { element.classList.add(className); } else { element.classList.remove(className); } }, [enabled] // Only re-call effect when value changes ); // Return enabled state and setter return [enabled, setEnabledState];}// Compose our useMedia hook to detect dark mode preference.// The API for useMedia looks a bit weird, but that's because ...// ... it was designed to support multiple media queries and return values.// Thanks to hook composition we can hide away that extra complexity!// Read the recipe for useMedia to learn more: usehooks.com/useMediafunction usePrefersDarkMode() { return useMedia([&quot;(prefers-color-scheme: dark)&quot;], [true], false);} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Usagefunction App() { const [darkMode, setDarkMode] = useDarkMode(); return ( &lt;div&gt; &lt;div className=&quot;navbar&quot;&gt; &lt;Toggle darkMode={darkMode} setDarkMode={setDarkMode} /&gt; &lt;/div&gt; &lt;Content /&gt; &lt;/div&gt; );}// Hookfunction useDarkMode() { // Use our useLocalStorage hook to persist state through a page refresh. // Read the recipe for this hook to learn more: usehooks.com/useLocalStorage const [enabledState, setEnabledState] = useLocalStorage&lt;boolean&gt;( &quot;dark-mode-enabled&quot;, false ); // See if user has set a browser or OS preference for dark mode. // The usePrefersDarkMode hook composes a useMedia hook (see code below). const prefersDarkMode = usePrefersDarkMode(); // If enabledState is defined use it, otherwise fallback to prefersDarkMode. // This allows user to override OS level setting on our website. const enabled = enabledState ?? prefersDarkMode; // Fire off effect that add/removes dark mode class useEffect( () =&gt; { const className = &quot;dark-mode&quot;; const element = window.document.body; if (enabled) { element.classList.add(className); } else { element.classList.remove(className); } }, [enabled] // Only re-call effect when value changes ); // Return enabled state and setter return [enabled, setEnabledState];}// Compose our useMedia hook to detect dark mode preference.// The API for useMedia looks a bit weird, but that's because ...// ... it was designed to support multiple media queries and return values.// Thanks to hook composition we can hide away that extra complexity!// Read the recipe for useMedia to learn more: usehooks.com/useMediafunction usePrefersDarkMode() { return useMedia&lt;boolean&gt;([&quot;(prefers-color-scheme: dark)&quot;], [true], false);}","link":"/2021/01/19/react/useHooks/useDarkMode/"},{"title":"useDebounce","text":"This hook allows you to debounce any fast changing value. The debounced value will only reflect the latest value when the useDebounce hook has not been called for the specified time period. When used in conjunction with useEffect, as we do in the recipe below, you can easily ensure that expensive operations like API calls are not executed too frequently. The example below allows you to search the Marvel Comic API and uses useDebounce to prevent API calls from being fired on every keystroke. Be sure to check out the CodeSandbox demo for this one. Hook code and inspiration from github.com/xnimorz/use-debounce. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import { useState, useEffect, useRef } from &quot;react&quot;;// Usagefunction App() { // State and setters for ... // Search term const [searchTerm, setSearchTerm] = useState(&quot;&quot;); // API search results const [results, setResults] = useState([]); // Searching status (whether there is pending API request) const [isSearching, setIsSearching] = useState(false); // Debounce search term so that it only gives us latest value ... // ... if searchTerm has not been updated within last 500ms. // The goal is to only have the API call fire when user stops typing ... // ... so that we aren't hitting our API rapidly. const debouncedSearchTerm = useDebounce(searchTerm, 500); // Effect for API call useEffect( () =&gt; { if (debouncedSearchTerm) { setIsSearching(true); searchCharacters(debouncedSearchTerm).then((results) =&gt; { setIsSearching(false); setResults(results); }); } else { setResults([]); setIsSearching(false); } }, [debouncedSearchTerm] // Only call effect if debounced search term changes ); return ( &lt;div&gt; &lt;input placeholder=&quot;Search Marvel Comics&quot; onChange={(e) =&gt; setSearchTerm(e.target.value)} /&gt; {isSearching &amp;&amp; &lt;div&gt;Searching ...&lt;/div&gt;} {results.map((result) =&gt; ( &lt;div key={result.id}&gt; &lt;h4&gt;{result.title}&lt;/h4&gt; &lt;img src={`${result.thumbnail.path}/portrait_incredible.${result.thumbnail.extension}`} /&gt; &lt;/div&gt; ))} &lt;/div&gt; );}// API search functionfunction searchCharacters(search) { const apiKey = &quot;f9dfb1e8d466d36c27850bedd2047687&quot;; return fetch( `https://gateway.marvel.com/v1/public/comics?apikey=${apiKey}&amp;titleStartsWith=${search}`, { method: &quot;GET&quot;, } ) .then((r) =&gt; r.json()) .then((r) =&gt; r.data.results) .catch((error) =&gt; { console.error(error); return []; });}// Hookfunction useDebounce(value, delay) { // State and setters for debounced value const [debouncedValue, setDebouncedValue] = useState(value); useEffect( () =&gt; { // Update debounced value after delay const handler = setTimeout(() =&gt; { setDebouncedValue(value); }, delay); // Cancel the timeout if value changes (also on delay change or unmount) // This is how we prevent debounced value from updating if value is changed ... // .. within the delay period. Timeout gets cleared and restarted. return () =&gt; { clearTimeout(handler); }; }, [value, delay] // Only re-call effect if value or delay changes ); return debouncedValue;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import { useState, useEffect, useRef } from &quot;react&quot;;// Usagefunction App() { // State and setters for ... // Search term const [searchTerm, setSearchTerm] = useState&lt;string&gt;(&quot;&quot;); // API search results const [results, setResults] = useState&lt;any[]&gt;([]); // Searching status (whether there is pending API request) const [isSearching, setIsSearching] = useState&lt;boolean&gt;(false); // Debounce search term so that it only gives us latest value ... // ... if searchTerm has not been updated within last 500ms. // The goal is to only have the API call fire when user stops typing ... // ... so that we aren't hitting our API rapidly. // We pass generic type, this case string const debouncedSearchTerm: string = useDebounce&lt;string&gt;(searchTerm, 500); // Effect for API call useEffect( () =&gt; { if (debouncedSearchTerm) { setIsSearching(true); searchCharacters(debouncedSearchTerm).then((results) =&gt; { setIsSearching(false); setResults(results); }); } else { setResults([]); } }, [debouncedSearchTerm] // Only call effect if debounced search term changes ); return ( &lt;div&gt; &lt;input placeholder=&quot;Search Marvel Comics&quot; onChange={(e: React.FormEvent&lt;HTMLInputElement&gt;) =&gt; setSearchTerm(e.target.value)} /&gt; {isSearching &amp;&amp; &lt;div&gt;Searching ...&lt;/div&gt;} {results.map((result) =&gt; ( &lt;div key={result.id}&gt; &lt;h4&gt;{result.title}&lt;/h4&gt; &lt;img src={`${result.thumbnail.path}/portrait_incredible.${result.thumbnail.extension}`} /&gt; &lt;/div&gt; ))} &lt;/div&gt; );}// API search functionfunction searchCharacters(search: string): Promise&lt;any[]&gt; { const apiKey:string = &quot;f9dfb1e8d466d36c27850bedd2047687&quot;; return fetch( `https://gateway.marvel.com/v1/public/comics?apikey=${apiKey}&amp;titleStartsWith=${search}`, { method: &quot;GET&quot;, } ) .then((r) =&gt; r.json()) .then((r) =&gt; r.data.results) .catch((error) =&gt; { console.error(error); return []; });}// Hook// T is a generic type for value parameter, our case this will be stringfunction useDebounce&lt;T&gt;(value: T, delay: number): T { // State and setters for debounced value const [debouncedValue, setDebouncedValue] = useState&lt;T&gt;(value); useEffect( () =&gt; { // Update debounced value after delay const handler = setTimeout(() =&gt; { setDebouncedValue(value); }, delay); // Cancel the timeout if value changes (also on delay change or unmount) // This is how we prevent debounced value from updating if value is changed ... // .. within the delay period. Timeout gets cleared and restarted. return () =&gt; { clearTimeout(handler); }; }, [value, delay] // Only re-call effect if value or delay changes ); return debouncedValue;}","link":"/2021/01/19/react/useHooks/useDebounce/"},{"title":"useCallback","text":"If you find yourself adding a lot of event listeners using useEffect you might consider moving that logic to a custom hook. In the recipe below we create a useEventListener hook that handles checking if addEventListener is supported, adding the event listener, and removal on cleanup. See it in action in the CodeSandbox demo. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import { useState, useRef, useEffect, useCallback } from &quot;react&quot;;// Usagefunction App() { // State for storing mouse coordinates const [coords, setCoords] = useState({ x: 0, y: 0 }); // Event handler utilizing useCallback ... // ... so that reference never changes. const handler = useCallback( ({ clientX, clientY }) =&gt; { // Update coordinates setCoords({ x: clientX, y: clientY }); }, [setCoords] ); // Add event listener using our hook useEventListener(&quot;mousemove&quot;, handler); return ( &lt;h1&gt; The mouse position is ({coords.x}, {coords.y}) &lt;/h1&gt; );}// Hookfunction useEventListener(eventName, handler, element = window) { // Create a ref that stores handler const savedHandler = useRef(); // Update ref.current value if handler changes. // This allows our effect below to always get latest handler ... // ... without us needing to pass it in effect deps array ... // ... and potentially cause effect to re-run every render. useEffect(() =&gt; { savedHandler.current = handler; }, [handler]); useEffect( () =&gt; { // Make sure element supports addEventListener // On const isSupported = element &amp;&amp; element.addEventListener; if (!isSupported) return; // Create event listener that calls handler function stored in ref const eventListener = (event) =&gt; savedHandler.current(event); // Add event listener element.addEventListener(eventName, eventListener); // Remove event listener on cleanup return () =&gt; { element.removeEventListener(eventName, eventListener); }; }, [eventName, element] // Re-run if eventName or element changes );}","link":"/2021/01/19/react/useHooks/useEventListener/"},{"title":"useFirestoreQuery","text":"This hook makes it super easy to subscribe to data in your Firestore database without having to worry about state management. Instead of calling Firestore’s query.onSnapshot() method you simply pass a query to useFirestoreQuery() and you get back everything you need, including status, data, and error. Your component will re-render when data changes and your subscription will be automatically removed when the component unmounts. Our example even supports dependent queries where you can wait on needed data by passing a falsy value to the hook. Read through the recipe and comments below to see how it works. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// Usagefunction ProfilePage({ uid }) { // Subscribe to Firestore document const { data, status, error } = useFirestoreQuery( firestore.collection(&quot;profiles&quot;).doc(uid) ); if (status === &quot;loading&quot;) { return &quot;Loading...&quot;; } if (status === &quot;error&quot;) { return `Error: ${error.message}`; } return ( &lt;div&gt; &lt;ProfileHeader avatar={data.avatar} name={data.name} /&gt; &lt;Posts posts={data.posts} /&gt; &lt;/div&gt; );}// Reducer for hook state and actionsconst reducer = (state, action) =&gt; { switch (action.type) { case &quot;idle&quot;: return { status: &quot;idle&quot;, data: undefined, error: undefined }; case &quot;loading&quot;: return { status: &quot;loading&quot;, data: undefined, error: undefined }; case &quot;success&quot;: return { status: &quot;success&quot;, data: action.payload, error: undefined }; case &quot;error&quot;: return { status: &quot;error&quot;, data: undefined, error: action.payload }; default: throw new Error(&quot;invalid action&quot;); }};// Hookfunction useFirestoreQuery(query) { // Our initial state // Start with an &quot;idle&quot; status if query is falsy, as that means hook consumer is // waiting on required data before creating the query object. // Example: useFirestoreQuery(uid &amp;&amp; firestore.collection(&quot;profiles&quot;).doc(uid)) const initialState = { status: query ? &quot;loading&quot; : &quot;idle&quot;, data: undefined, error: undefined, }; // Setup our state and actions const [state, dispatch] = useReducer(reducer, initialState); // Get cached Firestore query object with useMemoCompare (https://usehooks.com/useMemoCompare) // Needed because firestore.collection(&quot;profiles&quot;).doc(uid) will always being a new object reference // causing effect to run -&gt; state change -&gt; rerender -&gt; effect runs -&gt; etc ... // This is nicer than requiring hook consumer to always memoize query with useMemo. const queryCached = useMemoCompare(query, (prevQuery) =&gt; { // Use built-in Firestore isEqual method to determine if &quot;equal&quot; return prevQuery &amp;&amp; query &amp;&amp; query.isEqual(prevQuery); }); useEffect(() =&gt; { // Return early if query is falsy and reset to &quot;idle&quot; status in case // we're coming from &quot;success&quot; or &quot;error&quot; status due to query change. if (!queryCached) { dispatch({ type: &quot;idle&quot; }); return; } dispatch({ type: &quot;loading&quot; }); // Subscribe to query with onSnapshot // Will unsubscribe on cleanup since this returns an unsubscribe function return queryCached.onSnapshot( (response) =&gt; { // Get data for collection or doc const data = response.docs ? getCollectionData(response) : getDocData(response); dispatch({ type: &quot;success&quot;, payload: data }); }, (error) =&gt; { dispatch({ type: &quot;error&quot;, payload: error }); } ); }, [queryCached]); // Only run effect if queryCached changes return state;}// Get doc data and merge doc.idfunction getDocData(doc) { return doc.exists === true ? { id: doc.id, ...doc.data() } : null;}// Get array of doc data from collectionfunction getCollectionData(collection) { return collection.docs.map(getDocData);}","link":"/2021/01/19/react/useHooks/useFirestoreQuery/"},{"title":"useHistory","text":"This hook makes it really easy to add undo/redo functionality to your app. Our recipe is a simple drawing app. It generates a grid of blocks, allows you to click any block to toggle its color, and uses the useHistory hook so we can undo, redo, or clear all changes to the canvas. Check out our CodeSandbox demo. Within our hook we’re using useReducer to store state instead of useState, which should look familiar to anyone that’s used redux (read more about useReducer in the official docs). The hook code was copied, with minor changes, from the excellent use-undo library, so if you’d like to pull this into your project you can also use that library via npm. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import { useReducer, useCallback } from &quot;react&quot;;// Usagefunction App() { const { state, set, undo, redo, clear, canUndo, canRedo } = useHistory({}); return ( &lt;div className=&quot;container&quot;&gt; &lt;div className=&quot;controls&quot;&gt; &lt;div className=&quot;title&quot;&gt;👩‍🎨 Click squares to draw&lt;/div&gt; &lt;button onClick={undo} disabled={!canUndo}&gt; Undo &lt;/button&gt; &lt;button onClick={redo} disabled={!canRedo}&gt; Redo &lt;/button&gt; &lt;button onClick={clear}&gt;Clear&lt;/button&gt; &lt;/div&gt; &lt;div className=&quot;grid&quot;&gt; {((blocks, i, len) =&gt; { // Generate a grid of blocks while (++i &lt;= len) { const index = i; blocks.push( &lt;div // Give block &quot;active&quot; class if true in state object className={&quot;block&quot; + (state[index] ? &quot; active&quot; : &quot;&quot;)} // Toggle boolean value of clicked block and merge into current state onClick={() =&gt; set({ ...state, [index]: !state[index] })} key={i} /&gt; ); } return blocks; })([], 0, 625)} &lt;/div&gt; &lt;/div&gt; );}// Initial state that we pass into useReducerconst initialState = { // Array of previous state values updated each time we push a new state past: [], // Current state value present: null, // Will contain &quot;future&quot; state values if we undo (so we can redo) future: [],};// Our reducer function to handle state changes based on actionconst reducer = (state, action) =&gt; { const { past, present, future } = state; switch (action.type) { case &quot;UNDO&quot;: const previous = past[past.length - 1]; const newPast = past.slice(0, past.length - 1); return { past: newPast, present: previous, future: [present, ...future], }; case &quot;REDO&quot;: const next = future[0]; const newFuture = future.slice(1); return { past: [...past, present], present: next, future: newFuture, }; case &quot;SET&quot;: const { newPresent } = action; if (newPresent === present) { return state; } return { past: [...past, present], present: newPresent, future: [], }; case &quot;CLEAR&quot;: const { initialPresent } = action; return { ...initialState, present: initialPresent, }; }};// Hookconst useHistory = (initialPresent) =&gt; { const [state, dispatch] = useReducer(reducer, { ...initialState, present: initialPresent, }); const canUndo = state.past.length !== 0; const canRedo = state.future.length !== 0; // Setup our callback functions // We memoize with useCallback to prevent unnecessary re-renders const undo = useCallback(() =&gt; { if (canUndo) { dispatch({ type: &quot;UNDO&quot; }); } }, [canUndo, dispatch]); const redo = useCallback(() =&gt; { if (canRedo) { dispatch({ type: &quot;REDO&quot; }); } }, [canRedo, dispatch]); const set = useCallback( (newPresent) =&gt; dispatch({ type: &quot;SET&quot;, newPresent }), [dispatch] ); const clear = useCallback(() =&gt; dispatch({ type: &quot;CLEAR&quot;, initialPresent }), [ dispatch, ]); // If needed we could also return past and future state return { state: state.present, set, undo, redo, clear, canUndo, canRedo };};","link":"/2021/01/19/react/useHooks/useHistory/"},{"title":"useHover","text":"Detect whether the mouse is hovering an element. The hook returns a refand a boolean value indicating whether the element with that ref is currently beinghovered. Just add the returned ref to any element whose hover state you wantto monitor. One potential bug with this method: If you have logic that changes the element that hoverRef is added to then your event listeners will not necessarily get applied to the new element. If you need this functionality then use this alternate version that utilizes a callback ref. 12345678910111213141516171819202122232425262728293031323334// Usagefunction App() { const [hoverRef, isHovered] = useHover(); return &lt;div ref={hoverRef}&gt;{isHovered ? &quot;😁&quot; : &quot;☹️&quot;}&lt;/div&gt;;}// Hookfunction useHover() { const [value, setValue] = useState(false); const ref = useRef(null); const handleMouseOver = () =&gt; setValue(true); const handleMouseOut = () =&gt; setValue(false); useEffect( () =&gt; { const node = ref.current; if (node) { node.addEventListener(&quot;mouseover&quot;, handleMouseOver); node.addEventListener(&quot;mouseout&quot;, handleMouseOut); return () =&gt; { node.removeEventListener(&quot;mouseover&quot;, handleMouseOver); node.removeEventListener(&quot;mouseout&quot;, handleMouseOut); }; } }, [ref.current] // Recall only if ref changes ); return [ref, value];} 123456789101112131415161718192021222324252627282930313233343536// Usagefunction App() { const [hoverRef, isHovered] = useHover&lt;HTMLDivElement&gt;(); return &lt;div ref={hoverRef}&gt;{isHovered ? &quot;😁&quot; : &quot;☹️&quot;}&lt;/div&gt;;}// Hook// T - could be any type of HTML element like: HTMLDivElement, HTMLParagraphElement and etc.// hook returns tuple(array) with type [any, boolean]function useHover&lt;T&gt;(): [MutableRefObject&lt;T&gt;, boolean] { const [value, setValue] = useState&lt;boolean&gt;(false); const ref: any = useRef&lt;T | null&gt;(null); const handleMouseOver = (): void =&gt; setValue(true); const handleMouseOut = (): void =&gt; setValue(false); useEffect( () =&gt; { const node: any = ref.current; if (node) { node.addEventListener(&quot;mouseover&quot;, handleMouseOver); node.addEventListener(&quot;mouseout&quot;, handleMouseOut); return () =&gt; { node.removeEventListener(&quot;mouseover&quot;, handleMouseOver); node.removeEventListener(&quot;mouseout&quot;, handleMouseOut); }; } }, [ref.current] // Recall only if ref changes ); return [ref, value];}","link":"/2021/01/19/react/useHooks/useHover/"},{"title":"useKeyPress","text":"This hook makes it easy to detect when the user is pressing a specific key on their keyboard. The recipe is fairly simple, as I want to show how little code is required, but I challenge any readers to create a more advanced version of this hook. Detecting when multiple keys are held down at the same time would be a nice addition. Bonus points: also require they be held down in a specified order. Feel free to share anything you’ve created in this recipe’s gist. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import { useState, useEffect } from &quot;react&quot;;// Usagefunction App() { // Call our hook for each key that we'd like to monitor const happyPress = useKeyPress(&quot;h&quot;); const sadPress = useKeyPress(&quot;s&quot;); const robotPress = useKeyPress(&quot;r&quot;); const foxPress = useKeyPress(&quot;f&quot;); return ( &lt;div&gt; &lt;div&gt;h, s, r, f&lt;/div&gt; &lt;div&gt; {happyPress &amp;&amp; &quot;😊&quot;} {sadPress &amp;&amp; &quot;😢&quot;} {robotPress &amp;&amp; &quot;🤖&quot;} {foxPress &amp;&amp; &quot;🦊&quot;} &lt;/div&gt; &lt;/div&gt; );}// Hookfunction useKeyPress(targetKey) { // State for keeping track of whether key is pressed const [keyPressed, setKeyPressed] = useState&lt;boolean&gt;(false); // If pressed key is our target key then set to true function downHandler({ key }) { if (key === targetKey) { setKeyPressed(true); } } // If released key is our target key then set to false const upHandler = ({ key }) =&gt; { if (key === targetKey) { setKeyPressed(false); } }; // Add event listeners useEffect(() =&gt; { window.addEventListener(&quot;keydown&quot;, downHandler); window.addEventListener(&quot;keyup&quot;, upHandler); // Remove event listeners on cleanup return () =&gt; { window.removeEventListener(&quot;keydown&quot;, downHandler); window.removeEventListener(&quot;keyup&quot;, upHandler); }; }, []); // Empty array ensures that effect is only run on mount and unmount return keyPressed;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import { useState, useEffect } from &quot;react&quot;;// Usagefunction App() { // Call our hook for each key that we'd like to monitor const happyPress: boolean = useKeyPress(&quot;h&quot;); const sadPress: boolean = useKeyPress(&quot;s&quot;); const robotPress: boolean = useKeyPress(&quot;r&quot;); const foxPress: boolean = useKeyPress(&quot;f&quot;); return ( &lt;div&gt; &lt;div&gt;h, s, r, f&lt;/div&gt; &lt;div&gt; {happyPress &amp;&amp; &quot;😊&quot;} {sadPress &amp;&amp; &quot;😢&quot;} {robotPress &amp;&amp; &quot;🤖&quot;} {foxPress &amp;&amp; &quot;🦊&quot;} &lt;/div&gt; &lt;/div&gt; );}// Hookfunction useKeyPress(targetKey: string): boolean { // State for keeping track of whether key is pressed const [keyPressed, setKeyPressed] = useState(false); // If pressed key is our target key then set to true function downHandler({ key }): void { if (key === targetKey) { setKeyPressed(true); } } // If released key is our target key then set to false const upHandler = ({ key }): void =&gt; { if (key === targetKey) { setKeyPressed(false); } }; // Add event listeners useEffect(() =&gt; { window.addEventListener(&quot;keydown&quot;, downHandler); window.addEventListener(&quot;keyup&quot;, upHandler); // Remove event listeners on cleanup return () =&gt; { window.removeEventListener(&quot;keydown&quot;, downHandler); window.removeEventListener(&quot;keyup&quot;, upHandler); }; }, []); // Empty array ensures that effect is only run on mount and unmount return keyPressed;}","link":"/2021/01/19/react/useHooks/useKeyPress/"},{"title":"useKeyPress","text":"Sync state to local storage so that it persists through a page refresh.Usage is similar to useState except we pass in a local storage key so that we candefault to that value on page load instead of the specified initial value. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import { useState } from &quot;react&quot;;// Usagefunction App() { // Similar to useState but first arg is key to the value in local storage. const [name, setName] = useLocalStorage(&quot;name&quot;, &quot;Bob&quot;); return ( &lt;div&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Enter your name&quot; value={name} onChange={(e) =&gt; setName(e.target.value)} /&gt; &lt;/div&gt; );}// Hookfunction useLocalStorage(key, initialValue) { // State to store our value // Pass initial state function to useState so logic is only executed once const [storedValue, setStoredValue] = useState(() =&gt; { try { // Get from local storage by key const item = window.localStorage.getItem(key); // Parse stored json or if none return initialValue return item ? JSON.parse(item) : initialValue; } catch (error) { // If error also return initialValue console.log(error); return initialValue; } }); // Return a wrapped version of useState's setter function that ... // ... persists the new value to localStorage. const setValue = (value) =&gt; { try { // Allow value to be a function so we have same API as useState const valueToStore = value instanceof Function ? value(storedValue) : value; // Save state setStoredValue(valueToStore); // Save to local storage window.localStorage.setItem(key, JSON.stringify(valueToStore)); } catch (error) { // A more advanced implementation would handle the error case console.log(error); } }; return [storedValue, setValue];} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import { useState } from &quot;react&quot;;// Usagefunction App() { // Similar to useState but first arg is key to the value in local storage. const [name, setName] = useLocalStorage&lt;string&gt;(&quot;name&quot;, &quot;Bob&quot;); return ( &lt;div&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Enter your name&quot; value={name} onChange={(e) =&gt; setName(e.target.value)} /&gt; &lt;/div&gt; );}// Hookfunction useLocalStorage&lt;T&gt;(key: string, initialValue: T) { // State to store our value // Pass initial state function to useState so logic is only executed once const [storedValue, setStoredValue] = useState&lt;T&gt;(() =&gt; { try { // Get from local storage by key const item = window.localStorage.getItem(key); // Parse stored json or if none return initialValue return item ? JSON.parse(item) : initialValue; } catch (error) { // If error also return initialValue console.log(error); return initialValue; } }); // Return a wrapped version of useState's setter function that ... // ... persists the new value to localStorage. const setValue = (value: T | ((val: T) =&gt; T)) =&gt; { try { // Allow value to be a function so we have same API as useState const valueToStore = value instanceof Function ? value(storedValue) : value; // Save state setStoredValue(valueToStore); // Save to local storage window.localStorage.setItem(key, JSON.stringify(valueToStore)); } catch (error) { // A more advanced implementation would handle the error case console.log(error); } }; return [storedValue, setValue] as const;}","link":"/2021/01/19/react/useHooks/useLocalStorage/"},{"title":"useLockBodyScroll","text":"Sometimes you want to prevent your users from being able to scroll the body of your page while a particular component is absolutely positioned over your page (think modal or full-screen mobile menu). It can be confusing to see the background content scroll underneath a modal, especially if you intended to scroll an area within the modal. Well, this hook solves that! Simply call the useLockBodyScroll hook in any component and body scrolling will be locked until that component unmounts. See it in action in the CodeSandbox Demo. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import { useState, useLayoutEffect } from &quot;react&quot;;// Usagefunction App() { // State for our modal const [modalOpen, setModalOpen] = useState(false); return ( &lt;div&gt; &lt;button onClick={() =&gt; setModalOpen(true)}&gt;Show Modal&lt;/button&gt; &lt;Content /&gt; {modalOpen &amp;&amp; ( &lt;Modal title=&quot;Try scrolling&quot; content=&quot;I bet you you can't! Muahahaha 😈&quot; onClose={() =&gt; setModalOpen(false)} /&gt; )} &lt;/div&gt; );}function Modal({ title, content, onClose }) { // Call hook to lock body scroll useLockBodyScroll(); return ( &lt;div className=&quot;modal-overlay&quot; onClick={onClose}&gt; &lt;div className=&quot;modal&quot;&gt; &lt;h2&gt;{title}&lt;/h2&gt; &lt;p&gt;{content}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; );}// Hookfunction useLockBodyScroll() { useLayoutEffect(() =&gt; { // Get original body overflow const originalStyle = window.getComputedStyle(document.body).overflow; // Prevent scrolling on mount document.body.style.overflow = &quot;hidden&quot;; // Re-enable scrolling when component unmounts return () =&gt; (document.body.style.overflow = originalStyle); }, []); // Empty array ensures effect is only run on mount and unmount} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import { useState, useLayoutEffect } from &quot;react&quot;;// Usagefunction App() { // State for our modal const [modalOpen, setModalOpen] = useState&lt;boolean&gt;(false); return ( &lt;div&gt; &lt;button onClick={() =&gt; setModalOpen(true)}&gt;Show Modal&lt;/button&gt; &lt;Content /&gt; {modalOpen &amp;&amp; ( &lt;Modal title=&quot;Try scrolling&quot; content=&quot;I bet you you can't! Muahahaha 😈&quot; onClose={() =&gt; setModalOpen(false)} /&gt; )} &lt;/div&gt; );}// Define modal props typetype ModalProps = { title: string; content: string; onClose: () =&gt; void;}function Modal({ title, content, onClose } : ModalProps) { // Call hook to lock body scroll useLockBodyScroll(); return ( &lt;div className=&quot;modal-overlay&quot; onClick={onClose}&gt; &lt;div className=&quot;modal&quot;&gt; &lt;h2&gt;{title}&lt;/h2&gt; &lt;p&gt;{content}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; );}// Hookfunction useLockBodyScroll(): void { // useLaoutEffect callback return type is &quot;() =&gt; void&quot; type useLayoutEffect(() : () =&gt; void =&gt; { // Get original body overflow const originalStyle: string = window.getComputedStyle(document.body).overflow; // Prevent scrolling on mount document.body.style.overflow = &quot;hidden&quot;; // Re-enable scrolling when component unmounts return () =&gt; (document.body.style.overflow = originalStyle); }, []); // Empty array ensures effect is only run on mount and unmount}","link":"/2021/01/19/react/useHooks/useLockBodyScroll/"},{"title":"useMedia","text":"This hook makes it super easy to utilize media queries in your component logic. In our example below we render a different number of columns depending on which media query matches the current screen width, and then distribute images amongst the columns in a way that limits column height difference (we don’t want one column way longer than the rest).You could create a hook that directly measures screen width instead of using media queries, but this method is nice because it makes it easy to share media queries between JS and your stylesheet. See it in action in the CodeSandbox Demo. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import { useState, useEffect } from &quot;react&quot;;function App() { const columnCount = useMedia( // Media queries [&quot;(min-width: 1500px)&quot;, &quot;(min-width: 1000px)&quot;, &quot;(min-width: 600px)&quot;], // Column counts (relates to above media queries by array index) [5, 4, 3], // Default column count 2 ); // Create array of column heights (start at 0) let columnHeights = new Array(columnCount).fill(0); // Create array of arrays that will hold each column's items let columns = new Array(columnCount).fill().map(() =&gt; []); data.forEach((item) =&gt; { // Get index of shortest column const shortColumnIndex = columnHeights.indexOf(Math.min(...columnHeights)); // Add item columns[shortColumnIndex].push(item); // Update height columnHeights[shortColumnIndex] += item.height; }); // Render columns and items return ( &lt;div className=&quot;App&quot;&gt; &lt;div className=&quot;columns is-mobile&quot;&gt; {columns.map((column) =&gt; ( &lt;div className=&quot;column&quot;&gt; {column.map((item) =&gt; ( &lt;div className=&quot;image-container&quot; style={{ // Size image container to aspect ratio of image paddingTop: (item.height / item.width) * 100 + &quot;%&quot;, }} &gt; &lt;img src={item.image} alt=&quot;&quot; /&gt; &lt;/div&gt; ))} &lt;/div&gt; ))} &lt;/div&gt; &lt;/div&gt; );}// Hookfunction useMedia(queries, values, defaultValue) { // Array containing a media query list for each query const mediaQueryLists = queries.map((q) =&gt; window.matchMedia(q)); // Function that gets value based on matching media query const getValue = () =&gt; { // Get index of first media query that matches const index = mediaQueryLists.findIndex((mql) =&gt; mql.matches); // Return related value or defaultValue if none return typeof values[index] !== &quot;undefined&quot; ? values[index] : defaultValue; }; // State and setter for matched value const [value, setValue] = useState(getValue); useEffect( () =&gt; { // Event listener callback // Note: By defining getValue outside of useEffect we ensure that it has ... // ... current values of hook args (as this hook callback is created once on mount). const handler = () =&gt; setValue(getValue); // Set a listener for each media query with above handler as callback. mediaQueryLists.forEach((mql) =&gt; mql.addListener(handler)); // Remove listeners on cleanup return () =&gt; mediaQueryLists.forEach((mql) =&gt; mql.removeListener(handler)); }, [] // Empty array ensures effect is only run on mount and unmount ); return value;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import { useState, useEffect } from &quot;react&quot;;function App() { const columnCount = useMedia&lt;number&gt;( // Media queries [&quot;(min-width: 1500px)&quot;, &quot;(min-width: 1000px)&quot;, &quot;(min-width: 600px)&quot;], // Column counts (relates to above media queries by array index) [5, 4, 3], // Default column count 2 ); // Create array of column heights (start at 0) let columnHeights = new Array(columnCount).fill(0); // Create array of arrays that will hold each column's items let columns = new Array(columnCount).fill().map(() =&gt; []) as Array&lt; DataProps[] &gt;; (data as DataProps[]).forEach((item) =&gt; { // Get index of shortest column const shortColumnIndex = columnHeights.indexOf(Math.min(...columnHeights)); // Add item columns[shortColumnIndex].push(item); // Update height columnHeights[shortColumnIndex] += item.height; }); // Render columns and items return ( &lt;div className=&quot;App&quot;&gt; &lt;div className=&quot;columns is-mobile&quot;&gt; {columns.map((column) =&gt; ( &lt;div className=&quot;column&quot;&gt; {column.map((item) =&gt; ( &lt;div className=&quot;image-container&quot; style={{ // Size image container to aspect ratio of image paddingTop: (item.height / item.width) * 100 + &quot;%&quot;, }} &gt; &lt;img src={item.image} alt=&quot;&quot; /&gt; &lt;/div&gt; ))} &lt;/div&gt; ))} &lt;/div&gt; &lt;/div&gt; );}// Hookconst useMedia = &lt;T&gt;(queries: string[], values: T[], defaultValue: T) =&gt; { // Array containing a media query list for each query const mediaQueryLists = queries.map((q) =&gt; window.matchMedia(q)); // Function that gets value based on matching media query const getValue = () =&gt; { // Get index of first media query that matches const index = mediaQueryLists.findIndex((mql) =&gt; mql.matches); // Return related value or defaultValue if none return values?.[index] || defaultValue; }; // State and setter for matched value const [value, setValue] = useState&lt;T&gt;(getValue); useEffect( () =&gt; { // Event listener callback // Note: By defining getValue outside of useEffect we ensure that it has ... // ... current values of hook args (as this hook callback is created once on mount). const handler = () =&gt; setValue(getValue); // Set a listener for each media query with above handler as callback. mediaQueryLists.forEach((mql) =&gt; mql.addListener(handler)); // Remove listeners on cleanup return () =&gt; mediaQueryLists.forEach((mql) =&gt; mql.removeListener(handler)); }, [] // Empty array ensures effect is only run on mount and unmount ); return value;};","link":"/2021/01/19/react/useHooks/useMedia/"},{"title":"useMemo","text":"React has a built-in hook called useMemo that allows you to memoize expensive functions so that you can avoid calling them on every render. You simple pass in a function and an array of inputs and useMemo will only recompute the memoized value when one of the inputs has changed. In our example below we have an expensive function called computeLetterCount (for demo purposes we make it slow by including a large and completely unnecessary loop). When the current selected word changes you’ll notice a delay as it has to recall computeLetterCount on the new word. We also have a separate counter that gets incremented every time the increment button is clicked. When that counter is incremented you’ll notice that there is zero lag between renders. This is because computeLetterCount is not called again. The input word hasn’t changed and thus the cached value is returned. You’ll probably want to check out the CodeSandbox demo so you can see for yourself. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import { useState, useMemo } from &quot;react&quot;;// Usagefunction App() { // State for our counter const [count, setCount] = useState(0); // State to keep track of current word in array we want to show const [wordIndex, setWordIndex] = useState(0); // Words we can flip through and view letter count const words = [&quot;hey&quot;, &quot;this&quot;, &quot;is&quot;, &quot;cool&quot;]; const word = words[wordIndex]; // Returns number of letters in a word // We make it slow by including a large and completely unnecessary loop const computeLetterCount = (word) =&gt; { let i = 0; while (i &lt; 1000000000) i++; return word.length; }; // Memoize computeLetterCount so it uses cached return value if input array ... // ... values are the same as last time the function was run. const letterCount = useMemo(() =&gt; computeLetterCount(word), [word]); // This would result in lag when incrementing the counter because ... // ... we'd have to wait for expensive function when re-rendering. //const letterCount = computeLetterCount(word); return ( &lt;div style={{ padding: &quot;15px&quot; }}&gt; &lt;h2&gt;Compute number of letters (slow 🐌)&lt;/h2&gt; &lt;p&gt; &quot;{word}&quot; has {letterCount} letters &lt;/p&gt; &lt;button onClick={() =&gt; { const next = wordIndex + 1 === words.length ? 0 : wordIndex + 1; setWordIndex(next); }} &gt; Next word &lt;/button&gt; &lt;h2&gt;Increment a counter (fast ⚡️)&lt;/h2&gt; &lt;p&gt;Counter: {count}&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt; &lt;/div&gt; );}","link":"/2021/01/19/react/useHooks/useMemo/"},{"title":"useMemoCompare","text":"This hook is similar to useMemo, but instead of passing an array of dependencies we pass a custom compare function that receives the previous and new value. The compare function can then compare nested properties, call object methods, or anything else to determine equality. If the compare function returns true then the hook returns the old object reference.It’s worth noting that, unlike useMemo, this hook isn’t meant to avoid expensive calculations. It needs to be passed a computed value so that it can compare it to the old value. Where this comes in handy is if you want to offer a library to other developers and it would be annoying to force them to memoize an object before passing it to your library. If that object is created in the component body (often the case if it’s based on props) then it’s going to be a new object on every render. If that object is a useEffect dependency then it’s going to cause the effect to fire on every render, which can lead to problems or even an infinite loop. This hook allows you to avoid that scenario by using the old object reference instead of the new one if your custom comparison function deems them equal.Read through the recipe and comments below. For a more practical example be sure to check out our useFirestoreQuery hook. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React, { useState, useEffect, useRef } from &quot;react&quot;;// Usagefunction MyComponent({ obj }) { const [state, setState] = useState(); // Use the previous obj value if the &quot;id&quot; property hasn't changed const objFinal = useMemoCompare(obj, (prev, next) =&gt; { return prev &amp;&amp; prev.id === next.id; }); // Here we want to fire off an effect if objFinal changes. // If we had used obj directly without the above hook and obj was technically a // new object on every render then the effect would fire on every render. // Worse yet, if our effect triggered a state change it could cause an endless loop // where effect runs -&gt; state change causes rerender -&gt; effect runs -&gt; etc ... useEffect(() =&gt; { // Call a method on the object and set results to state return objFinal.someMethod().then((value) =&gt; setState(value)); }, [objFinal]); // So why not pass [obj.id] as the dependency array instead? useEffect(() =&gt; { // Then eslint-plugin-hooks would rightfully complain that obj is not in the // dependency array and we'd have to use eslint-disable-next-line to work around that. // It's much cleaner to just get the old object reference with our custom hook. return obj.someMethod().then((value) =&gt; setState(value)); }, [obj.id]); return &lt;div&gt; ... &lt;/div&gt;;}// Hookfunction useMemoCompare(next, compare) { // Ref for storing previous value const previousRef = useRef(); const previous = previousRef.current; // Pass previous and next value to compare function // to determine whether to consider them equal. const isEqual = compare(previous, next); // If not equal update previousRef to next value. // We only update if not equal so that this hook continues to return // the same old value if compare keeps returning true. useEffect(() =&gt; { if (!isEqual) { previousRef.current = next; } }); // Finally, if equal then return the previous value return isEqual ? previous : next;}","link":"/2021/01/19/react/useHooks/useMemoCompare/"},{"title":"useOnClickOutside","text":"This hook allows you to detect clicks outside of a specified element.In the example below we use it to close a modal when any element outside of themodal is clicked. By abstracting this logic out into a hook we can easily use itacross all of our components that need this kind of functionality (dropdown menus,tooltips, etc). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import { useState, useEffect, useRef } from &quot;react&quot;;// Usagefunction App() { // Create a ref that we add to the element for which we want to detect outside clicks const ref = useRef(); // State for our modal const [isModalOpen, setModalOpen] = useState(false); // Call hook passing in the ref and a function to call on outside click useOnClickOutside(ref, () =&gt; setModalOpen(false)); return ( &lt;div&gt; {isModalOpen ? ( &lt;div ref={ref}&gt; 👋 Hey, I'm a modal. Click anywhere outside of me to close. &lt;/div&gt; ) : ( &lt;button onClick={() =&gt; setModalOpen(true)}&gt;Open Modal&lt;/button&gt; )} &lt;/div&gt; );}// Hookfunction useOnClickOutside(ref, handler) { useEffect( () =&gt; { const listener = (event) =&gt; { // Do nothing if clicking ref's element or descendent elements if (!ref.current || ref.current.contains(event.target)) { return; } handler(event); }; document.addEventListener(&quot;mousedown&quot;, listener); document.addEventListener(&quot;touchstart&quot;, listener); return () =&gt; { document.removeEventListener(&quot;mousedown&quot;, listener); document.removeEventListener(&quot;touchstart&quot;, listener); }; }, // Add ref and handler to effect dependencies // It's worth noting that because passed in handler is a new ... // ... function on every render that will cause this effect ... // ... callback/cleanup to run every render. It's not a big deal ... // ... but to optimize you can wrap handler in useCallback before ... // ... passing it into this hook. [ref, handler] );}","link":"/2021/01/19/react/useHooks/useOnClickOutside/"},{"title":"useOnScreen","text":"This hook allows you to easily detect when an element is visible on thescreen as well as specify how much of the element should be visible before beingconsidered on screen. Perfect for lazy loading images or triggering animations whenthe user has scrolled down to a particular section. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import { useState, useEffect, useRef } from &quot;react&quot;;// Usagefunction App() { // Ref for the element that we want to detect whether on screen const ref = useRef(); // Call the hook passing in ref and root margin // In this case it would only be considered onScreen if more ... // ... than 300px of element is visible. const onScreen = useOnScreen(ref, &quot;-300px&quot;); return ( &lt;div&gt; &lt;div style={{ height: &quot;100vh&quot; }}&gt; &lt;h1&gt;Scroll down to next section 👇&lt;/h1&gt; &lt;/div&gt; &lt;div ref={ref} style={{ height: &quot;100vh&quot;, backgroundColor: onScreen ? &quot;#23cebd&quot; : &quot;#efefef&quot;, }} &gt; {onScreen ? ( &lt;div&gt; &lt;h1&gt;Hey I'm on the screen&lt;/h1&gt; &lt;img src=&quot;https://i.giphy.com/media/ASd0Ukj0y3qMM/giphy.gif&quot; /&gt; &lt;/div&gt; ) : ( &lt;h1&gt;Scroll down 300px from the top of this section 👇&lt;/h1&gt; )} &lt;/div&gt; &lt;/div&gt; );}// Hookfunction useOnScreen(ref, rootMargin = &quot;0px&quot;) { // State and setter for storing whether element is visible const [isIntersecting, setIntersecting] = useState(false); useEffect(() =&gt; { const observer = new IntersectionObserver( ([entry]) =&gt; { // Update our state when observer callback fires setIntersecting(entry.isIntersecting); }, { rootMargin, } ); if (ref.current) { observer.observe(ref.current); } return () =&gt; { observer.unobserve(ref.current); }; }, []); // Empty array ensures that effect is only run on mount and unmount return isIntersecting;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import { useState, useEffect, useRef, MutableRefObject } from &quot;react&quot;;// Usagefunction App() { // Ref for the element that we want to detect whether on screen const ref: any = useRef&lt;HTMLDivElement&gt;(); // Call the hook passing in ref and root margin // In this case it would only be considered onScreen if more ... // ... than 300px of element is visible. const onScreen: boolean = useOnScreen&lt;HTMLDivElement&gt;(ref, &quot;-300px&quot;); return ( &lt;div&gt; &lt;div style={{ height: &quot;100vh&quot; }}&gt; &lt;h1&gt;Scroll down to next section 👇&lt;/h1&gt; &lt;/div&gt; &lt;div ref={ref} style={{ height: &quot;100vh&quot;, backgroundColor: onScreen ? &quot;#23cebd&quot; : &quot;#efefef&quot;, }} &gt; {onScreen ? ( &lt;div&gt; &lt;h1&gt;Hey I'm on the screen&lt;/h1&gt; &lt;img src=&quot;https://i.giphy.com/media/ASd0Ukj0y3qMM/giphy.gif&quot; /&gt; &lt;/div&gt; ) : ( &lt;h1&gt;Scroll down 300px from the top of this section 👇&lt;/h1&gt; )} &lt;/div&gt; &lt;/div&gt; );}// Hookfunction useOnScreen&lt;T extends Element&gt;(ref: MutableRefObject&lt;T&gt;, rootMargin: string = &quot;0px&quot;): boolean { // State and setter for storing whether element is visible const [isIntersecting, setIntersecting] = useState&lt;boolean&gt;(false); useEffect(() =&gt; { const observer = new IntersectionObserver( ([entry]) =&gt; { // Update our state when observer callback fires setIntersecting(entry.isIntersecting); }, { rootMargin, } ); if (ref.current) { observer.observe(ref.current); } return () =&gt; { observer.unobserve(ref.current); }; }, []); // Empty array ensures that effect is only run on mount and unmount return isIntersecting;}","link":"/2021/01/19/react/useHooks/useOnScreen/"},{"title":"usePrevious","text":"One question that comes up a lot is “When using hooks how do I get the previous value of props or state?”. With React class components you have the componentDidUpdate method which receives previous props and state as arguments or you can update an instance variable (this.previous = value) and reference it later to get the previous value. So how can we do this inside a functional component that doesn’t have lifecycle methods or an instance to store values on? Hooks to the rescue! We can create a custom hook that uses the useRef hook internally for storing the previous value. See the recipe below with inline comments. You can also find this example in the official React Hooks FAQ. 1234567891011121314151617181920212223242526272829303132333435import { useState, useEffect, useRef } from &quot;react&quot;;// Usagefunction App() { // State value and setter for our example const [count, setCount] = useState(0); // Get the previous value (was passed into hook on last render) const prevCount = usePrevious(count); // Display both current and previous count value return ( &lt;div&gt; &lt;h1&gt; Now: {count}, before: {prevCount} &lt;/h1&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt; &lt;/div&gt; );}// Hookfunction usePrevious(value) { // The ref object is a generic container whose current property is mutable ... // ... and can hold any value, similar to an instance property on a class const ref = useRef(); // Store current value in ref useEffect(() =&gt; { ref.current = value; }, [value]); // Only re-run if value changes // Return previous value (happens before update in useEffect above) return ref.current;} 1234567891011121314151617181920212223242526272829303132333435import { useState, useEffect, useRef } from &quot;react&quot;;// Usagefunction App() { // State value and setter for our example const [count, setCount] = useState&lt;number&gt;(0); // Get the previous value (was passed into hook on last render) const prevCount: number = usePrevious&lt;number&gt;(count); // Display both current and previous count value return ( &lt;div&gt; &lt;h1&gt; Now: {count}, before: {prevCount} &lt;/h1&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt; &lt;/div&gt; );}// Hookfunction usePrevious&lt;T&gt;(value: T): T { // The ref object is a generic container whose current property is mutable ... // ... and can hold any value, similar to an instance property on a class const ref: any = useRef&lt;T&gt;(); // Store current value in ref useEffect(() =&gt; { ref.current = value; }, [value]); // Only re-run if value changes // Return previous value (happens before update in useEffect above) return ref.current;}","link":"/2021/01/19/react/useHooks/usePrevious/"},{"title":"useRequireAuth","text":"A common need is a way to redirect the user if they are signed out and trying to view a page that should require them to be authenticated. This example shows how you can easily compose our useAuth and useRouter hooks to create a new useRequireAuth hook that does just that. Of course, this functionality could be added directly to our useAuth hook, but then we’d need to make that hook aware of our router logic. Using the power of hook composition we can keep the other two hooks as simple as possible and just utilize our new useRequireAuth when redirection is needed. 123456789101112131415161718192021222324252627282930313233343536import Dashboard from &quot;./Dashboard.js&quot;;import Loading from &quot;./Loading.js&quot;;import { useRequireAuth } from &quot;./use-require-auth.js&quot;;function DashboardPage(props) { const auth = useRequireAuth(); // If auth is null (still fetching data) // or false (logged out, above hook will redirect) // then show loading indicator. if (!auth) { return &lt;Loading /&gt;; } return &lt;Dashboard auth={auth} /&gt;;}// Hook (use-require-auth.js)import { useEffect } from &quot;react&quot;;import { useAuth } from &quot;./use-auth.js&quot;;import { useRouter } from &quot;./use-router.js&quot;;function useRequireAuth(redirectUrl = &quot;/signup&quot;) { const auth = useAuth(); const router = useRouter(); // If auth.user is false that means we're not // logged in and should redirect. useEffect(() =&gt; { if (auth.user === false) { router.push(redirectUrl); } }, [auth, router]); return auth;}","link":"/2021/01/19/react/useHooks/useRequireAuth/"},{"title":"useRouter","text":"If you use React Router you might have noticed they recently added a number of useful hooks, specifically useParams, useLocation, useHistory, and use useRouteMatch. But let’s see if we can make it even simpler by wrapping them up into a single useRouter hook that exposes just the data and methods we need. In this recipe we show how easy it is to compose multiple hooks and combine their returned state into a single object. It makes a lot of sense for libraries like React Router to offer a selection of low-level hooks, as using only the hook you need can minimize unnecessary re-renders. That said, sometimes you want a simpler developer experience and custom hooks make that easy. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import { useMemo } from &quot;react&quot;;import { useParams, useLocation, useHistory, useRouteMatch,} from &quot;react-router-dom&quot;;import queryString from &quot;query-string&quot;;// Usagefunction MyComponent() { // Get the router object const router = useRouter(); // Get value from query string (?postId=123) or route param (/:postId) console.log(router.query.postId); // Get current pathname console.log(router.pathname); // Navigate with with router.push() return &lt;button onClick={(e) =&gt; router.push(&quot;/about&quot;)}&gt;About&lt;/button&gt;;}// Hookexport function useRouter() { const params = useParams(); const location = useLocation(); const history = useHistory(); const match = useRouteMatch(); // Return our custom router object // Memoize so that a new object is only returned if something changes return useMemo(() =&gt; { return { // For convenience add push(), replace(), pathname at top level push: history.push, replace: history.replace, pathname: location.pathname, // Merge params and parsed query string into single &quot;query&quot; object // so that they can be used interchangeably. // Example: /:topic?sort=popular -&gt; { topic: &quot;react&quot;, sort: &quot;popular&quot; } query: { ...queryString.parse(location.search), // Convert string to object ...params, }, // Include match, location, history objects so we have // access to extra React Router functionality if needed. match, location, history, }; }, [params, match, location, history]);}","link":"/2021/01/19/react/useHooks/useRouter/"},{"title":"useScript","text":"This hook makes it super easy to dynamically load an external script and know when its loaded. This is useful when you need to interact with a 3rd party library (Stripe, Google Analytics, etc) and you’d prefer to load the script when needed rather then include it in the document head for every page request. In the example below we wait until the script has loaded successfully before calling a function declared in the script. If you’re interested in seeing how this would look if implemented as a Higher Order Component then check out the source of react-script-loader-hoc. I personally find it much more readable as a hook. Another advantage is because you can use this hook multiple times within a component, we don’t need to add support for loading multiple scripts and we can keep our hook logic nice and simple. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import { useState, useEffect } from &quot;react&quot;;// Usagefunction App() { const status = useScript( &quot;https://pm28k14qlj.codesandbox.io/test-external-script.js&quot; ); return ( &lt;div&gt; &lt;div&gt; Script status: &lt;b&gt;{status}&lt;/b&gt; &lt;/div&gt; {status === &quot;ready&quot; &amp;&amp; ( &lt;div&gt; Script function call response: &lt;b&gt;{TEST_SCRIPT.start()}&lt;/b&gt; &lt;/div&gt; )} &lt;/div&gt; );}// Hookfunction useScript(src) { // Keep track of script status (&quot;idle&quot;, &quot;loading&quot;, &quot;ready&quot;, &quot;error&quot;) const [status, setStatus] = useState(src ? &quot;loading&quot; : &quot;idle&quot;); useEffect( () =&gt; { // Allow falsy src value if waiting on other data needed for // constructing the script URL passed to this hook. if (!src) { setStatus(&quot;idle&quot;); return; } // Fetch existing script element by src // It may have been added by another intance of this hook let script = document.querySelector(`script[src=&quot;${src}&quot;]`); if (!script) { // Create script script = document.createElement(&quot;script&quot;); script.src = src; script.async = true; script.setAttribute(&quot;data-status&quot;, &quot;loading&quot;); // Add script to document body document.body.appendChild(script); // Store status in attribute on script // This can be read by other instances of this hook const setAttributeFromEvent = (event) =&gt; { script.setAttribute( &quot;data-status&quot;, event.type === &quot;load&quot; ? &quot;ready&quot; : &quot;error&quot; ); }; script.addEventListener(&quot;load&quot;, setAttributeFromEvent); script.addEventListener(&quot;error&quot;, setAttributeFromEvent); } else { // Grab existing script status from attribute and set to state. setStatus(script.getAttribute(&quot;data-status&quot;)); } // Script event handler to update status in state // Note: Even if the script already exists we still need to add // event handlers to update the state for *this* hook instance. const setStateFromEvent = (event) =&gt; { setStatus(event.type === &quot;load&quot; ? &quot;ready&quot; : &quot;error&quot;); }; // Add event listeners script.addEventListener(&quot;load&quot;, setStateFromEvent); script.addEventListener(&quot;error&quot;, setStateFromEvent); // Remove event listeners on cleanup return () =&gt; { if (script) { script.removeEventListener(&quot;load&quot;, setStateFromEvent); script.removeEventListener(&quot;error&quot;, setStateFromEvent); } }; }, [src] // Only re-run effect if script src changes ); return status;}","link":"/2021/01/19/react/useHooks/useScript/"},{"title":"useSpring","text":"This hook is part of the react-spring animation library which allows for highly performant physics-based animations. I try to avoid including dependencies in these recipes, but once in awhile I’m going to make an exception for hooks that expose the functionality of really useful libraries. One nice thing about react-spring is that it allows you to completely skip the React render cycle when applying animations, often giving a pretty substantial performance boost. In our recipe below we render a row of cards and apply a springy animation effect related to the mouse position over any given card. To make this work we call the useSpring hook with an array of values we want to animate, render an animated.div component (exported by react-spring), get the mouse position over a card with the onMouseMove event, then call setAnimatedProps (function returned by the hook) to update that set of values based on the mouse position. Read through the comments in the recipe below for more details or jump right over to the CodeSandbox demo. I liked this effect so much I ended up using it on my startup’s landing page 😎 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import { useState, useRef } from &quot;react&quot;;import { useSpring, animated } from &quot;react-spring&quot;;// Displays a row of cards// Usage of hook is within &lt;Card&gt; component belowfunction App() { return ( &lt;div className=&quot;container&quot;&gt; &lt;div className=&quot;row&quot;&gt; {cards.map((card, i) =&gt; ( &lt;div className=&quot;column&quot;&gt; &lt;Card&gt; &lt;div className=&quot;card-title&quot;&gt;{card.title}&lt;/div&gt; &lt;div className=&quot;card-body&quot;&gt;{card.description}&lt;/div&gt; &lt;img className=&quot;card-image&quot; src={card.image} /&gt; &lt;/Card&gt; &lt;/div&gt; ))} &lt;/div&gt; &lt;/div&gt; );}function Card({ children }) { // We add this ref to card element and use in onMouseMove event ... // ... to get element's offset and dimensions. const ref = useRef(); // Keep track of whether card is hovered so we can increment ... // ... zIndex to ensure it shows up above other cards when animation causes overlap. const [isHovered, setHovered] = useState(false); // The useSpring hook const [animatedProps, setAnimatedProps] = useSpring(() =&gt; { return { // Array containing [rotateX, rotateY, and scale] values. // We store under a single key (xys) instead of separate keys ... // ... so that we can use animatedProps.xys.interpolate() to ... // ... easily generate the css transform value below. xys: [0, 0, 1], // Setup physics config: { mass: 10, tension: 400, friction: 40, precision: 0.00001 }, }; }); return ( &lt;animated.div ref={ref} className=&quot;card&quot; onMouseEnter={() =&gt; setHovered(true)} onMouseMove={({ clientX, clientY }) =&gt; { // Get mouse x position within card const x = clientX - (ref.current.offsetLeft - (window.scrollX || window.pageXOffset || document.body.scrollLeft)); // Get mouse y position within card const y = clientY - (ref.current.offsetTop - (window.scrollY || window.pageYOffset || document.body.scrollTop)); // Set animated values based on mouse position and card dimensions const dampen = 50; // Lower the number the less rotation const xys = [ -(y - ref.current.clientHeight / 2) / dampen, // rotateX (x - ref.current.clientWidth / 2) / dampen, // rotateY 1.07, // Scale ]; // Update values to animate to setAnimatedProps({ xys: xys }); }} onMouseLeave={() =&gt; { setHovered(false); // Set xys back to original setAnimatedProps({ xys: [0, 0, 1] }); }} style={{ // If hovered we want it to overlap other cards when it scales up zIndex: isHovered ? 2 : 1, // Interpolate function to handle css changes transform: animatedProps.xys.interpolate( (x, y, s) =&gt; `perspective(600px) rotateX(${x}deg) rotateY(${y}deg) scale(${s})` ), }} &gt; {children} &lt;/animated.div&gt; );}","link":"/2021/01/19/react/useHooks/useSpring/"},{"title":"useTheme","text":"This hook makes it easy to dynamically change the appearance of your app using CSS variables. You simply pass in an object containing key/value pairs of the CSS variables you’d like to update and the hook updates each variable in the document’s root element. This is useful in situations where you can’t define styles inline (no pseudo class support) and there are too many style permutations to include each theme in your stylesheet (such as a web app that lets users customize the look of their profile). It’s worth noting that many css-in-js libraries support dynamic styles out of the box, but it’s interesting to experiment with how this can be done with just CSS variables and a React Hook. The example below is intentionally very simple, but you could imagine the theme object being stored in state or fetched from an API. Be sure to check out the CodeSandbox demo for a more interesting example and to see the accompanying stylesheet. 1234567891011121314151617181920212223242526272829303132333435363738import { useLayoutEffect } from &quot;react&quot;;import &quot;./styles.scss&quot;; // -&gt; https://codesandbox.io/s/15mko9187// Usageconst theme = { &quot;button-padding&quot;: &quot;16px&quot;, &quot;button-font-size&quot;: &quot;14px&quot;, &quot;button-border-radius&quot;: &quot;4px&quot;, &quot;button-border&quot;: &quot;none&quot;, &quot;button-color&quot;: &quot;#FFF&quot;, &quot;button-background&quot;: &quot;#6772e5&quot;, &quot;button-hover-border&quot;: &quot;none&quot;, &quot;button-hover-color&quot;: &quot;#FFF&quot;,};function App() { useTheme(theme); return ( &lt;div&gt; &lt;button className=&quot;button&quot;&gt;Button&lt;/button&gt; &lt;/div&gt; );}// Hookfunction useTheme(theme) { useLayoutEffect( () =&gt; { // Iterate through each value in theme object for (const key in theme) { // Update css variables in document's root element document.documentElement.style.setProperty(`--${key}`, theme[key]); } }, [theme] // Only call again if theme object reference changes );} 12345678910111213141516171819202122232425262728293031323334353637383940414243import { useLayoutEffect } from &quot;react&quot;;import &quot;./styles.scss&quot;; // -&gt; https://codesandbox.io/s/15mko9187// Usageconst theme = { &quot;button-padding&quot;: &quot;16px&quot;, &quot;button-font-size&quot;: &quot;14px&quot;, &quot;button-border-radius&quot;: &quot;4px&quot;, &quot;button-border&quot;: &quot;none&quot;, &quot;button-color&quot;: &quot;#FFF&quot;, &quot;button-background&quot;: &quot;#6772e5&quot;, &quot;button-hover-border&quot;: &quot;none&quot;, &quot;button-hover-color&quot;: &quot;#FFF&quot;,};// This is type of &quot;theme&quot; object, kind of dynamic typeinterface Theme { [name: string]: string;}function App() { useTheme(theme); return ( &lt;div&gt; &lt;button className=&quot;button&quot;&gt;Button&lt;/button&gt; &lt;/div&gt; );}// Hookfunction useTheme(theme: Theme): void { useLayoutEffect( (): void =&gt; { // Iterate through each value in theme object for (const key in theme) { // Update css variables in document's root element document.documentElement.style.setProperty(`--${key}`, theme[key]); } }, [theme] // Only call again if theme object reference changes );}","link":"/2021/01/19/react/useHooks/useTheme/"},{"title":"useToggle","text":"Basically, what this hook does is that, it takes a parameter with value true or false and toggles that value to opposite.It’s useful when we want to take some action into it’s opposite action, for example: show and hide modal, show more/show less text, open/close side menu. 12345678910111213141516171819202122232425import { useCallback, useState } from 'react';// Usagefunction App() { // Call the hook which returns, current value and the toggler function const [isTextChanged, setIsTextChanged] = useToggle(); return ( &lt;button onClick={setIsTextChanged}&gt;{isTextChanged ? 'Toggled' : 'Click to Toggle'}&lt;/button&gt; );}// Hook// Parameter is the boolean, with default &quot;false&quot; valueconst useToggle = (initialState = false) =&gt; { // Initialize the state const [state, setState] = useState(initialState); // Define and memorize toggler function in case we pass down the comopnent, // This function change the boolean value to it's opposite value const toggle = useCallback(() =&gt; setState(state =&gt; !state), []); return [state, toggle]} 12345678910111213141516171819202122232425import { useCallback, useState } from 'react';// Usagefunction App() { // Call the hook which returns, current value and the toggler function const [isTextChanged, setIsTextChanged] = useToggle(); return ( &lt;button onClick={setIsTextChanged}&gt;{isTextChanged ? 'Toggled' : 'Click to Toggle'}&lt;/button&gt; );}// Hook// Parameter is the boolean, with default &quot;false&quot; valueconst useToggle = (initialState: boolean = false): [boolean, any] =&gt; { // Initialize the state const [state, setState] = useState&lt;boolean&gt;(initialState); // Define and memorize toggler function in case we pass down the comopnent, // This function change the boolean value to it's opposite value const toggle = useCallback((): void =&gt; setState(state =&gt; !state), []); return [state, toggle]}","link":"/2021/01/19/react/useHooks/useToggle/"},{"title":"useWhyDidYouUpdate","text":"This hook makes it easy to see which prop changes are causing a component to re-render. If a function is particularly expensive to run and you know it renders the same results given the same props you can use the React.memo higher order component, as we’ve done with the Counter component in the below example. In this case if you’re still seeing re-renders that seem unnecessary you can drop in the useWhyDidYouUpdate hook and check your console to see which props changed between renders and view their previous/current values. Pretty nifty huh?A huge thanks to Bruno Lemos for the idea and original code. You can also see it in action in the CodeSandbox demo. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import { useState, useEffect, useRef } from &quot;react&quot;;// Let's pretend this &lt;Counter&gt; component is expensive to re-render so ...// ... we wrap with React.memo, but we're still seeing performance issues :/// So we add useWhyDidYouUpdate and check our console to see what's going on.const Counter = React.memo((props) =&gt; { useWhyDidYouUpdate(&quot;Counter&quot;, props); return &lt;div style={props.style}&gt;{props.count}&lt;/div&gt;;});function App() { const [count, setCount] = useState(0); const [userId, setUserId] = useState(0); // Our console output tells use that the style prop for &lt;Counter&gt; ... // ... changes on every render, even when we only change userId state by ... // ... clicking the &quot;switch user&quot; button. Oh of course! That's because the // ... counterStyle object is being re-created on every render. // Thanks to our hook we figured this out and realized we should probably ... // ... move this object outside of the component body. const counterStyle = { fontSize: &quot;3rem&quot;, color: &quot;red&quot;, }; return ( &lt;div&gt; &lt;div className=&quot;counter&quot;&gt; &lt;Counter count={count} style={counterStyle} /&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt; &lt;/div&gt; &lt;div className=&quot;user&quot;&gt; &lt;img src={`http://i.pravatar.cc/80?img=${userId}`} /&gt; &lt;button onClick={() =&gt; setUserId(userId + 1)}&gt;Switch User&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; );}// Hookfunction useWhyDidYouUpdate(name, props) { // Get a mutable ref object where we can store props ... // ... for comparison next time this hook runs. const previousProps = useRef(); useEffect(() =&gt; { if (previousProps.current) { // Get all keys from previous and current props const allKeys = Object.keys({ ...previousProps.current, ...props }); // Use this object to keep track of changed props const changesObj = {}; // Iterate through keys allKeys.forEach((key) =&gt; { // If previous is different from current if (previousProps.current[key] !== props[key]) { // Add to changesObj changesObj[key] = { from: previousProps.current[key], to: props[key], }; } }); // If changesObj not empty then output to console if (Object.keys(changesObj).length) { console.log(&quot;[why-did-you-update]&quot;, name, changesObj); } } // Finally update previousProps with current props for next hook call previousProps.current = props; });}","link":"/2021/01/19/react/useHooks/useWhyDidYouUpdate/"},{"title":"useWindowSize","text":"A really common need is to get the current size of the browser window.This hook returns an object containing the window’s width and height. If executedserver-side (no window object) the value of width and height will be undefined. 1234567891011121314151617181920212223242526272829303132333435363738394041424344import { useState, useEffect } from &quot;react&quot;;// Usagefunction App() { const size = useWindowSize(); return ( &lt;div&gt; {size.width}px / {size.height}px &lt;/div&gt; );}// Hookfunction useWindowSize() { // Initialize state with undefined width/height so server and client renders match // Learn more here: https://joshwcomeau.com/react/the-perils-of-rehydration/ const [windowSize, setWindowSize] = useState({ width: undefined, height: undefined, }); useEffect(() =&gt; { // Handler to call on window resize function handleResize() { // Set window width/height to state setWindowSize({ width: window.innerWidth, height: window.innerHeight, }); } // Add event listener window.addEventListener(&quot;resize&quot;, handleResize); // Call handler right away so state gets updated with initial window size handleResize(); // Remove event listener on cleanup return () =&gt; window.removeEventListener(&quot;resize&quot;, handleResize); }, []); // Empty array ensures that effect is only run on mount return windowSize;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import { useState, useEffect } from &quot;react&quot;;// Define general type for useWindowSize hook, which includes width and heightinterface Size { width: number | undefined; height: number | undefined;}// Usagefunction App() { const size: Size = useWindowSize(); return ( &lt;div&gt; {size.width}px / {size.height}px &lt;/div&gt; );}// Hookfunction useWindowSize(): Size { // Initialize state with undefined width/height so server and client renders match // Learn more here: https://joshwcomeau.com/react/the-perils-of-rehydration/ const [windowSize, setWindowSize] = useState&lt;Size&gt;({ width: undefined, height: undefined, }); useEffect(() =&gt; { // Handler to call on window resize function handleResize() { // Set window width/height to state setWindowSize({ width: window.innerWidth, height: window.innerHeight, }); } // Add event listener window.addEventListener(&quot;resize&quot;, handleResize); // Call handler right away so state gets updated with initial window size handleResize(); // Remove event listener on cleanup return () =&gt; window.removeEventListener(&quot;resize&quot;, handleResize); }, []); // Empty array ensures that effect is only run on mount return windowSize;}","link":"/2021/01/19/react/useHooks/useWindowSize/"},{"title":"文本标题处理脚本","text":"Text title processing script用于处理标题格式不规范 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt; ​&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;读取文件内容&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;textarea style=&quot;width: 100%; height: 150px&quot; id=&quot;content&quot;&gt; 要下载的文本内容。。。。 &lt;/textarea&gt; &lt;a download=&quot;data.txt&quot; id=&quot;save-btn&quot; @click=&quot;file&quot;&gt; &lt;button type=&quot;button&quot;&gt;下载&lt;/button&gt; &lt;/a&gt; &lt;script&gt; let str = `待处理文本`; const setFindTitle = (str) =&gt; { const len = str.match(/第一章 /g).length; for (let i = 1; i &lt;= len; i++) { str = str.replace('第一章 ', `第${i}章 `); console.log('加载中。。。'); if (i == len) { console.log(str); var content, saveBtn; content = document.querySelector('#content'); content.value = str; saveBtn = document.querySelector('#save-btn'); content.addEventListener( 'change', (function self() { saveBtn.setAttribute( 'href', 'data:text/paint; utf-8,' + content.value ); return self; })() ); } } }; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2021/01/19/scripts/textTitleScript/"},{"title":"http协议原理","text":"http协议原理前言 目前，前端必须要了解的知识中HTTP必不可少，而自己也在学习当中，我主要是通过阅读《图解HTTP进行学习 若有错误请大家指出。 http 基础网络 为了理解 HTTP，我们有必要事先了解一下 TCP/IP 协议族。 通常使用的网络（包括互联网）是在 TCP/IP 协议族的基础上运作 的。而 HTTP 属于它内部的一个子集。 应用层：为不同的网络应用提供所需的服务。 传输层：为应用层实体提供端到端的通信/传输功能，确保数据包的按顺序传送及数据的完整性。 网络层：处理网络上流动的数据包，它所包含的协议涉及到数据包在整个网络上的逻辑传输。 链路层：监控数据交换，处理网络连接的硬件部分。 利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通 信。发送端从应用层往下走，接收端则往应用层往上走。 我们用 HTTP 举例来说明，首先作为发送端的客户端在应用层 （HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。 接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数 据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端 口号后转发给网络层。 在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链 路层。这样一来，发往网络的通信请求就准备齐全了。 接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用 层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。 与HTTP协议密切相关的协议/服务：IP，TCP，DNSIP协议负责数据包的传送，当然，这需要配合IP地址和MAC地址，IP间的通信依赖MAC地址，这就涉及到用以解析地址的ARP协议了。 TCP提供了可靠的字节流服务，对要发送的大块数据进行分割成小数据包以易于传输，并且该协议可确认数据包是否送达到目的方。 DNS服务负责解析域名 URI(统一资源标识符)和URL(统一资源定位符) URI：一个用于标识某一互联网资源名称的字符串。组成：主机名(含端口号)+相对路径+标识符 URL：对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。组成：协议+主机名(含端口号)+相对路径 区别：URI表示请求资源在互联网上存在的位置，URL在表示请求资源的位置同时还要说明如何访问到这个资源，URL是URI的一个子集。 简单的 HTTP 协议 HTTP 协议用于客户端和服务器端之间的通信 请求报文：是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。 响应报文：基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。稍后我们会对这些内容进行详细说明。 http无状态HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自 身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个 级别，协议对于发送过的请求或响应都不做持久化处理。 虽然是无状态协议，但为了实现期望的保持状态功能，于 是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管 理状态了。有关 Cookie 的详细内容稍后讲解 保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入 了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入 Cookie 信 息来控制客户端的状态。 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器 发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出 去。 服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一 个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前 的状态信息。 get 和post 的区别 Get 请求能缓存，Post 不能 Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。 Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术 URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的 Post 支持更多的编码类型且不对数据类型限制 各个区间的CODE的语义 100 - 199 接收的请求正在处理 200 - 299 操作成功 200 OK，表示从客户端发来的请求在服务器端被正确处理 204 No content，表示请求成功，但响应报文不含实体的主体部分 206 Partial Content，进行范围请求 300 - 399 操作需要重定向，需要用别的方式来获取数据 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL 302 found，临时性重定向，表示资源临时被分配了新的 URL 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况 307 temporary redirect，临时重定向，和302含义相同 400 - 499 发送的请求有问题 400 bad request，请求报文存在语法错误 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 403 forbidden，表示对请求资源的访问被服务器拒绝 404 not found，表示在服务器上没有找到请求的资源 500 - 599 服务器出现了问题 缓存缓存是代理服务器或客户端本地磁盘内保存的资源副本，利用缓存来减少对源服务器的访问以便于节省通信流量和通信时间，也可以达到更好的交互体验。 请求的资源如果已经被缓存则直接由缓存服务器返回给客户端，或者客户端直接从本地磁盘读取。缓存可以设置有效时间，当判断缓存过期后，客户端/缓存服务器可像源服务器重新请求新资源。 通用首部 指请求报文和响应报文都可以使用的字段 Cache-Control no-cache 指客户端不缓存过期资源 no-store 指不进行缓存 max-age 指缓存资源的缓存时间比指定的值小，那么客户端就接受缓存资源，且缓存服务器不对资源有效性进行再次确认 Connection 指控制不再转发给代理的首部字段（Hop-by-hop），管理持久连接 close 指服务器像明确断开连接 Keep-Alive 指保存持久连接，HTTP/1.1前默认连接是非持久性的，如需要保存持久连接，需要增加此字段 Upgrade 可以用来指定一个完全不同的通信协议，对于这个字段，服务器可以返回101状态码 请求首部字段 Accept 指用户代理能够处理的媒体类型及媒体类型的相对优先级 Accept-Encoding 指用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序 Authorization 指用来告知服务器，用户代理的认证信息 Host 当一个 IP 下存在多个域名时，帮助服务器知道要请求的具体主机 User-Agent 会讲创建请求的浏览器和用户代理名称等信息传达给服务器","link":"/2020/12/25/http/httpProtocol/"},{"title":"浏览器兼容总结","text":"前端浏览器兼容问题总结浏览器占比现状在各大浏览器厂商的发展过程中，他们其实对web的标准都有不同的实现，因为实现的标准的不同，所以会有兼容性的产生,早期IE是在浏览器的世界中，占据主导地位。所以它自身实现了很多不同于标准浏览器的东西，有css的，也有js的。 从IE8开始，IE浏览器渐渐遵循标准，到IE9后由于大家都一致认为标准很重要，可以说在兼容性上比较好了，但是在中国来说，由于xp的占有率问题，还是有很多xp系统ie7、8浏览器。 js兼容问题及解决1、js中 style、currentStyle和getComputedStyle的区别1.1 style：各大浏览器都兼容，能设置样式和获取样式，但是获取不了外部样式。 写法:ele.style.attr(这样为获取),ele.style.attr=”值”; 1.2. currentStyle：该属性只兼容IE，不兼容火狐和谷歌 ele.currentStyle.attr; 1.3. getComputedStyle:该属性是兼容火狐谷歌,不兼容IE8及以下 1window.getComputedStyle(ele,null).attr 通常使用 getComputedStyle 读取样式，通过 element.style 修改样式。 可选[pseudoElt]属性：指定一个要匹配的伪元素的字符串。不需要伪元素可以为null 配合该属性可以从伪元素拉取样式信息：比如,::after, ::before 123456789 getComputedStyle(oDiv, '::after').content;//兼容性写法： function getStyle(ele,attr){ if(ele.currentStyle){ return ele.currentStyle[attr] }else{ return getComputedStyle(obj,false)[attr] } } 2. 使用event对象 以主流浏览器 IE、谷歌、火狐为例： (1) IE 在IE中，event 是一个全局的变量，不存在作用域的问题。也就是说，谁触发了事件，那在事件绑定的函数中，你可以直接使用event的属性做任何操作，没有作用域的限制，也没有其他函数格式的要求。 ​ (2)Chrome 谷歌 谷歌做的也不错，使用也没有什么问题。在 Chrome 中，event并不是全局变量。他是在每个事件绑定的函数中都默认传入了一个形参event，注意函数的第一个形参就是event对象，而且我们不需要去写这个形参。如果你要在事件绑定的函数中使用 event，那直接 event . 点他的属性即可。系统默认将event对象以参数的形式传递到了函数中。这里不需要你做任何操作，只管用，简单粗暴。 IE 和 Chrome 虽然看起来用法一样，其实还是有本质区别的，只是浏览器封装的好而已。 ​ (3)Firebox 火狐 火狐就麻烦一点了。因为火狐中压根就没有event这个变量。不过解决方法也是很简单的： 1.2.1 用户不传参： 想要使用 event，我们就需要先使用如下语句 var e = arguments.callee.caller.arguments[0] || window.event arguments.callee.caller.arguments[0]: 函数体本身–&gt;函数体的调用函数体–&gt; function onclick() argument.callee.caller.arguments[0]即为传参集合的第一个形参event了. 1.2.2. 传参(event) 3.获取目标元素：兼容写法：event.srcElement ? event.srcElement : event.target; srcElement：ie 4. attachEvent和addEventListener4.1 attachEvent是IE有的方法，它不遵循W3C标准，而其他的主流浏览器如FF等遵循W3C标准的浏览器都使用addEventListener，所以实际开发中需分开处理。 4.2 多次绑定后执行的顺序是不一样的，attachEvent是后绑定先执行，addEventListener是先绑定先执行。 123456ele.attachEvent('onclick',function(){console.log('test...')})//ie11以及以上不支持 chrome不支持 ff不支持ele.addEventListener(&quot;click&quot;,function(){console.log('ceshi...')},false) //ie8及以下 不支持 5. 获取dom节点：parentElement 获取对象层次中的父元素。 parentNode 获取文档层次中的父结点。 在Dom文档结构中，HTML页面每一部分都是由节点组成的，节点的类型一共有3种，元素节点，文本节点，属性节点，从图中可以看出属性节点属于元素节点的分支，一般不常考虑。 两者在通常情况下都是一样的，因为包含元素的节点只有可能是元素节点，这里可能会有一个误区，有些人可能会想文本节点是否可以包含元素节点，来作为父节点，这里是不行的，文本节点只是文本本身，自身算一个节点，文本节点的父节点直接是元素节点。 二者唯一区别： 因为parentElement找的是元素，因此当找到根部document时候就是出现值为null的报错，而且parentNode找的是节点，当然就可以显示出来了！ 1bodyDom.parentNode.parentNode.parentNode.parentNode —#document 1bodyDom.parentElement.parentElement.parentElement.parentElement —null 6、日期函数处理IE8以下：new Date().getFullYear() === new Date().getYear() ：得到的是当前年份 2019 IE9、标准浏览器： new Date().getYear() 为 119 ：得到的是当前年份(2019)与1900年的差值 119 7、集合类对象问题问题说明：IE下，可以使用 () 或 [] 获取集合类对象；Firefox下，只能使用 [ ]获取集合类对象。 解决方法：统一使用 [] 获取集合类对象。 8、鼠标按键编码的兼容W3C标准下：0，1，2分别代表左，中，右三个键; 在ie11及以上 + 主流浏览器下 是符合W3C标准的，但是在ie10以及以下： 左中右分别为：1 4 2 123456789101112function but(evt){ var e = evt || window.event; if(evt){ return e.button; } else if (window.event){ switch(e.button){ case 1: return 0; case 4: return 1; case 2: return 2; } } } 9、8引出的其它问题：ie中的window.event全局对象和 事件访问对象(传递的参数evt) 的区别： 1.DOM标准描述了一个Event对象，提供了触发事件的元素信息，并允许在脚本中获取该元素。 \\2. ie中的事件处理: ie的全局event对象的属性不同于DOM标准的event对象，但提供的数据类似。 区别： DOM事件模型与IE事件模型之间的主要区别是事件信息的访问方式，以及获取引发事件的元 素的方式。 DOM是需要传送事件引用给处理函数，IE中直接通过全局的event访问； DOM中获取获取引发事件的元素对象是通过tarfet属性，而IE是通过srcElement属性。 css兼容性问题首先是&lt;!DOCTYPE&gt;的声明 位于位于HTML文档中的第一行，处于 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 1、reset最主要也是最常见的，就是浏览器对标签的默认支持不同，所以我们要统一，就要进行CSS reset 。但是不要为了reset而reset： 但是很多时候我们的CSS reset过于臃肿，主要有两个问题： 1.1 把很多浏览器对元素的默认属性有设置了一边，比如div的padding和margin为0啊什么的，这是没有必要的 1.2 把一些很不常用的元素的设置也写进了CSS reset。 2、上下margin重合问题相邻的两个div margin-left margin-right 不会重合，但相邻的margin-top margin-bottom会重合。 3、td高度的问题 table中td的宽度都不包含border的宽度，但是oprea和ff中td的高度包含了border的高度 。 解决： 设置line-height和height一样。在ie中如果td中的没有内容，那么border将不会显示。 4、兼容ie8 或者ie9 或任意ie版本浏览器​ \\4. 1.条件注释法(IE10+已经不支持条件注释) 大于 gt || 大于等于 gte || 小于 lt || 小于等于 lte(&lt;!--[if gte IE 8]&gt;&lt;![endif]--&gt;) 用ie浏览器独有的文档注释的方式。像这样： 12345&lt;!DOCTYPE html&gt; &lt;!--[if IE 8 ]&gt; &lt;html class=&quot;ie8&quot; lang=&quot;en&quot;&gt; &lt;![endif]--&gt; &lt;!--[if IE 9 ]&gt; &lt;html class=&quot;ie9&quot; lang=&quot;en&quot;&gt; &lt;![endif]--&gt; &lt;!--[if (gt IE 9)|!(IE)]&gt;&lt;!--&gt; &lt;html lang=&quot;en&quot;&gt; &lt;!--&lt;![endif]--&gt; 可以独立的维护处理兼容ie浏览器的样式表，又不会淹没在一大堆css hack标识中，只需要在独立对ie8应用样式规则的地方 ​ 4.2. 非IE(IE10+也能识别)，此处多加的&lt;–&gt;，在IE中被当作内部注释，而在非IE浏览器中会闭合之前的注释(&lt;![endif]–&gt;) 1&lt;!--[if !IE]&gt;&lt;--&gt; &lt;![endif]--&gt; 5、对于360双核浏览器可以添加以下头部meta信息可以使得网页用webkit内核渲染： IE=edge：保持使用最高级别模式显示内容； chrome=1：谷歌的外挂插件Google Chrome Frame（谷歌内嵌浏览器框架GCF），使用IE浏览网页时实际上是使用Chrome浏览器内核渲染，最低支持IE6，但前提是客户端已经安装GCF。 但实际上这个meta标识是ie浏览器所识别的，并不是公认的标准，所以有时你会发现360并不能总是以chrome内核渲染你的按现代标准开发的网页。 可以试试通过添加：&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; 这个meta标识是360自家实现的(详情：meta.html)，表示强制要求360浏览器用chrome的内核渲染网页。se.360.cn/v6/help/met… 6、ie8的css兼容 6.1 使用meta标签调节浏览器的渲染方式： IE8中有一个“兼容性视图”的概念，当初IE8发布时，相对于IE6/7已经做出了非常大的改进，但是很多老站点仅针对IE6/7进行了优化，使用IE8渲染反而会一团糟。IE8加入了“兼容性视图”功能，这样的话就可以在IE8中使用IE6或IE7的内核渲染页面。这个当然不是我们想要的，所以需要使用meta标签来强制IE8使用最新的内核渲染页面，代码如下： IE=edge表示强制使用IE最新内核， chrome=1表示如果安装了针对IE6/7/8等版本的浏览器插件Google Chrome Frame（可以让用户的浏览器外观依然是IE的菜单和界面，但用户在浏览网页时，实际上使用的是Chrome浏览器内核），那么就用Chrome内核来渲染。 对比360：&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; 6.2 ie8中的一些css 不支持 ​ 6.2.1 ie8支持:first-child,但不支持:last-child。因为前者是css2.1标准，后者是css3标准。推荐的做法不是使用last-child，而是给最后一个元素设置一个.last的class，然后对此进行样式设置，这样就全部兼容了。 ​ 6.2.2 html5shiv.js IE8不支持HTML5的新标签，如&lt;header&gt;、&lt;nav&gt;等标签在IE8无法渲染。html5shiv.js可帮助IE6-8浏览器兼容HTML5语义化标签。 使用方法：在页面中引用html5shiv.js文件。必须添加在页面的元素内，因为IE浏览器必须在元素解析前知道这个元素，所以这个js文件不能在页面底部引用。 ​ 6.2.3. Respond.js IE8不支持CSS媒体查询，对响应式设计大大不利。Respond.js可帮助IE6-8兼容“min/max-width”媒体查询条件。 使用方法：在页面中所有css文件的引用位置之后引用Respond.js。而且Respond.js的引用得越早，用户看到页面闪烁的机会越小。 ​ 6.2.4. CSS3字体单位“rem”兼容方案：rem.js CSS3引入了新的字体大小单位rem，与em的“相对于其父元素来设置字体大小”的功能不同，rem是相对于根元素的字体大小比率单位，成了目前主流的单位之一。IE9+开始支持，IE8就只能通过引入js库来支持了。 使用方法：在页面中引用rem.js文件。需要引用在页脚，也就是末尾，在所有css文件引用和DOM元素之后。 ​ 6.2.5. 一些其它不支持的属性： border-radius 圆角 box-shadow 盒子阴影 CSS3 Background 背景渐变 7、placeholder不支持ie10-以下的版本(可以通过使用一个span标签来模拟提示。) 关于css优化问题：1、不要使用*{} 类似的通配符这种方法虽然写起来简单，但是渲染起来，浏览器引擎要遍历所有的标签，很影响效率。为了对浏览器友好，可以把自己经常用的标签进行重置操作。 2、尽量少用绝对定位和浮动等高性能属性虽然绝对定位可以很简洁的实现很棒的效果，但是由于浏览器的渲染机制，网页中如果用过多的绝对定位，会让网页加载速度变得很慢。 3、利用CSS继承减少代码量 我们知道有一部分CSS代码是可以继承的，如果父元素已经设置了该样式，子元素就不需要去设置该样式，这个也是提高性能的行之有效的方法。 常见的可以继承的属性比如： color，font-size，font-family，text-align，line-height等等 不可继承的比如： position，display，float，display，background。width等等 4、CSS Sprites减少http请求小图标 通过一张雪碧图 控制background-position来请求 5、合写css：font background padding margin 6、不要用标签或 class 来限制 ID 规则很多人会写出#test.info或者div#test这样的选择器，这个只能说是画蛇添足，id已经可以唯一而且最快的定位一个元素了 7、避免通配选择器CSS选择器对性能的影响源于浏览器匹配选择器和文档元素时所消耗的时间，所以优化选择器的原则是应尽量避免需要消耗更多匹配时间的选择器。而在这之前我们需要了解CSS选择器匹配的机制，如例子的子选择器规则： #header a {font-weight:blod;} 我们中的大多数人都是从左到右的阅读习惯，可能也会习惯性的设定浏览器也是从左到右的方式进行匹配规则，因为会推测这条规则的开销并不高。我们这样假象浏览器会像这样的方式工作：找到唯一的id为header为的元素，然后把这个样式规则应用到直系子元素中的a元素上。我们知道文档中只有一个id为header的元素，并且它只有几个a类型的子节点，所以这个CSS选择器应该相当高效。 事实上，却恰好相反，CSS选择器是从右到左进行规则匹配。了解这个机制后，例子中看似高效的选择器在实际中的匹配开销是很高的，浏览器必须遍历页面中所有的a元素并且确定其父元素的id是否为header。 如果把例子的子选择器改为后代选择器则会开销更多，在遍历页面中所有a元素后还需向其上级遍历直到根节点。 #header a {font-weight:blod;} 理解了CSS选择器从右到左匹配的机制后，可以理解选择器中最右边的规则往往决定了浏览器继续左移匹配的工作量，我们把最右边选择规则称之为关键选择器。 通配选择器使用 * 符合表示，可匹配文档中的每一个元素。如下例规则将所有元素的字体大小设置为20px： * { font-size:20px;} 通配选择器作用于所有的元素，如规则最右边为通配符： .selected * {color: red;} 浏览器匹配文档中所有的元素后分别向上逐级匹配class为selected的元素，直到文档的根节点，因此其匹配开销是非常大的，通常比开销最小的ID选择器高出1~3个数量级，所以应避免使用关键选择器是通配选择器的规则。 8、避免单规则的属性选择器属性选择器根据元素的属性是否存在或其属性值进行匹配，如下例规则会把herf属性值等于”#index”的链接元素设置为红色： .selected [href=”#index”] {color: red;} 但其匹配开销是非常大的，浏览器先匹配所有的元素，检查其是否有href属性并且herf属性值等于”#index”， 然后分别向上逐级匹配class为selected的元素，直到文档的根节点。所以应避免使用关键选择器是单规则属性选择器的规则。 9、避免类正则的属性选择器CSS3添加了复杂的属性选择器，可以通过类正则表达式的方式对元素的属性值进行匹配。当然这些类型的选择器定是会影响性能的，正则表达式匹配会比基于类别的匹配会慢很多。大部分情况下我们应尽量避免使用 *=， |=， ^=， $=， 和 ~=语法的属性选择器。 10、移除无匹配的样式：移除无匹配的样式，有两个好处： 第一，删除无用的样式后可以缩减样式文件的体积，加快资源下载速度； 第二，对于浏览器而言，所有的样式规则的都会被解析后索引起来，即使是当前页面无匹配的规则。移除无匹配的规则，减少索引项，加快浏览器查找速度；","link":"/2019/04/12/http/BrowserCompatible/"},{"title":"垂直水平居中","text":"[垂直水平居中] 一、水平居中1.1 行内元素1234.parent { text-align: center;} 1.2 块级元素1.2.1 块级元素一般居中方法1234.son { margin: 0 auto;} 1.2.2 子元素含 float123456789.parent{ width:fit-content; margin:0 auto;}.son { float: left;} 1.2.3 Flex 弹性盒子1） flex 2012版 12345.parent { display: flex; justify-content: center;} 2）flex 2009版 123456.parent { display: box; box-orient: horizontal; box-pack: center;} 1.2.4 绝对定位1）transform 123456.son { position: absolute; left: 50%; transform: translate(-50%, 0);} 2）left: 50% 1234567.son { position: absolute; width: 宽度; left: 50%; margin-left: -0.5*宽度} 3）left/right: 0 12345678.son { position: absolute; width: 宽度; left: 0; right: 0; margin: 0 auto;} 小结以上是 CSS 水平居中的 8 种方法。 二、垂直居中2.1 行内元素12345678.parent { height: 高度;}.son { line-height: 高度;} 注：① 子元素 line-height 值为父元素 height 值。② 单行文本。 2.2 块级元素2.2.1 行内块级元素123456789.parent::after, .son{ display:inline-block; vertical-align:middle;}.parent::after{ content:''; height:100%;} 适应 IE7。 2.2.2 table12345678.parent { display: table;}.son { display: table-cell; vertical-align: middle;} 优点 元素高度可以动态改变, 不需再CSS中定义, 如果父元素没有足够空间时, 该元素内容也不会被截断。 缺点 IE6~7, 甚至IE8 beta中无效。 2.2.3 Flex 弹性盒子1）flex 2012版 12345.parent { display: flex; align-items: center;} 优点 内容块的宽高任意, 优雅的溢出。 可用于更复杂高级的布局技术中。 缺点 IE8/IE9不支持。 需要浏览器厂商前缀。 渲染上可能会有一些问题。 2）flex 2009版 123456.parent { display: box; box-orien: vertical; box-pack: center;} 优点 实现简单, 扩展性强。 缺点 兼容性差, 不支持IE。 2.2.4 绝对定位1）transform 123456.son { position: absolute; top: 50%; transform: translate( 0, -50%);} 优点 代码少。 缺点 IE8不支持, 属性需要追加浏览器厂商前缀, 可能干扰其他 transform 效果, 某些情形下会出现文本或元素边界渲染模糊的现象。 2）top: 50% 1234567.son { position: absolute; top: 50%; height: 高度; margin-top: -0.5高度;} 优点 适用于所有浏览器。 缺点 父元素空间不够时, 子元素可能不可见(当浏览器窗口缩小时,滚动条不出现时).如果子元素设置了overflow:auto, 则高度不够时, 会出现滚动条。 3）top/bottom: 0; 1234567.son { position: absolute; top: 0; bottom: 0; margin: auto 0;} 优点 简单。 缺点 没有足够空间时, 子元素会被截断, 但不会有滚动条。 小结以上是 CSS 垂直居中的 8 种方法及其优缺点。 三、小结 以上总结了水平居中、垂直居中各8个共16种方法。 其中， flex 绝对定位 同时适用于水平居中和垂直居中。 希望帮助到了你。 欢迎讨论。 ٩(๑❛ᴗ❛๑)۶ 感谢@ape-casear，@斗鹰 的指正！ 也欢迎大家一起将 CSS 的居中总结得更好！ 参考文献 [1] louis. [16种方法实现水平居中垂直居中OL]，2017-04-20. [2] 慢思考快行动. [css设置垂直居中OL], 2017-09-03. 作者：前端星球链接：https://juejin.cn/post/6844903799446831117来源：掘金","link":"/2021/05/19/css/center/"},{"title":"获取手机权限","text":"微信小程序获取手机权限taro获取微信小程序权限 获取手机号获取微信用户绑定的手机号，需先调用wx.login接口。 因为需要用户主动触发才能发起获取手机号接口，所以该功能不由 API 来调用，需用 button 组件的点击来触发。 注意：目前该接口针对非个人开发者，且完成了认证的小程序开放（不包含海外主体）。需谨慎使用，若用户举报较多或被发现在不必要场景下使用，微信有权永久回收该小程序的该接口权限。 使用方法需要将 button 组件 open-type 的值设置为 getPhoneNumber，当用户点击并同意之后，可以通过 bindgetphonenumber 事件回调获取到微信服务器返回的加密数据，然后在第三方服务端结合 session_key 以及 app_id 进行解密获取手机号。 示例代码12345678&lt;button open-type=&quot;getPhoneNumber&quot; bindgetphonenumber=&quot;getPhoneNumber&quot;&gt;&lt;/button&gt;Page({ getPhoneNumber (e) { console.log(e.detail.errMsg) console.log(e.detail.iv) console.log(e.detail.encryptedData) }}) Taro中用法12345678910import { AtButton } from 'taro-ui'getPhoneNumber: function (e) { console.log(`是否成功调用${e.detail.errMsg}`); console.log(`加密算法的初始向量:${e.detail.iv}`); console.log(`包括敏感数据在内的完整用户信息的加密数据:${e.detail.encryptedData}`);} &lt;AtButton type=&quot;primary&quot; openType=&quot;getPhoneNumber&quot; onGetPhoneNumber=&quot;getPhoneNumber&quot;&gt;微信绑定手机号登录&lt;/AtButton&gt;","link":"/2021/02/23/Applets/Applets/"},{"title":"微信支付流程","text":"微信支付的一般流程 前端代码123456789wx.requestPayment({ timeStamp: '', nonceStr: '', package: '', signType: 'MD5', paySign: '', success(res) {}, fail(res) {},}); 相关文档 微信支付使用云开发来实现相应的支付功能后，开发者无需关心证书、签名、微信支付服务器端文档，使用简单，代码较少，只需要调用相应的函数即可。此外，因为云开发基于微信私有协议实现，官方通过服务商提供支付接口对接支持，不依赖第三方模块，免去泄漏证书、支付情况等其他敏感信息的风险。同时，云开发还支持云函数接收微信支付进行支付和退款的回调，安全高效。 安全：微信私有协议，无证书等信息泄露风险 免签名：所有接口免签名 &amp; 直接获取小程序 wx.requestPayment 所需参数 接收回调：云函数支持接收异步支付结果回调 资质需要是已经开通了微信支付，且已绑定了商户号的小程序。 开通在云控制台 -&gt; 设置 -&gt; 全局设置中开通。 权限添加商户号后需要分别进行帐号绑定、jsapi 和 api 退款权限授权。请注意： 1）帐号绑定：商户号的超级管理员需要在微信支付提供的【微信支付商家助手】小程序上确认授权。 2）jsapi 和 api 退款权限，需要前往微信支付商户平台我的授权产品中进行确认授权。说明 完成授权后即可调用微信支付相关接口能力。 接口 wx-server-sdk &gt;= 2.0.2 云开发提供了微信支付相关接口和服务端回调，包括统一下单、查询订单、关闭订单、申请退款、查询退款、下载对账单，具体文档见 API 文档。 下单关键开发流程： 小程序调用云函数，在云函数中调用统一下单接口，参数中带上接收异步支付结果的云函数名和其所在云环境 ID 统一下单接口返回的成功结果对象中有 payment 字段，该字段即是小程序端发起支付的接口（wx.requestPayment）所需的所有信息 小程序端拿到云函数结果，调用 wx.requestPayemnt 发起支付 支付完成后，在统一下单接口中配置的云函数将收到支付结果通知 流程图可见顶部。 注意：收到支付结果回调的云函数必须返回一个 { &quot;errcode&quot;: 0 } 的对象，否则会认为回调处理失败，在接下来两天内会持续收到回调，直到返回成功为止。具体返回值协议见统一下单接口文档。 接口与微信支付原接口（文档）的不同点在于： 私有安全链路，免证书管理，免签名计算 商户号填入 sub_mch_id 字段，小程序/公众号 appid 填入 sub_appid 字段 免填写以下字段：mch_id、appid、sign、sign_type 接口入参和返回值都为 JSON 而不是 XML","link":"/2021/02/23/Applets/WechatPayment/"},{"title":"盒子模型","text":"[css盒模型不同浏览器下解释不同 解决办法] 标准 w3c 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。 content = height + width ie 盒子模型的范围也包括 margin、border、padding、content，和标准 w3c 盒子模型不同的是：ie 盒子模型的 content 部分包含了 border 和 pading content = height + width + border + padding","link":"/2021/06/07/html/box/"},{"title":"mvvm实现","text":"vue 中 mvvm 模式实现 vue 框架是典型的 MVVM（Model-View-ViewModel）模式的前端框架，它最大的特点就是，View 和 ViewModel 之间做了双向数据绑定，当 Model 发生变化的时候，绑定 Model 数据的 View 会随之发生变化，当 View 发生变化时，对应的 Model 也会随之变化。我们现在就来实现一个小巧简单的 mvvm 框架吧~ 初步的文件结构设计如下： index.html页面框架，创建 MVVM 实例，挂载页面元素和数据。分别引入 watcher.js、observer.js、compile.js、mvvm.js 文件，后面会介绍具体的作用。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;My MVVM&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 双向数据绑定 --&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; /&gt; {{msg}} &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;./watcher.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./observer.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./compile.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./mvvm.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // mvvm如何实现？ // vue中实现双向绑定 1.模板编译 2.数据劫持 3.Watcher let vm = new MVVM({ el: '#app', //el:document.getElementById('app') data: { msg: 'hello', }, }); &lt;/script&gt;&lt;/html&gt; mvvm.jsmvvm.js 定义了 MVVM 类，首先把可用的属性全部挂载到实例上。如果有要编译的模板就开始编译，涉及到数据劫持、数据代理、模板编译三个阶段。其中，数据劫持是把对象的所有属性改为 get、set；代理数据阶段让 this.$data下的数据都代理到this（MVVM）中，能让用户方便地从this.xx进行取值，而不是需要从this.$data.xx 进行取值；模板编译阶段是使用数据和元素进行编译，返回含有完整数据内容的页面。 12345678910111213141516171819202122232425262728class MVVM { constructor(options) { // 先把可用的东西挂载到实例上 this.$el = options.el; this.$data = options.data; // 如果有要编译的模板就开始编译 if (this.$el) { new Observer(this.$data); // 数据劫持，把对象的所有属性改为get、set this.proxyData(this.$data); new Compile(this.$el, this); // 用数据和元素进行编译 } } // 代理数据，因为用户可能要通过this.msg取值，而不是this.$data.msg取值 proxyData(data) { Object.keys(data).forEach((key) =&gt; { Object.defineProperty(this, key, { get() { return data[key]; }, set(newVal) { data[key] = newVal; }, }); }); }} compile.jscompile.js 是将数据和页面元素组合起来，返回含有对应数据内容的完整页面，用于浏览器渲染。如果存在模板，则需要进行以下几步： 把真实的 dom 移入到内存，放到 fragment（node2Fragment(el)函数）进行编译（compile(fragment)函数)，提取元素节点和文本节点，针对元素节点和文本节点实行不同的编译方式： 如果是元素节点，则需要先进行元素节点编译（compileElement(node)函数），再进行递归如果是文本节点，则直接编译文本节点（compileText(node)函数），提取{{}}中的内容进行数据填充 把编译好的 element 放回页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146class Compile { constructor(el, vm) { // 判断el是否是元素节点，如果是html的元素节点则直接返回，否则使用document.querySelector找到el节点并返回 this.el = this.isElementNode(el) ? el : document.querySelector(el) this.vm = vm if (this.el) { // 1. 先把真实的dom移入到内存，放到fragment let fragment = this.node2Fragment(this.el) // 2. 编译——提取想要的元素节点和文本节点 v-model {{}} this.compile(fragment) // 3. 把编译好的element放回页面 this.el.appendChild(fragment) } } // 辅助方法 isElementNode(node) { return node.nodeType === 1 } isDirective(name) { return name.includes('v-') } // 核心方法 // 将el元素内容全部放入内存 node2Fragment(el) { let fragment = document.createDocumentFragment() //文档碎片 let firstChild while (firstChild = el.firstChild) { fragment.appendChild(firstChild) } return fragment } // 编译 compile(fragment) { // childNodes拿不到嵌套子节点，需要使用递归 let childNodes = fragment.childNodes Array.from(childNodes).forEach(node =&gt; { // 元素节点 if (this.isElementNode(node)) { this.compileElement(node) this.compile(node) // 需要深入检查， 使用递归 } else { // 文本节点 this.compileText(node) } }) } // 编译元素 v-model、v-text等 compileElement(node) { let attrs = node.attributes Array.from(attrs).forEach(attr =&gt; { // 判断属性名字是否包含v- let attrName = attr.name if (this.isDirective(attrName)) { let expr = attr.value //expr是指令的值 // node this.vm.$data expr //取到v-后面的名称，如v-model的model，v-text的text等等 // let type = attrName.slice(2) let [, type] = attrName.split('-') Util[type](node, this.vm, expr) } }) } // 编译文本，{{}} compileText(node) { let expr = node.textContent let reg = /\\{\\{([^}]+)\\}\\}/g //匹配{{}} if (reg.test(expr)) { const type = 'text' Util[type](node, this.vm, expr) } }}Util = { // 获取实例上对应的数据，如msg.a.b=&gt;'hello' // msg.a.b=&gt;this.$data.msg=&gt;this.$data.msg.a=&gt;this.$data.msg.a.b getVal(vm, expr) { expr = expr.split('.') return expr.reduce((prev, next) =&gt; { return prev[next] }, vm.$data) }, // 获取编译文本后的结果，如{{msg}}=&gt;'hello' getTextVal(vm, expr) { return expr.replace(/\\{\\{([^}]+)\\}\\}/g, (...arguments) =&gt; { // arguments[1]是正则匹配括号内容，如{{msg}}的msg return this.getVal(vm, arguments[1]) }) }, // 赋值 // 例如给msg.a.b赋新值，则取到最后再赋value值 setVal(vm, expr, value) { expr = expr.split('.') return expr.reduce((prev, next, curIndex) =&gt; { if (curIndex === expr.length - 1) { return prev[next] = value } }, vm.$data) }, // 文本处理 text(node, vm, expr) { let updateFn = this.update['textUpdater'] // 拿到{{a}}{{b}}的a、b expr.replace(/\\{\\{([^}]+)\\}\\}/g, (...arguments) =&gt; { new Watcher(vm, arguments[1], newVal =&gt; { // 如果数据变化了， 文本节点需要重新获取依赖的数据来更新文本节点 updateFn &amp;&amp; updateFn(node, this.getTextVal(vm, expr)) }) }) let value = this.getTextVal(vm, expr) updateFn &amp;&amp; updateFn(node, value) }, // 输入框处理 model(node, vm, expr) { let updateFn = this.update['modelUpdater'] // 这里应该加一个监控，数据变化时，应该调用watcher的callback，将新值传递过来 new Watcher(vm, expr, newVal =&gt; { updateFn &amp;&amp; updateFn(node, this.getVal(vm, expr)) }) updateFn &amp;&amp; updateFn(node, this.getVal(vm, expr)) node.addEventListener('input', e =&gt; { let newVal = e.target.value this.setVal(vm, expr, newVal) }) }, update: { // 文本更新 textUpdater(node, value) { node.textContent = value }, // 输入框更新 modelUpdater(node, value) { node.value = value } }} observer.jsobserver.js 是将页面中绑定的数据全部变为响应式，即将 data 数据原有的属性改为 get 和 set 的形式，使用 defineReactive 函数进行数据劫持（这里要注意，如果劫持的是对象，还要对对象内的属性继续劫持）。在 defineReactive 函数中，我们针对每个数据都新建了 Dep 的实例，Dep 是典型的用来发布订阅的类（见下文的 watcher.js），可以用来添加订阅者信息和触发数据更新。在这个函数中，使用 Object.defineProperty 进行了数据劫持，在数据发生变化时（对应 set），通知所有该数据的订阅者数据变化了，会让对应的订阅者进行更新操作。 1234567891011121314151617181920212223242526272829303132333435363738class Observer { constructor(data) { this.observe(data); } // 将data数据原有的属性改为get和set的形式 observe(data) { if (!data || typeof data !== 'object') return; Object.keys(data).forEach((key) =&gt; { // 开始劫持 this.defineReactive(data, key, data[key]); // 如果劫持的是对象，还要对对象内的属性继续劫持 this.observe(data[key]); }); } // 定义响应式 defineReactive(data, key, value) { let _this = this; let dep = new Dep(); //每个变化的数据都会对应一个数组，这个数组是存放所有更新的操作 Object.defineProperty(data, key, { enumerable: true, configurable: true, get() { Dep.target &amp;&amp; dep.addSub(Dep.target); return value; }, set(newValue) { if (newValue !== value) { // 设置新值时，如果是对象仍然需要劫持 _this.observe(newValue); value = newValue; dep.notify(); //通知所有订阅者数据变化了 } }, }); }} watcher.jswatcher.js 定义了观察者类，用来给需要变化的 dom 元素增加观察者。使用新值和旧值进行比对，如果发生变化，执行对应的方法（如更新页面）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Watcher { constructor(vm, expr, cb) { this.vm = vm; this.expr = expr; this.cb = cb; this.value = this.get(); } // 获取实例上对应的数据，如msg.a.b=&gt;'hello' getVal(vm, expr) { expr = expr.split('.'); return expr.reduce((prev, next) =&gt; { return prev[next]; }, vm.$data); } get() { Dep.target = this; let value = this.getVal(this.vm, this.expr); Dep.target = null; return value; } // 对外暴露的方法 update() { let newVal = this.getVal(this.vm, this.expr); let oldVal = this.value; if (newVal !== oldVal) { this.cb(newVal); } }}// 发布订阅class Dep { constructor() { // 订阅数组 this.subs = []; } // 添加订阅 addSub(watcher) { this.subs.push(watcher); } notify() { this.subs.forEach((watcher) =&gt; { watcher.update(); }); }}","link":"/2021/06/18/vue/mvvm/"},{"title":"redux解析","text":"Redux/react-redux/redux 中间件设计实现剖析其实笔者本来没有 redux 相关的行文计划，不过公司内部最近有同事作了 redux 相关的技术分享,而笔者承担了一部分文章评审的任务，在评审的过程中，笔者花了相当的精力时间来查阅资料和实现代码，前后积攒了几千字的笔记，对 redux 也有了一份心得见解，于是顺手写就本文，希望能给大家带来些一些启发和思考 Thanks♪(･ω·)ﾉ经过本文的学习，读者应该能够学习理解： redux的设计思路及实现原理 react-redux的设计思路及实现原理 redux中间件的设计思路及实现原理 一. redux 的实现在一切开始之前，我们首先要回答一个问题：为什么我们需要 redux，redux 为我们解决了什么问题？只有回答了这个问题，我们才能把握 redux 的设计思路。 React 作为一个组件化开发框架，组件之间存在大量通信，有时这些通信跨越多个组件，或者多个组件之间共享一套数据，简单的父子组件间传值不能满足我们的需求，自然而然地，我们需要有一个地方存取和操作这些公共状态。而 redux 就为我们提供了一种管理公共状态的方案，我们后续的设计实现也将围绕这个需求来展开。 我们思考一下如何管理公共状态：既然是公共状态，那么就直接把公共状态提取出来好了。我们创建一个 store.js 文件，然后直接在里边存放公共的 state，其他组件只要引入这个 store 就可以存取共用状态了。 123const state = { count: 0} 我们在 store 里存放一个公共状态 count，组件在 import 了 store 后就可以操作这个 count。这是最直接的 store，当然我们的 store 肯定不能这么设计，原因主要是两点： 1. 容易误操作 比如说，有人一个不小心把 store 赋值了{}，清空了 store，或者误修改了其他组件的数据，那显然不太安全，出错了也很难排查，因此我们需要有条件地操作 store，防止使用者直接修改 store 的数据。 2. 可读性很差 JS 是一门极其依赖语义化的语言，试想如果在代码中不经注释直接修改了公用的 state，以后其他人维护代码得多懵逼，为了搞清楚修改 state 的含义还得根据上下文推断，所以我们最好是给每个操作起个名字。 项目交接 我们重新思考一下如何设计这个公共状态管理器，根据我们上面的分析，我们希望公共状态既能够被全局访问到，又是私有的不能被直接修改，思考一下，闭包是不是就就正好符合这两条要求，因此我们会把公共状态设计成闭包（对闭包理解有困难的同学也可以跳过闭包，这并不影响后续理解） 既然我们要存取状态，那么肯定要有getter和setter，此外当状态发生改变时，我们得进行广播，通知组件状态发生了变更。这不就和 redux 的三个 API：getState、dispatch、subscribe对应上了吗。我们用几句代码勾勒出 store 的大致形状： 1234567export const createStore = () =&gt; { let currentState = {} // 公共状态 function getState() {} // getter function dispatch() {} // setter function subscribe() {} // 发布订阅 return { getState, dispatch, subscribe }} 1. getState 实现getState()的实现非常简单，返回当前状态即可： 123456789export const createStore = () =&gt; { let currentState = {} // 公共状态 function getState() { // getter return currentState } function dispatch() {} // setter function subscribe() {} // 发布订阅 return { getState, dispatch, subscribe }} 2.dispatch 实现但是dispatch()的实现我们得思考一下，经过上面的分析，我们的目标是有条件地、具名地修改 store 的数据，那么我们要如何实现这两点呢？我们已经知道，在使用 dispatch 的时候，我们会给 dispatch()传入一个 action 对象，这个对象包括我们要修改的 state 以及这个操作的名字(actionType)，根据 type 的不同，store 会修改对应的 state。我们这里也沿用这种设计： 1234567891011121314151617export const createStore = () =&gt; { let currentState = {} function getState() { return currentState } function dispatch(action) { switch (action.type) { case 'plus': currentState = { ...state, count: currentState.count + 1 } } } function subscribe() {} return { getState, subscribe, dispatch }} 我们把对 actionType 的判断写在了 dispatch 中，这样显得很臃肿，也很笨拙，于是我们想到把这部分修改 state 的规则抽离出来放到外面，这就是我们熟悉的**reducer。**我们修改一下代码，让 reducer 从外部传入： 123456789101112import { reducer } from './reducer'export const createStore = (reducer) =&gt; { let currentState = {} function getState() { return currentState } function dispatch(action) { currentState = reducer(currentState, action) } function subscribe() {} return { getState, dispatch, subscribe }} 然后我们创建一个 reducer.js 文件，写我们的 reducer 1234567891011121314151617181920//reducer.jsconst initialState = { count: 0}export function reducer(state = initialState, action) { switch(action.type) { case 'plus': return { ...state, count: state.count + 1 } case 'subtract': return { ...state, count: state.count - 1 } default: return initialState }} 代码写到这里，我们可以验证一下getState和dispatch： 1234567891011121314151617//store.jsimport { reducer } from './reducer'export const createStore = (reducer) =&gt; { let currentState = {} function getState() { return currentState } function dispatch(action) { currentState = reducer(currentState, action) } function subscribe() {} return { getState, subscribe, dispatch }}const store = createStore(reducer) //创建storestore.dispatch({ type: 'plus' }) //执行加法操作,给count加1console.log(store.getState()) //获取state 运行代码，我们会发现，打印得到的 state 是：{ count: NaN }，这是由于 store 里初始数据为空，state.count + 1 实际上是 underfind+1，输出了 NaN，所以我们得先进行 store 数据初始化，我们在执行 dispatch({ type: ‘plus’ })之前先进行一次初始化的 dispatch，这个 dispatch 的 actionType 可以随便填，只要不和已有的 type 重复，让 reducer 里的 switch 能走到 default 去初始化 store 就行了： 1234567891011121314151617import { reducer } from './reducer'export const createStore = (reducer) =&gt; { let currentState = {} function getState() { return currentState } function dispatch(action) { currentState = reducer(currentState, action) } function subscribe() {} dispatch({ type: '@@REDUX_INIT' }) //初始化store数据 return { getState, subscribe, dispatch }}const store = createStore(reducer) //创建storestore.dispatch({ type: 'plus' }) //执行加法操作,给count加1console.log(store.getState()) //获取state 运行代码，我们就能打印到的正确的 state：{ count: 1 } 3.subscribe 实现尽管我们已经能够存取公用 state，但 store 的变化并不会直接引起视图的更新，我们需要监听 store 的变化，这里我们应用一个设计模式——观察者模式，观察者模式被广泛运用于监听事件实现（有些地方写的是发布订阅模式，但我个人认为这里称为观察者模式更准确，有关观察者和发布订阅的区别，讨论有很多，读者可以搜一下） 所谓观察者模式，概念也很简单：观察者监听被观察者的变化，被观察者发生改变时，通知所有的观察者。那么我们如何实现这种监听-通知的功能呢，为了照顾还不熟悉观察者模式实现的同学，我们先跳出 redux，写一段简单的观察者模式实现代码： 123456789101112131415161718192021222324252627282930313233//观察者class Observer { constructor (fn) { this.update = fn }}//被观察者class Subject { constructor() { this.observers = [] //观察者队列 } addObserver(observer) { this.observers.push(observer) //往观察者队列添加观察者 } notify() { //通知所有观察者,实际上是把观察者的update()都执行了一遍 this.observers.forEach(observer =&gt; { observer.update() //依次取出观察者,并执行观察者的update方法 }) }} var subject = new Subject() //被观察者 const update = () =&gt; { console.log('被观察者发出通知') } //收到广播时要执行的方法 var ob1 = new Observer(update) //观察者1 var ob2 = new Observer(update) //观察者2 subject.addObserver(ob1) //观察者1订阅subject的通知subject.addObserver(ob2) //观察者2订阅subject的通知subject.notify() //发出广播,执行所有观察者的update方法 解释一下上面的代码：观察者对象有一个update方法(收到通知后要执行的方法)，我们想要在被观察者发出通知后，执行该方法；被观察者拥有addObserver和notify方法，addObserver 用于收集观察者，其实就是将观察者们的 update 方法加入一个队列，而当 notify 被执行的时候，就从队列中取出所有观察者的 update 方法并执行，这样就实现了通知的功能。我们 redux 的监听-通知功能也将按照这种实现思路来实现 subscribe： 有了上面观察者模式的例子，subscribe 的实现应该很好理解，这里把 dispatch 和 notify 做了合并，我们每次 dispatch，都进行广播，通知组件 store 的状态发生了变更。 12345678910111213141516171819import { reducer } from './reducer'export const createStore = (reducer) =&gt; { let currentState = {} let observers = [] //观察者队列 function getState() { return currentState } function dispatch(action) { currentState = reducer(currentState, action) observers.forEach(fn =&gt; fn()) } function subscribe(fn) { observers.push(fn) } dispatch({ type: '@@REDUX_INIT' }) //初始化store数据 return { getState, subscribe, dispatch }} 我们来试一下这个 subscribe（这里就不创建组件再引入 store 再 subscribe 了，直接在 store.js 中模拟一下两个组件使用 subscribe 订阅 store 变化）： 12345678910111213141516171819202122232425import { reducer } from './reducer'export const createStore = (reducer) =&gt; { let currentState = {} let observers = [] //观察者队列 function getState() { return currentState } function dispatch(action) { currentState = reducer(currentState, action) observers.forEach(fn =&gt; fn()) } function subscribe(fn) { observers.push(fn) } dispatch({ type: '@@REDUX_INIT' }) //初始化store数据 return { getState, subscribe, dispatch }} const store = createStore(reducer) //创建 storestore.subscribe(() =&gt; { console.log('组件1收到store的通知') }) store.subscribe(() =&gt; { console.log('组件2收到store的通知') }) store.dispatch({ type: 'plus' }) //执行dispatch，触发store的通知 控制台成功输出 store.subscribe()传入的回调的执行结果： 到这里，一个简单的 redux 就已经完成，在 redux 真正的源码中还加入了入参校验等细节，但总体思路和上面的基本相同。 我们已经可以在组件里引入 store 进行状态的存取以及订阅 store 变化，数一下，正好十行代码(｀ ∀´)Ψ。但是我们看一眼右边的进度条，就会发现事情并不简单，篇幅到这里才过了三分之一。尽管说我们已经实现了 redux，但 coder 们并不满足于此，我们在使用 store 时，需要在每个组件中引入 store，然后 getState，然后 dispatch，还有 subscribe，代码比较冗余，我们需要合并一些重复操作，而其中一种简化合并的方案，就是我们熟悉的react-redux。 二. react-redux 的实现上文我们说到，一个组件如果想从 store 存取公用状态，需要进行四步操作：import 引入 store、getState 获取状态、dispatch 修改状态、subscribe 订阅更新，代码相对冗余，我们想要合并一些重复的操作，而 react-redux 就提供了一种合并操作的方案：react-redux 提供Provider和connect两个 API，Provider 将 store 放进 this.context 里，省去了 import 这一步，connect 将 getState、dispatch 合并进了 this.props，并自动订阅更新，简化了另外三步，下面我们来看一下如何实现这两个 API： 1. Provider 实现我们先从比较简单的Provider开始实现，Provider 是一个组件，接收 store 并放进全局的context对象，至于为什么要放进 context，后面我们实现 connect 的时候就会明白。下面我们创建 Provider 组件，并把 store 放进 context 里，使用 context 这个 API 时有一些固定写法(有关 context 的用法可以查看这篇文章) 123456789101112131415161718import React from 'react'import PropTypes from 'prop-types'export class Provider extends React.Component { // 需要声明静态属性childContextTypes来指定context对象的属性,是context的固定写法 static childContextTypes = { store: PropTypes.object } // 实现getChildContext方法,返回context对象,也是固定写法 getChildContext() { return { store: this.store } } constructor(props, context) { super(props, context) this.store = props.store } // 渲染被Provider包裹的组件 render() { return this.props.children }} 完成 Provider 后，我们就能在组件中通过 this.context.store 这样的形式取到 store，不需要再单独 import store。 2. connect 实现下面我们来思考一下如何实现connect，我们先回顾一下 connect 的使用方法： 1connect(mapStateToProps, mapDispatchToProps)(App) 我们已经知道，connect 接收 mapStateToProps、mapDispatchToProps 两个方法，然后返回一个高阶函数，这个高阶函数接收一个组件，返回一个高阶组件（其实就是给传入的组件增加一些属性和功能）connect 根据传入的 map，将 state 和 dispatch(action)挂载子组件的 props 上，我们直接放出 connect 的实现代码，寥寥几行，并不复杂： 1234567891011121314151617181920212223242526export function connect(mapStateToProps, mapDispatchToProps) { return function(Component) { class Connect extends React.Component { componentDidMount() { //从context获取store并订阅更新 this.context.store.subscribe(this.handleStoreChange.bind(this)); } handleStoreChange() { // 触发更新 // 触发的方法有多种,这里为了简洁起见,直接forceUpdate强制更新,读者也可以通过setState来触发子组件更新 this.forceUpdate() } render() { return ( &lt;Component // 传入该组件的props,需要由connect这个高阶组件原样传回原组件 { ...this.props } // 根据mapStateToProps把state挂到this.props上 { ...mapStateToProps(this.context.store.getState()) } // 根据mapDispatchToProps把dispatch(action)挂到this.props上 { ...mapDispatchToProps(this.context.store.dispatch) } /&gt; ) } } //接收context的固定写法 Connect.contextTypes = { store: PropTypes.object } return Connect }} 写完了 connect 的代码，我们有两点需要解释一下： \\1. Provider 的意义：我们审视一下 connect 的代码，其实 context 不过是给 connect 提供了获取 store 的途径，我们在 connect 中直接 import store 完全可以取代 context。那么 Provider 存在的意义是什么，其实笔者也想过一阵子，后来才想起…上面这个 connect 是自己写的，当然可以直接 import store，但 react-redux 的 connect 是封装的，对外只提供 api，所以需要让 Provider 传入 store。 \\2. connect 中的装饰器模式：回顾一下 connect 的调用方式：connect(mapStateToProps, mapDispatchToProps)(App)其实 connect 完全可以把 App 跟着 mapStateToProps 一起传进去，看似没必要 return 一个函数再传入 App，为什么 react-redux 要这样设计，react-redux 作为一个被广泛使用的模块，其设计肯定有它的深意。 其实 connect 这种设计，是装饰器模式的实现，所谓装饰器模式，简单地说就是对类的一个包装，动态地拓展类的功能。connect 以及 React 中的高阶组件（HoC）都是这一模式的实现。除此之外，也有更直接的原因：这种设计能够兼容 ES7 的装饰器(Decorator)，使得我们可以用@connect 这样的方式来简化代码，有关@connect 的使用可以看这篇： 12345678910111213//普通connect使用class App extends React.Component{ render(){ return &lt;div&gt;hello&lt;/div&gt; }}function mapStateToProps(state){ return state.main}function mapDispatchToProps(dispatch){ return bindActionCreators(action,dispatch)}export default connect(mapStateToProps,mapDispatchToProps)(App) 12345678910//使用装饰器简化@connect( state=&gt;state.main, dispatch=&gt;bindActionCreators(action,dispatch))class App extends React.Component{ render(){ return &lt;div&gt;hello&lt;/div&gt; }} 写完了 react-redux，我们可以写个 demo 来测试一下：使用create-react-app创建一个项目，删掉无用的文件，并创建 store.js、reducer.js、react-redux.js 来分别写我们 redux 和 react-redux 的代码，index.js 是项目的入口文件，在 App.js 中我们简单的写一个计数器，点击按钮就派发一个 dispatch，让 store 中的 count 加一，页面上显示这个 count。最后文件目录和代码如下： 12345678910111213141516171819// store.jsexport const createStore = (reducer) =&gt; { let currentState = {} let observers = [] //观察者队列 function getState() { return currentState } function dispatch(action) { currentState = reducer(currentState, action) observers.forEach(fn =&gt; fn()) } function subscribe(fn) { observers.push(fn) } dispatch({ type: '@@REDUX_INIT' }) //初始化store数据 return { getState, subscribe, dispatch }} 1234567891011121314151617//reducer.jsconst initialState = { count: 0}export function reducer(state = initialState, action) { switch(action.type) { case 'plus': return { ...state, count: state.count + 1 } case 'subtract': return { ...state, count: state.count - 1 } default: return initialState } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//react-redux.jsimport React from 'react'import PropTypes from 'prop-types'export class Provider extends React.Component { // 需要声明静态属性childContextTypes来指定context对象的属性,是context的固定写法 static childContextTypes = { store: PropTypes.object } // 实现getChildContext方法,返回context对象,也是固定写法 getChildContext() { return { store: this.store } } constructor(props, context) { super(props, context) this.store = props.store } // 渲染被Provider包裹的组件 render() { return this.props.children }}export function connect(mapStateToProps, mapDispatchToProps) { return function(Component) { class Connect extends React.Component { componentDidMount() { //从context获取store并订阅更新 this.context.store.subscribe(this.handleStoreChange.bind(this)); } handleStoreChange() { // 触发更新 // 触发的方法有多种,这里为了简洁起见,直接forceUpdate强制更新,读者也可以通过setState来触发子组件更新 this.forceUpdate() } render() { return ( &lt;Component // 传入该组件的props,需要由connect这个高阶组件原样传回原组件 { ...this.props } // 根据mapStateToProps把state挂到this.props上 { ...mapStateToProps(this.context.store.getState()) } // 根据mapDispatchToProps把dispatch(action)挂到this.props上 { ...mapDispatchToProps(this.context.store.dispatch) } /&gt; ) } } //接收context的固定写法 Connect.contextTypes = { store: PropTypes.object } return Connect }} 123456789101112//index.jsimport React from 'react'import ReactDOM from 'react-dom'import App from './App'import { Provider } from './react-redux'import { createStore } from './store'import { reducer } from './reducer'ReactDOM.render( &lt;Provider store={createStore(reducer)}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')); 12345678910111213141516171819202122232425262728293031323334//App.jsimport React from 'react'import { connect } from './react-redux'const addCountAction = { type: 'plus'}const mapStateToProps = state =&gt; { return { count: state.count }}const mapDispatchToProps = dispatch =&gt; { return { addCount: () =&gt; { dispatch(addCountAction) } }}class App extends React.Component { render() { return ( &lt;div className=&quot;App&quot;&gt; { this.props.count } &lt;button onClick={ () =&gt; this.props.addCount() }&gt;增加&lt;/button&gt; &lt;/div&gt; ); }}export default connect(mapStateToProps, mapDispatchToProps)(App) 运行项目，点击增加按钮，能够正确的计数，OK 大成功，我们整个 redux、react-redux 的流程就走通了 三. redux Middleware 实现上面 redux 和 react-redux 的实现都比较简单，下面我们来分析实现稍困难一些的redux 中间件。所谓中间件，我们可以理解为拦截器，用于对某些过程进行拦截和处理，且中间件之间能够串联使用。在 redux 中，我们中间件拦截的是 dispatch 提交到 reducer 这个过程，从而增强 dispatch 的功能。 我查阅了很多 redux 中间件相关的资料，但最后发现没有一篇写的比官方文档清晰，文档从中间件的需求到设计，从概念到实现，每一步都有清晰生动的讲解。下面我们就和文档一样，以一个记录日志的中间件为例，一步一步分析 redux 中间件的设计实现。 我们思考一下，如果我们想在每次 dispatch 之后，打印一下 store 的内容，我们会如何实现呢： 1. 在每次 dispatch 之后手动打印 store 的内容12store.dispatch({ type: 'plus' })console.log('next state', store.getState()) 这是最直接的方法，当然我们不可能在项目里每个 dispatch 后面都粘贴一段打印日志的代码，我们至少要把这部分功能提取出来。 2. 封装 dispatch1234function dispatchAndLog(store, action) { store.dispatch(action) console.log('next state', store.getState())} 我们可以重新封装一个公用的新的 dispatch 方法，这样可以减少一部分重复的代码。不过每次使用这个新的 dispatch 都得从外部引一下，还是比较麻烦。 3. 替换 dispatch12345let next = store.dispatchstore.dispatch = function dispatchAndLog(action) { let result = next(action) console.log('next state', store.getState()) return result} 如果我们直接把 dispatch 给替换，这样每次使用的时候不就不需要再从外部引用一次了吗？对于单纯打印日志来说，这样就足够了，但是如果我们还有一个监控 dispatch 错误的需求呢，我们固然可以在打印日志的代码后面加上捕获错误的代码，但随着功能模块的增多，代码量会迅速膨胀，以后这个中间件就没法维护了，我们希望不同的功能是独立的可拔插的模块。 4. 模块化123456789101112131415161718// 打印日志中间件function patchStoreToAddLogging(store) { let next = store.dispatch //此处也可以写成匿名函数 store.dispatch = function dispatchAndLog(action) { let result = next(action) console.log('next state', store.getState()) return result }} // 监控错误中间件 function patchStoreToAddCrashReporting(store) { //这里取到的dispatch已经是被上一个中间件包装过的dispatch, 从而实现中间件串联 let next = store.dispatch store.dispatch = function dispatchAndReportErrors(action) { try { return next(action) } catch (err) { console.error('捕获一个异常!', err) throw err } }} 我们把不同功能的模块拆分成不同的方法，通过在方法内获取上一个中间件包装过的 store.dispatch 实现链式调用。然后我们就能通过调用这些中间件方法，分别使用、组合这些中间件。 1patchStoreToAddLogging(store)patchStoreToAddCrashReporting(store) 到这里我们基本实现了可组合、拔插的中间件，但我们仍然可以把代码再写好看一点。我们注意到，我们当前写的中间件方法都是先获取 dispatch，然后在方法内替换 dispatch，这部分重复代码我们可以再稍微简化一下：我们不在方法内替换 dispatch，而是返回一个新的 dispatch，然后让循环来进行每一步的替换。 5. applyMiddleware改造一下中间件，使其返回新的 dispatch 而不是替换原 dispatch 1234567891011121314function logger(store) { let next = store.dispatch // 我们之前的做法(在方法内直接替换dispatch): // store.dispatch = function dispatchAndLog(action) { // ... // } return function dispatchAndLog(action) { let result = next(action) console.log('next state', store.getState()) return result }} 在 Redux 中增加一个辅助方法 applyMiddleware，用于添加中间件 123456function applyMiddleware(store, middlewares) { middlewares = [ ...middlewares ] //浅拷贝数组, 避免下面reserve()影响原数组 middlewares.reverse() //由于循环替换dispatch时,前面的中间件在最里层,因此需要翻转数组才能保证中间件的调用顺序 // 循环替换dispatch middlewares.forEach(middleware =&gt; store.dispatch = middleware(store) )} 然后我们就能以这种形式增加中间件了： 1applyMiddleware(store, [ logger, crashReporter ]) 写到这里，我们可以简单地测试一下中间件。我创建了三个中间件，分别是 logger1、thunk、logger2，其作用也很简单，打印 logger1 -&gt; 执行异步 dispatch -&gt; 打印 logger2，我们通过这个例子观察中间件的执行顺序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//index.jsimport React from 'react';import ReactDOM from 'react-dom';import App from './App';import { Provider } from './react-redux'import { createStore } from './store'import { reducer } from './reducer'let store = createStore(reducer)function logger(store) { let next = store.dispatch return (action) =&gt; { console.log('logger1') let result = next(action) return result }}function thunk(store) { let next = store.dispatch return (action) =&gt; { console.log('thunk') return typeof action === 'function' ? action(store.dispatch) : next(action) }}function logger2(store) { let next = store.dispatch return (action) =&gt; { console.log('logger2') let result = next(action) return result }}function applyMiddleware(store, middlewares) { middlewares = [ ...middlewares ] middlewares.reverse() middlewares.forEach(middleware =&gt; store.dispatch = middleware(store) )}applyMiddleware(store, [ logger, thunk, logger2 ])ReactDOM.render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')); 发出异步 dispatch 123456function addCountAction(dispatch) { setTimeout(() =&gt; { dispatch({ type: 'plus' }) }, 1000) } dispatch(addCountAction) 输出结果 可以看到，控制台先输出了中间件 logger1 的打印结果，然后进入 thunk 中间件打印了’thunk’，等待一秒后，异步 dispatch 被触发，又重新走了一遍 logger1 -&gt; thunk -&gt; logger2。到这里，我们就基本实现了可拔插、可组合的中间件机制，还顺便实现了 redux-thunk。 6. 纯函数之前的例子已经基本实现我们的需求，但我们还可以进一步改进，上面这个函数看起来仍然不够“纯”，函数在函数体内修改了 store 自身的 dispatch，产生了所谓的“副作用”，从函数式编程的规范出发，我们可以进行一些改造，借鉴 react-redux 的实现思路，我们可以把 applyMiddleware 作为高阶函数，用于增强 store，而不是替换 dispatch： 先对 createStore 进行一个小改造，传入 heightener（即 applyMiddleware），heightener 接收并强化 createStore。 12345678910111213141516171819202122// store.jsexport const createStore = (reducer, heightener) =&gt; { // heightener是一个高阶函数,用于增强createStore //如果存在heightener,则执行增强后的createStore if (heightener) { return heightener(createStore)(reducer) } let currentState = {} let observers = [] //观察者队列 function getState() { return currentState } function dispatch(action) { currentState = reducer(currentState, action); observers.forEach(fn =&gt; fn()) } function subscribe(fn) { observers.push(fn) } dispatch({ type: '@@REDUX_INIT' })//初始化store数据 return { getState, subscribe, dispatch }} 中间件进一步柯里化，让 next 通过参数传入 1234567891011121314151617const logger = store =&gt; next =&gt; action =&gt; { console.log('log1') let result = next(action) return result}const thunk = store =&gt; next =&gt;action =&gt; { console.log('thunk') const { dispatch, getState } = store return typeof action === 'function' ? action(store.dispatch) : next(action)}const logger2 = store =&gt; next =&gt; action =&gt; { console.log('log2') let result = next(action) return result} 改造 applyMiddleware 12345678910111213141516171819202122const applyMiddleware = (...middlewares) =&gt; createStore =&gt; reducer =&gt; { const store = createStore(reducer) let { getState, dispatch } = store const params = { getState, dispatch: (action) =&gt; dispatch(action) //解释一下这里为什么不直接 dispatch: dispatch //因为直接使用dispatch会产生闭包,导致所有中间件都共享同一个dispatch,如果有中间件修改了dispatch或者进行异步dispatch就可能出错 } const middlewareArr = middlewares.map(middleware =&gt; middleware(params)) dispatch = compose(...middlewareArr)(dispatch) return { ...store, dispatch }}//compose这一步对应了middlewares.reverse(),是函数式编程一种常见的组合方法function compose(...fns) { if (fns.length === 0) return arg =&gt; arg if (fns.length === 1) return fns[0] return fns.reduce((res, cur) =&gt;(...args) =&gt; res(cur(...args)))} 代码应该不难看懂，在上一个例子的基础上，我们主要做了两个改造 \\1. 使用 compose 方法取代了 middlewares.reverse()，compose 是函数式编程中常用的一种组合函数的方式，compose 内部使用 reduce 巧妙地组合了中间件函数，使传入的中间件函数变成(...arg) =&gt; mid1(mid2(mid3(...arg)))这种形式 \\2. 不直接替换 dispatch，而是作为高阶函数增强 createStore，最后 return 的是一个新的 store 7.洋葱圈模型之所以把洋葱圈模型放到后面来讲，是因为洋葱圈和前边中间件的实现并没有很紧密的关系，为了避免读者混淆，放到这里再提一下。我们直接放出三个打印日志的中间件，观察输出结果，就能很轻易地看懂洋葱圈模型。 1234567891011121314151617181920const logger1 = store =&gt; next =&gt; action =&gt; { console.log('进入log1') let result = next(action) console.log('离开log1') return result}const logger2 = store =&gt; next =&gt; action =&gt; { console.log('进入log2') let result = next(action) console.log('离开log2') return result}const logger3 = store =&gt; next =&gt; action =&gt; { console.log('进入log3') let result = next(action) console.log('离开log3') return result} 执行结果 由于我们的中间件是这样的结构： 12345678910111213logger1( console.log('进入logger1') logger2( console.log('进入logger2') logger3( console.log('进入logger3') //dispatch() console.log('离开logger3') ) console.log('离开logger2') ) console.log('离开logger1')) 因此我们可以看到，中间件的执行顺序实际上是这样的： 进入 log1 -&gt; 执行 next -&gt; 进入 log2 -&gt; 执行 next -&gt; 进入 log3 -&gt; 执行 next -&gt; next 执行完毕 -&gt; 离开 log3 -&gt; 回到上一层中间件,执行上层中间件 next 之后的语句 -&gt; 离开 log2 -&gt; 回到中间件 log1, 执行 log1 的 next 之后的语句 -&gt; 离开 log1 这就是所谓的“洋葱圈模型”","link":"/2021/06/21/react/redux-analysis/"},{"title":"webpack","text":"[关于 webpack4 的 14 个知识点,童叟无欺] 没有什么比时间更具有说服力了，因为时间无需通知我们就可以改变一切。 最近工作中用到了 nuxt,才发现,如果 webpack 学的 6,nuxt 基本不需要学习,没什么学习成本的,因此,这篇重新记录下 webpack4 的一些基础知识点,下一篇将会配置一个优化到极致的 react 脚手架,也希望大家能够持续关注,配置 webpack 就是优化优化再优化,哈哈~ 已经发布了webpack4 的 30 个步骤打造优化到极致的 react 开发环境，如约而至,点击这里 酒壮怂人胆,我学这个的办法基本就分 3 步： 首先,将这些必要的配置,以及某些 loader,某些插件,像语文课文一样默读,并背诵(这一步最重要) 动手去实践,去试错 理解其原理 好了,正式开始 前言Webpack 可以看做是模块打包机：它做的事情是，分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript 等），并将其打包为合适的格式以供浏览器使用。 WebPack 和 Grunt 以及 Gulp 相比有什么特性其实 Webpack 和另外两个并没有太多的可比性，Gulp/Grunt 是一种能够优化前端的开发流程的工具，而 WebPack 是一种模块化的解决方案，不过 Webpack 的优点使得 Webpack 在很多场景下可以替代 Gulp/Grunt 类的工具。 Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。 Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。 Loader：模块转换器，用于把模块原内容按照需求转换成新内容。 Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。 Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。 1. 从 0 开始配置结构 初始化项目结构 2. 配置 webpack.config.js 在项目根目录新建 webpack.config.js 3. 配置开发服务器 4. 打包 js 5. 支持 ES6,react,vue 6. 处理 css,sass,以及 css3 属性前缀处理 css 动态卸载和加载CSS style-loader 为 css 对象提供了 use()和 unuse()两种方法可以用来加载和卸载 css 比如实现一个点击切换颜色的需求，修改 index.js 处理 sass 提取 css 文件为单独文件 7.产出 html 8. 处理引用的第三方库,暴露全局变量webpack.ProvidePlugin 参数是键值对形式，键就是我们项目中使用的变量名，值就是键所指向的库 9. code splitting、懒加载(按需加载)说白了就是在需要的时候在进行加载，比如一个场景，点击按钮才加载某个 js. 10. JS Tree Shaking 11. 图片处理 12. Clean Plugin and Watch Mode清空目录，文件有改动就重新打包 13. 区分环境变量 14. 开发模式与 webpack-dev-server,proxy 到这里基本就结束了,觉得有帮助,不妨点个赞,不足之处，还望斧正~","link":"/2021/06/28/webpack/webpack/"},{"title":"react-query","text":"[react-query] react-query这是一个适用于react hooks的请求库。 这个库将帮助你获取、同步、更新和缓存你的远程数据， 提供两个简单的 hooks，就能完成增删改查等操作 react-query 一些配置参数 staleTime 重新获取数据的时间间隔 默认0 cacheTime 数据缓存时间 默认 1000 _ 60 _ 5 5 分钟 retry 失败重试次数 默认 3 次 refetchOnWindowFocus 窗口重新获得焦点时重新获取数据 默认 false refetchOnReconnect 网络重新链接 refetchOnMount 实例重新挂载 enabled 如果为“false”的化，“useQuery”不会触发，需要使用其返回的“refetch”来触发操作 如何全局配置呢？如下： 123456789101112131415161718192021import { ReactQueryConfigProvider, ReactQueryProviderConfig } from 'react-query';const queryConfig: ReactQueryProviderConfig = { /** * refetchOnWindowFocus 窗口获得焦点时重新获取数据 * staleTime 过多久重新获取服务端数据 * cacheTime 数据缓存时间 默认是 5 * 60 * 1000 5分钟 */ queries: { refetchOnWindowFocus: true, staleTime: 5 * 60 * 1000, retry: 0 },};ReactDOM.render( &lt;ReactQueryConfigProvider config={queryConfig}&gt; &lt;App /&gt; &lt;/ReactQueryConfigProvider&gt; document.getElementById('root') ); 也可以单独配置，如下： 1234567891011121314151617181920212223242526272829303132333435363738function Todos() { // 第三个参数即可传参了 // &quot;enabled&quot;参数为false的化，不会自动发起请求，而是需要调用“refetch”来触发 const { isIdle, isLoading, isError, data, error, refetch, isFetching, } = useQuery('todos', fetchTodoList, { enabled: false, }) return ( &lt;&gt; &lt;button onClick={() =&gt; refetch()}&gt;Fetch Todos&lt;/button&gt; {isIdle ? ( 'Not ready...' ) : isLoading ? ( &lt;span&gt;Loading...&lt;/span&gt; ) : isError ? ( &lt;span&gt;Error: {error.message}&lt;/span&gt; ) : ( &lt;&gt; &lt;ul&gt; {data.map(todo =&gt; ( &lt;li key={todo.id}&gt;{todo.title}&lt;/li&gt; ))} &lt;/ul&gt; &lt;div&gt;{isFetching ? 'Fetching...' : null}&lt;/div&gt; &lt;/&gt; )} &lt;/&gt; ) } useQuery（查）详见 基本使用方法 12345678910111213141516171819202122232425function Todos() { // useQuery的第一个参数，作为useQuery查询的唯一标识，该值唯一 // 可以是string、array、object // string -&gt; useQuery('todos', ...) queryKey === ['todos'] // array -&gt; useQuery(['todo', 5], ...) queryKey === ['todo', 5] // object -&gt; useQuery(['todo', 5, { preview: true }], ...) queryKey === ['todo', 5, { preview: true }] const { isLoading, isError, data, error } = useQuery('todos', fetchTodoList) if (isLoading) { return &lt;span&gt;Loading...&lt;/span&gt; } if (isError) { return &lt;span&gt;Error: {error.message}&lt;/span&gt; } // also status === 'success', but &quot;else&quot; logic works, too return ( &lt;ul&gt; {data.map(todo =&gt; ( &lt;li key={todo.id}&gt;{todo.title}&lt;/li&gt; ))} &lt;/ul&gt; ) } 传递参数 12345678910111213function Todos({ completed }) { // useQuery(['todo', { status: 1, page: 1 }], ...) queryKey === ['todo', { status: 1, page: 1 }] // 传递参数给“fetchTodoList”使用 const queryInfo = useQuery(['todos', { status: 1, page: 1 }], fetchTodoList) } // 函数参数 // key -&gt; “todos” // status -&gt; 1 page -&gt; 1 function fetchTodoList(key, { status, page }) { return new Promise() // ... } 该库实现了常用的查询操作： 分页查询 无限滚动 useMutation（增、改、删）操作12345678910111213// 当“mutate()”被调用时，执行“pingMutation”const PingPong = () =&gt; { const [mutate, { status, data, error }] = useMutation(pingMutation) const onPing = async () =&gt; { try { const data = await mutate() console.log(data) } catch { } } return &lt;button onClick={onPing}&gt;Ping&lt;/button&gt; } 传递参数 1234567891011121314151617181920212223242526272829303132// &quot;mutate({title})&quot;就会将参数“title”传递给“createTodo”函数了const createTodo = ({ title }) =&gt; { console.log(&quot;title &quot;, title)}const CreateTodo = () =&gt; {const [title, setTitle] = useState('')const [mutate] = useMutation(createTodo)const onCreateTodo = async e =&gt; { e.preventDefault() try { await mutate({ title }) // Todo was successfully created } catch (error) { // Uh oh, something went wrong }}return ( &lt;form onSubmit={onCreateTodo}&gt; &lt;input type=&quot;text&quot; value={title} onChange={e =&gt; setTitle(e.target.value)} /&gt; &lt;br /&gt; &lt;button type=&quot;submit&quot;&gt;Create Todo&lt;/button&gt; &lt;/form&gt;)} 清除缓存比如当我们编辑完一篇文章，返回列表页面，如果不清除缓存，那么数据还是缓存的数据， 所以需要清除缓存，使得“userQuery”失效，回到列表页的时候重新拉取最新数据 queryCache invalidateQueries 123456789101112131415import { useMutation, useQueryCache } from 'react-query'const queryCache = useQueryCache()const [mutate] = useMutation(addTodo, { onSuccess: () =&gt; { // invalidateQueries 的匹配规则 // eg: // queryCache.invalidateQueries('todos') 那么如下两个`query key`都会被匹配到，匹配到的缓存都会失效 // const todoListQuery = useQuery('todos', fetchTodoList) // const todoListQuery = useQuery(['todos', { page: 1 }], fetchTodoList) queryCache.invalidateQueries('todos') queryCache.invalidateQueries('reminders') },}) 以上就是“react-query”使用的一些基本操作","link":"/2021/08/02/react/reactQuery/"},{"title":"utils","text":"[一些使用的工具方法] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157import { useCallback, useEffect, useRef } from 'react';/** 判断是否是空对象 * @param object * @return boolen */export const isEmptyObject = &lt;T&gt;(obj: T): boolean =&gt; { for (let value in obj) return true; return false;};/**判断是否是对象 * @param obj * @returns boolen */export const isObject = &lt;T&gt;(obj: T) =&gt; { return Object.prototype.toString.call(obj) === '[object Object]';};/** 是否是数组 * @param arr * @returns boolen */export const isArray = &lt;T&gt;(arr: T) =&gt; { return Array.isArray(arr);};/** 数组 &amp;&amp; 非空空数组 * @param arr * @returns boolen */export const isNoEmptyArray = &lt;T&gt;(arr: T) =&gt; { return Array.isArray(arr) &amp;&amp; arr.length &gt; 0;};/** 是否是函数 * @param func * @returns boolen */export const isFunction = &lt;T&gt;(func: T) =&gt; { return typeof func === 'function';};/** 判断参数类型 * @param args * @returns * 以下是11种： * const number = 1; // [object Number] * const string = '123'; // [object String] * const boolean = true; // [object Boolean] * const und = undefined; // [object Undefined] * const nul = null; // [object Null] * const obj = {a: 1} // [object Object] * const array = [1, 2, 3]; // [object Array] * const date = new Date(); // [object Date] * const error = new Error(); // [object Error] * const reg = /a/g; // [object RegExp] * const func = function a(){}; // [object Function] */export const etype = &lt;T&gt;(args: T) =&gt; { return Object.prototype.toString.call(args);};/** 判断类型 * @param obj * @returns string */export const istype = &lt;T&gt;(obj: T) =&gt; { var class2type: { [key in string]: any } = {}; // 生成class2type映射 'Boolean Number String Function Array Date RegExp Object Error' .split(' ') .map((item) =&gt; (class2type['[object ' + item + ']'] = item.toLowerCase())); if (obj == null) return obj + ''; return typeof obj === 'object' || typeof obj === 'function' ? class2type[Object.prototype.toString.call(obj)] || 'object' : typeof obj;};/** 防抖 * @param fn 回调函数 * @param delay 时间 * @param dep 监听值 * @returns func */export const useDebounce = (fn: any, delay: number, dep = []) =&gt; { const { current } = useRef&lt;{ fn: any; timer: any }&gt;({ fn, timer: null }); useEffect(() =&gt; (current.fn = fn), [fn]); return useCallback(function f(...args) { if (current.timer) clearTimeout(current.timer); current.timer = setTimeout(() =&gt; current.fn(...args), delay); }, dep);};/** 节流 * @param fn 回调函数 * @param delay 时间 * @param dep 监听值 * @returns func */export const useThrottle = (fn: any, delay: number, dep = []) =&gt; { const { current } = useRef&lt;{ fn: any; timer: any }&gt;({ fn, timer: null }); useEffect(() =&gt; (current.fn = fn), [fn]); return useCallback(function f(...args) { if (!current.timer) { current.timer = setTimeout(() =&gt; delete current.timer, delay); current.fn(...args); } }, dep);};/** 浅拷贝 * @param data 入参 * @returns data any */export const ShallowCopy = &lt;T&gt;(data: T) =&gt; { try { return JSON.parse(JSON.stringify(data)); } catch (err) { console.error(err); return data; }};type NewObject = any[] | { [key in any]: unknown };/** 深拷贝 * @param obj * @returns */export const deepCopy = (obj: NewObject) =&gt; { if (typeof obj !== 'object') return; const newObj: NewObject = obj instanceof Array ? [] : {}; for (let key in obj) { newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key]; }};/** 遍历对象 * @param obj * @returns */export const ErgObject = (obj: object): any[] =&gt; { return isObject(obj) ? Object.entries(obj) : [];};","link":"/2021/08/30/react/utils/"},{"title":"编辑器配置","text":"[关于 vscode 的一些配置] 文档配置1234567891011{ &quot;singleQuote&quot;: true, &quot;trailingComma&quot;: &quot;all&quot;, &quot;printWidth&quot;: 80, &quot;overrides&quot;: [ { &quot;files&quot;: &quot;.prettierrc&quot;, &quot;options&quot;: { &quot;parser&quot;: &quot;json&quot; } } ]} 本地后台配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980{ &quot;terminal.integrated.automationShell.windows&quot;: &quot;C:\\\\Windows\\\\Sysnative\\\\cmd.exe&quot;, ////////////////////////////////////// &quot;background.enabled&quot;: true, &quot;background.useDefault&quot;: false, &quot;background.customImages&quot;: [ &quot;https://scott_xia.gitee.io/static-resources/img/1.jpg&quot;, &quot;https://scott_xia.gitee.io/static-resources/img/1.jpg&quot;, &quot;https://scott_xia.gitee.io/static-resources/img/1.jpg&quot; ], &quot;background.style&quot;: { &quot;content&quot;: &quot;''&quot;, &quot;pointer-events&quot;: &quot;none&quot;, &quot;position&quot;: &quot;absolute&quot;, &quot;z-index&quot;: &quot;99999&quot;, &quot;width&quot;: &quot;100%&quot;, &quot;height&quot;: &quot;100%&quot;, &quot;background-position&quot;: &quot;center&quot;, &quot;background-repeat&quot;: &quot;no-repeat&quot;, &quot;background-size&quot;: &quot;cover&quot;, &quot;opacity&quot;: 0.04 }, /////////////////////////// &quot;workbench.startupEditor&quot;: &quot;newUntitledFile&quot;, &quot;leek-fund.funds&quot;: [&quot;260108&quot;, &quot;481010&quot;, &quot;160632&quot;], &quot;leek-fund.fundSort&quot;: -2, &quot;vsicons.dontShowNewVersionMessage&quot;: true, ////////////////////////// &quot;editor.detectIndentation&quot;: false, &quot;editor.accessibilityPageSize&quot;: 14, &quot;editor.formatOnSave&quot;: true, &quot;prettier.singleQuote&quot;: true, &quot;prettier.semi&quot;: true, &quot;prettier.tabWidth&quot;: 2, &quot;[vue]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;octref.vetur&quot; }, &quot;[javascriptreact]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[jsonc]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[javascript]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[html]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[typescript]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[typescriptreact]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[markdown]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[json]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;leek-fund.stocks&quot;: [ &quot;sh000001&quot;, &quot;sh000300&quot;, &quot;sh000016&quot;, &quot;sh000688&quot;, &quot;hk03690&quot;, &quot;hk00700&quot;, &quot;usr_ixic&quot;, &quot;usr_dji&quot;, &quot;usr_inx&quot;, &quot;sh601919&quot; ] // &quot;security.workspace.trust.untrustedFiles&quot;: &quot;open&quot;}","link":"/2021/08/17/vscode/config/"},{"title":"ts_泛型工具","text":"[常用的泛型工具] 泛型工具Partical此工具的作用就是将泛型中全部属性变为可选的。 123type Partial&lt;T&gt; = { [key in keyof T]?: T[P]} 举个例子，这个类型定义在下面也会用到。 123456type Animal = { name: string, category: string, age: number, eat: () =&gt; number,}; 使用 Partical 包裹一下。 12type PartOfAnimal = Partical&lt;Animal&gt;;const ww: PartOfAnimal = { name: 'ww' }; // 属性全部可选后，可以只赋值部分属性了 Record&lt;K, T&gt;此工具的作用是将 K 中所有属性值转化为 T 类型，我们常用它来申明一个普通 object 对象。 123type Record&lt;K extends keyof any,T&gt; = { [key in K]: T} 这里特别说明一下，keyof any对应的类型为number | string | symbol，也就是可以做对象键(专业说法叫索引 index)的类型集合。 举个例子： 1const obj: Record&lt;string, string&gt; = { name: 'mbg', tag: '年轻人不讲武德' }; Pick&lt;T, K&gt;此工具的作用是将 T 类型中的 K 键列表提取出来，生成新的子键值对类型。 123type Pick&lt;T, K extends keyof T&gt; = { [P in K]: T[P]} 我们还是用上面的Animal定义，看一下 Pick 如何使用。 1const bird: Pick&lt;Animal, 'name' | 'age'&gt; = { name: 'bird', age: 1 }; Exclude&lt;T, U&gt;此工具是在 T 类型中，去除 T 类型和 U 类型的交集，返回剩余的部分。 1type Exclude&lt;T, U&gt; = T extends U ? never : T 注意这里的 extends 返回的 T 是原来的 T 中和 U 无交集的属性，而任何属性联合 never 都是自身，具体可在上文查阅。 举个例子 12type T1 = Exclude&lt;'a' | 'b' | 'c', 'a' | 'b'&gt;; // &quot;c&quot;type T2 = Exclude&lt;string | number | (() =&gt; void), Function&gt;; // string | number Omit&lt;T, K&gt;此工具可认为是适用于键值对对象的 Exclude，它会去除类型 T 中包含 K 的键值对。 1type Omit = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt; 在定义中，第一步先从 T 的 key 中去掉与 K 重叠的 key，接着使用 Pick 把 T 类型和剩余的 key 组合起来即可。 还是用上面的 Animal 举个例子： 123456const OmitAnimal: Omit&lt;Animal, 'name' | 'age'&gt; = { category: 'lion', eat: () =&gt; { console.log('eat'); },}; 可以发现，Omit 与 Pick 得到的结果完全相反，一个是取非结果，一个取交结果。 ReturnType此工具就是获取 T 类型(函数)对应的返回值类型： 12type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any; 看源码其实有点多，其实可以稍微简化成下面的样子： 1type ReturnType&lt;T extends func&gt; = T extends () =&gt; infer R ? R: any; 通过使用 infer 推断返回值类型，然后返回此类型，如果你彻底理解了 infer 的含义，那这段就很好理解。 举个例子： 1234function foo(x: string | number): string | number { /*..*/}type FooType = ReturnType&lt;foo&gt;; // string | number Required此工具可以将类型 T 中所有的属性变为必选项。 123type Required&lt;T&gt; = { [P in keyof T]-?: T[P]} 这里有一个很有意思的语法-?，你可以理解为就是 TS 中把?可选属性减去的意思。 除了这些以外，还有很多的内置的类型工具，可以参考**TypeScript Handbook获得更详细的信息，同时 Github 上也有很多第三方类型辅助工具，如utility-types**等。","link":"/2021/09/07/typesctipt/ts_uitls/"},{"title":"AES加密","text":"AES 加密参数 一、AES 加密 AES 和 DES 是常见的对称加密算法。这里不多说了。 二、AES 加密的问题 其实也不能说是问题，而是刚开始使用的时候会有一些误区： 以为使用相同的密码进行加密，就能在不同平台上得到同样的结果。 三、AES 的参数 本文的 AES 实现，默认指的是 Rijndael。 key length（密钥位数，密码长度） key （密钥，密码） IV （向量） mode （加密模式） padding （填充方式） 四、参数的意义 key length（密钥位数，密码长度） AES128，AES192，AES256（128 位、192 位或 256 位）128 位对应的是 16 个字节，所以部分平台库上，会使用 16 个字符或者长度为 16 的字符串来做密码。 key （密钥，密码） key 指的就是密码了，AES128 就是 128 位的，如果位数不够，某些库可能会自动填充到 128。 IV （向量） IV 称为初始向量，不同的 IV 加密后的字符串是不同的，加密和解密需要相同的 IV。 mode （加密模式） AES 分为几种模式，比如 ECB，CBC，CFB 等等，这些模式除了 ECB 由于没有使用 IV 而不太安全，其他模式差别并没有太明显。 padding （填充方式） 对于加密解密两端需要使用同一的 PADDING 模式，大部分 PADDING 模式为 PKCS5, PKCS7, NOPADDING。","link":"/2020/12/29/js/AESEncryption/"},{"title":"JavaScript 运行机制详解","text":"[JavaScript如何实现异步编程，详细描述EventLoop机制] 一、为什么 JavaScript 是单线程？JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么 JavaScript 不能有多个线程呢？这样能提高效率啊。 JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。 二、任务队列单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。 如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 设备（输入输出设备）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。 JavaScript 语言的设计者意识到，这时主线程完全可以不管 IO 设备，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 设备返回了结果，再回过头，把挂起的任务继续执行下去。 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。） （1）所有同步任务都在主线程上执行，形成一个执行栈(execution context stack) （2）主线程之外，还存在一个”任务队列”(task queue)。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 （3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。 下图就是主线程和任务队列的示意图。 任务队列 只要主线程空了，就会去读取”任务队列”，这就是 JavaScript 的运行机制。这个过程会不断重复。 三、事件和回调函数“任务队列”是一个事件的队列（也可以理解成消息的队列），IO 设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 “任务队列”中的事件，除了 IO 设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。 四、Event Loop主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。 为了更好地理解 Event Loop，请看下图（转引自 Philip Roberts 的演讲《Help, I’m stuck in an event-loop》）。 Event Loop 上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部 API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。 执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。请看下面这个例子。 1234567var req = new XMLHttpRequest();req.open('GET', url);req.onload = function (){};req.onerror = function (){};req.send(); 上面代码中的 req.send 方法是 Ajax 操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取”任务队列”。所以，它与下面的写法等价。 1234567var req = new XMLHttpRequest();req.open('GET', url);req.send();req.onload = function (){};req.onerror = function (){}; 也就是说，指定回调函数的部分（onload 和 onerror），在 send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取”任务队列”。 五、定时器除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做”定时器”（timer）功能，也就是定时执行的代码。 定时器功能主要由 setTimeout()和 setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论 setTimeout()。 12345setTimeout() // 接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。console.log(1);setTimeout(function(){console.log(2);},1000);console.log(3); 上面代码的执行结果是 1，3，2，因为 setTimeout()将第二行推迟到 1000 毫秒之后执行。 如果将 setTimeout()的第二个参数设为 0，就表示当前代码执行完（执行栈清空）以后，立即执行（0 毫秒间隔）指定的回调函数。 12setTimeout(function(){console.log(1);}, 0);console.log(2); 上面代码的执行结果总是 2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。 总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。 HTML5 标准规定了 setTimeout()的第二个参数的最小值（最短间隔），不得低于 4 毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为 10 毫秒。另外，对于那些 DOM 的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每 16 毫秒执行一次。这时使用 requestAnimationFrame()的效果要好于 setTimeout()。 需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在 setTimeout()指定的时间执行。 #table table { border: 2px solid #dbdbdb; } 宏任务 # 浏览器 Node I/O ✅ ✅ setTimeout ✅ ✅ setInterval ✅ ✅ setImmediate ❌ ✅ requestAnimationFrame ✅ ❌ 微任务 # 浏览器 Node process.nextTick ❌ ✅ MutationObserver ✅ ❌ Promise.then catch finally ✅ ✅ 六、Node.js 的 Event LoopNode.js 也是单线程的 Event Loop，但是它的运行机制不同于浏览器环境。 请看下面的示意图 Node.js 根据上图，Node.js 的运行机制如下。 （1）V8 引擎解析 JavaScript 脚本。 （2）解析后的代码，调用 Node API。 （3）libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。 （4）V8 引擎再将结果返回给用户。 除了 setTimeout 和 setInterval 这两个方法，Node.js 还提供了另外两个与”任务队列”有关的方法：process.nextTick 和 setImmediate。它们可以帮助我们加深对”任务队列”的理解。 process.nextTick 方法可以在当前”执行栈”的尾部—-下一次 Event Loop（主线程读取”任务队列”）之前—-触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。setImmediate 方法则是在当前”任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次 Event Loop 时执行，这与 setTimeout(fn, 0)很像。请看下面的例子（via StackOverflow）。 12345678910111213process.nextTick(function A() {console.log(1);process.nextTick(function B(){console.log(2);});});setTimeout(function timeout() {console.log('TIMEOUT FIRED');}, 0)// 1// 2// TIMEOUT FIRED 上面代码中，由于 process.nextTick 方法指定的回调函数，总是在当前”执行栈”的尾部触发，所以不仅函数 A 比 setTimeout 指定的回调函数 timeout 先执行，而且函数 B 也比 timeout 先执行。这说明，如果有多个 process.nextTick 语句（不管它们是否嵌套），将全部在当前”执行栈”执行。 现在，再看 setImmediate。 12345678910setImmediate(function A() {console.log(1);setImmediate(function B(){console.log(2);});});setTimeout(function timeout() {console.log('TIMEOUT FIRED');}, 0); 上面代码中，setImmediate 与 setTimeout(fn,0)各自添加了一个回调函数 A 和 timeout，都是在下一次 Event Loop 触发。那么，哪个回调函数先执行呢？答案是不确定。运行结果可能是 1–TIMEOUT FIRED–2，也可能是 TIMEOUT FIRED–1–2。 令人困惑的是，Node.js 文档中称，setImmediate 指定的回调函数，总是排在 setTimeout 前面。实际上，这种情况只发生在递归调用的时候。 12345678910111213setImmediate(function (){ setImmediate(function A() { console.log(1); setImmediate(function B(){console.log(2);}); }); setTimeout(function timeout() { console.log('TIMEOUT FIRED'); }, 0);});// 1// TIMEOUT FIRED// 2 上面代码中，setImmediate 和 setTimeout 被封装在一个 setImmediate 里面，它的运行结果总是 1–TIMEOUT FIRED–2，这时函数 A 一定在 timeout 前面触发。至于 2 排在 TIMEOUT FIRED 的后面（即函数 B 在 timeout 后面触发），是因为 setImmediate 总是将事件注册到下一轮 Event Loop，所以函数 A 和 timeout 是在同一轮 Loop 执行，而函数 B 在下一轮 Loop 执行。 我们由此得到了 process.nextTick 和 setImmediate 的一个重要区别：多个 process.nextTick 语句总是在当前”执行栈”一次执行完，多个 setImmediate 可能则需要多次 loop 才能执行完。事实上，这正是 Node.js 10.0 版添加 setImmediate 方法的原因，否则像下面这样的递归调用 process.nextTick，将会没完没了，主线程根本不会去读取”事件队列”！ 123process.nextTick(function foo() {process.nextTick(foo);}); 事实上，现在要是你写出递归的 process.nextTick，Node.js 会抛出一个警告，要求你改成 setImmediate。 另外，由于 process.nextTick 指定的回调函数是在本次”事件循环”触发，而 setImmediate 指定的是在下次”事件循环”触发，所以很显然，前者总是比后者发生得早，而且执行效率也高（因为不用检查”任务队列”）。","link":"/2021/05/31/js/EventLoop/"},{"title":"执行上下文","text":"什么是执行上下文 Execution contextJS执行上下文，即JS的执行环境 执行上下文的类型执行上下文的类型分为三种： 全局代码，函数代码，eval代码 执行上下文栈（执行栈）执行栈是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文 其中函数执行上下文是在函数调用时生成的， 即遇到函数执行的时候，就会创建一个执行上下文","link":"/2020/12/25/js/ExecutionContext/"},{"title":"js监听模式","text":"[js 之观察者模式和发布订阅模式区别] JavaScript 中常见设计模式 单例模式 策略模式 代理模式 迭代器模式 发布-订阅模式 命令模式 组合模式 模板方法模式 享元模式 职责链模式 中介者模式 装饰者模式 状态模式 适配者模式 观察者模式观察者模式 观察者模式（Observer）观察者模式指的是一个对象（Subject）维持一系列依赖于它的对象（Observer），当有关状态发生变更时 Subject 对象则通知一系列 Observer 对象进行更新。 在观察者模式中，Subject 对象拥有添加、删除和通知一系列 Observer 的方法等等，而 Observer 对象拥有更新方法等等。 在 Subject 对象添加了一系列 Observer 对象之后，Subject 对象则维持着这一系列 Observer 对象，当有关状态发生变更时 Subject 对象则会通知这一系列 Observer 对象进行更新。 123456789101112131415161718192021222324252627282930313233343536373839404142function Subject(){ this.observers = [];} Subject.prototype = { add:function(observer){ // 添加 this.observers.push(observer); }, remove:function(observer){ // 删除 var observers = this.observers; for(var i = 0;i &lt; observers.length;i++){ if(observers[i] === observer){ observers.splice(i,1); } } }, notify:function(){ // 通知 var observers = this.observers; for(var i = 0;i &lt; observers.length;i++){ observers[i].update(); } }} function Observer(name){ this.name = name;} Observer.prototype = { update:function(){ // 更新 console.log('my name is '+this.name); }} var sub = new Subject(); var obs1 = new Observer('ttsy1');var obs2 = new Observer('ttsy2'); sub.add(obs1);sub.add(obs2);sub.notify(); //my name is ttsy1、my name is ttsy2 上述代码中，我们创建了 Subject 对象和两个 Observer 对象，当有关状态发生变更时则通过 Subject 对象的 notify 方法通知这两个 Observer 对象，这两个 Observer 对象通过 update 方法进行更新。 在 Subject 对象添加了一系列 Observer 对象之后，还可以通过 remove 方法移除某个 Observer 对象对它的依赖。 123456789101112131415161718192021222324252627282930313233343536373839404142function Subject(){ this.observers = [];} Subject.prototype = { add:function(observer){ // 添加 this.observers.push(observer); }, remove:function(observer){ // 删除 var observers = this.observers; for(var i = 0;i &lt; observers.length;i++){ if(observers[i] === observer){ observers.splice(i,1); } } }, notify:function(){ // 通知 var observers = this.observers; for(var i = 0;i &lt; observers.length;i++){ observers[i].update(); } }} function Observer(name){ this.name = name;} Observer.prototype = { update:function(){ // 更新 console.log('my name is '+this.name); }} var sub = new Subject(); var obs1 = new Observer('ttsy1');var obs2 = new Observer('ttsy2'); sub.add(obs1);sub.add(obs2);sub.notify(); //my name is ttsy1、my name is ttsy2 发布订阅模式（Publisher &amp;&amp; Subscriber）发布订阅模式指的是希望接收通知的对象（Subscriber）基于一个主题通过自定义事件订阅主题，被激活事件的对象（Publisher）通过发布主题事件的方式通知各个订阅该主题的 Subscriber 对象。 12345678910111213141516171819202122232425262728293031323334let pubSub = { list:{}, subscribe:function(key,fn){ // 订阅 if (!this.list[key]) { this.list[key] = []; } this.list[key].push(fn); }, publish:function(){ // 发布 let arg = arguments; let key = [].shift.call(arg); let fns = this.list[key]; if(!fns || fns.length&lt;=0) return false; for(var i=0,len=fns.length;i&lt;len;i++){ fns[i].apply(this, arg); } }, unSubscribe(key) { // 取消订阅 delete this.list[key]; }}; pubSub.subscribe('name', (name) =&gt; { console.log('your name is ' + name);});pubSub.subscribe('sex', (sex) =&gt; { console.log('your sex is ' + sex);});pubSub.publish('name', 'ttsy1'); // your name is ttsy1pubSub.publish('sex', 'male'); // your sex is male 上述代码的订阅是基于 name 和 sex 主题来自定义事件，发布是通过 name 和 sex 主题并传入自定义事件的参数，最终触发了特定主题的自定义事件。 可以通过 unSubscribe 方法取消特定主题的订阅。 123456789pubSub.subscribe('name', (name) =&gt; { console.log('your name is ' + name);});pubSub.subscribe('sex', (sex) =&gt; { console.log('your sex is ' + sex);});pubSub.unSubscribe('name');pubSub.publish('name', 'ttsy1'); // 这个主题被取消订阅了pubSub.publish('sex', 'male'); // your sex is male 观察者模式 VS 发布订阅模式 观察者模式与发布订阅模式都是定义了一个一对多的依赖关系，当有关状态发生变更时则执行相应的更新。 不同的是，在观察者模式中依赖于 Subject 对象的一系列 Observer 对象在被通知之后只能执行同一个特定的更新方法，而在发布订阅模式中则可以基于不同的主题去执行不同的自定义事件。相对而言，发布订阅模式比观察者模式要更加灵活多变。","link":"/2021/06/09/js/ObserverSubPub/"},{"title":"作用域","text":"作用域作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 静态作用域与动态作用域因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。 让我们认真看个例子就能明白之间的区别： 123456789101112var value = 1;function foo() { console.log(value);}function bar() { var value = 2; foo();}bar(); // 结果是 ???假设JavaScript采用静态作用域，让我们分析下执行过程： 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。 假设JavaScript采用动态作用域，让我们分析下执行过程： 执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。 前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。 动态作用域也许你会好奇什么语言是动态作用域？ bash 就是动态作用域，不信的话，把下面的脚本存成例如 scope.bash，然后进入相应的目录，用命令行执行 bash ./scope.bash，看看打印的值是多少。 12345678value=1function foo () { echo $value;}function bar () { local value=2; foo;} bar这个文件也可以在 Github 博客仓库中找到。 思考题最后，让我们看一个《JavaScript权威指南》中的例子： 123456789101112131415161718var scope = &quot;global scope&quot;;function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f();}checkscope();var scope = &quot;global scope&quot;;function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f;}checkscope()(); 猜猜两段代码各自的执行结果是多少？ 这里直接告诉大家结果，两段代码都会打印：local scope。 原因也很简单，因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。 而引用《JavaScript权威指南》的回答就是： JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。","link":"/2020/12/25/js/Scope/"},{"title":"d3入门","text":"[这里是文章说明] D3.js入门教程 &nbsp;&nbsp;&nbsp;&nbsp;1、D3.js简介 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; D3.js是一个强大的数据可视化js语言，可以利用svg在网页上展示各种精美的矢量图 &nbsp; &nbsp; 2、D3.js的官方 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 官网：https://d3js.org/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 官方API：https://github.com/d3/d3/blob/master/API.md &nbsp; &nbsp; 3、适合人群 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 本教程适合需要在网页前端做数据可视化图表开发、对数据可视化感兴趣、为图形痴狂，以及想了解并学习D3.js的读者 &nbsp; &nbsp; 4、编写原因 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; D3.js相对较新，目前版本也多样，版本之间变化也比较大，目前最新版本是v5，但是目前网上面的好的入门教程大多是v3版本，v5版本的教程少得可怜，而且很分散，（我在学习的过程中没有找到v5版本比较好的教程，使自己看官方API，然后百度关键字，花漫长时间才找到正确编写方法），v5和v3版本差别还是很大的，而且最近因为参加学校的一个创新实训，需要做数据可视化，就学了这个 &nbsp; &nbsp;5、参考文献 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 我写这篇教程的灵感来自于这片教程，大家可以发现：章节标题差不多是一样的。但是别人的是v3版本的 教程，写的很好，我写的是v5版本的教程，因为版本之间的差别比较大，虽然有那么好的v3版本教程，但是我在学习的过程中还是遇到很多阻碍！所以想将经验分享出来 &nbsp; &nbsp; 参考资料链接：http://wiki.jikexueyuan.com/project/d3wiki/ &nbsp;&nbsp;&nbsp;&nbsp;6、教程章节 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;D3.js的v5版本入门教程（第一章）—— 如何在项目中使用D3.js &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;D3.js的v5版本入门教程（第二章）—— 第一个程序 Hello World &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;D3.js的v5版本入门教程（第三章）—— 选择元素和绑定数据 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;D3.js的v5版本入门教程（第四章）—— 理解Update、Enter、Exit &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;D3.js的v5版本入门教程（第五章）—— 选择、插入、删除元素 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;D3.js的v5版本入门教程（第六章）——做一个简单的图表 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;D3.js的v5版本入门教程（第七章）—— 比例尺的使用 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;D3.js的v5版本入门教程（第八章）—— 坐标轴 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;D3.js的v5版本入门教程（第九章）——完整的柱状图 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D3.js的v5版本入门教程（第十章）——让图表动起来 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D3.js的v5版本入门教程（第十一章）——交互式操作 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D3.js的v5版本入门教程（第十二章）—— D3.js中各种精美的图形 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D3.js的v5版本入门教程（第十三章）—— 饼状图 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D3.js的v5版本入门教程（第十四章）—— 力导向图 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D3.js的v5版本入门教程（第十五章）—— 树状图 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D3.js的v5版本入门教程（第十六章）—— 中国地图 &nbsp; &nbsp; 7、精美的SVG图（预览需要用电脑才能打开链接） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 在学习之前，先来放一波“毒”，看看从本教程你能学到什么——SVG图，太美了！！！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 1、简单图表1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 链接：点击预览 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2、简单图表2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 链接：点击预览 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 3、简单图表3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 链接：点击预览 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 4、完整的柱状图 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 链接：点击预览 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 5、动态柱状图 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 链接：点击预览 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 6、会变色的柱状图 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 链接：点击预览 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 7、饼状图 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 链接：点击预览 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 8、力导向图 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 链接：点击预览 &nbsp; &nbsp; &nbsp; &nbsp; 9、树状图 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 链接：点击预览 &nbsp; &nbsp; 8、关于调试 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 本教程中出现的控制台指的都是chrome浏览器中的调试窗口的控制台","link":"/2021/09/02/js/d3/"},{"title":"Generator","text":"[关于 Generator 的应用] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function* gen() { const res1 = yield fetch( 'https://devapi.sangon.com:30443/api/user/v1/user/login/password/xuzhengwei/sangon123' ); const res2 = yield fetch('https://api.github.com/users/github/followers'); const res3 = yield function asyncFn(callback) { setTimeout(() =&gt; { console.log(1); callback([1, 2, 3, 4, 5]); }, 1000); }; const res4 = yield function asyncFn(callback) { setTimeout(() =&gt; { console.log(2); callback([1, 2, 3, 4, 5]); }, 500); }; console.log(res1, res2, res3, res4);}const RunReject = (gen) =&gt; { const iterator = gen(); const isPromise = (obj) =&gt; 'function' == typeof obj.then; return new Promise((resolve, reject) =&gt; { const next = (data) =&gt; { try { const result = iterator.next(data); if (result.done) return resolve(); if (isPromise(result.value)) { result.value.then((data) =&gt; data.json()).then((data) =&gt; next(data)); } else { result.value((data) =&gt; { next(data); }); } } catch (e) { reject(e); } }; next(); });};RunReject(gen); 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 语句，定义不同的内部状态 123456function* helloWorldGenerator() { yield 'hello'; yield 'world'; return 'ending';}var hw = helloWorldGenerator(); Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，我们可以通过调用 next 方法，使得指针移向下一个状态 hw.next() 1234567// { value: 'hello', done: false }hw.next();// { value: 'world', done: false }hw.next();// { value: 'ending', done: true }hw.next();// { value: undefined, done: true } 这是基础用法，还有一点不得不介绍：next 给函数内变量传值 123456789101112function* f() { for (var i = 0; true; i++) { var reset = yield i; if (reset) { i = -1; } }}var g = f();g.next(); // { value: 0, done: false }g.next(); // { value: 1, done: false }g.next(true); // { value: 0, done: false } 上面代码先定义了一个可以无限运行的 Generator 函数 f，如果 next 方法没有参数，每次运行到 yield 语句，变量 reset 的值总是 undefined。当 next 方法带一个参数 true 时，变量 reset 就被重置为这个参数（即 true），因此 i 会等于-1，下一轮循环就会从-1 开始递增。这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过 next 方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。这个用处在其用来实现 async/await 至关重要。简单吧？到次 generator 介绍完毕下面说说用处## infinite range &amp; lazy evaluation 123456789101112for...of循环可以自动遍历Generator函数时生成的Iterator对象，且此时不再需要调用next方法。function *foo() { yield 1; yield 2; yield 3; yield 4; yield 4+1; //只有在获取第五个元素时才会计算 return 6;}for (let v of foo()) { console.log(v);}// 1 2 3 4 5 这里只是一个 lazy evaluation 例子，同样你可以将这个例子改为获取 1 到无穷 所有的整数。- async/await 这里的实现原理有点复杂可以参考下阮一峰的 ECMAScript 6 入门http://es6.ruanyifeng.com/#docs/generator-async http://es6.ruanyifeng.com/# 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 第三版function run(gen) { return new Promise(function (resolve, reject) { if (typeof gen == 'function') gen = gen(); // 如果 gen 不是一个迭代器 if (!gen || typeof gen.next !== 'function') return resolve(gen); onFulfilled(); function onFulfilled(res) { var ret; try { ret = gen.next(res); } catch (e) { return reject(e); } next(ret); } function onRejected(err) { var ret; try { ret = gen.throw(err); } catch (e) { return reject(e); } next(ret); } function next(ret) { if (ret.done) return resolve(ret.value); var value = toPromise(ret.value); if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); return onRejected( new TypeError( 'You may only yield a function, promise ' + 'but the following object was passed: &quot;' + String(ret.value) + '&quot;' ) ); } });}function isPromise(obj) { return 'function' == typeof obj.then;}function toPromise(obj) { if (isPromise(obj)) return obj; if ('function' == typeof obj) return thunkToPromise(obj); return obj;}function thunkToPromise(fn) { return new Promise(function (resolve, reject) { fn(function (err, res) { if (err) return reject(err); resolve(res); }); });}module.exports = run;","link":"/2021/08/30/js/generator/"},{"title":"git Commit","text":"[关于规范git提交格式] Commit message 的格式每次提交，Commit message 都包括三个部分：header，body 和 footer。 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt; 其中，header 是必需的，body 和 footer 可以省略。 不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。 HeaderHeader部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。 type用于说明 commit 的类别，只允许使用下面7个标识。 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。 scopescope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 例如在Angular，可以是$location, $browser, $compile, $rootScope, ngHref, ngClick, ngView等。 如果你的修改影响了不止一个scope，你可以使用*代替。 subjectsubject是 commit 目的的简短描述，不超过50个字符。 其他注意事项： 以动词开头，使用第一人称现在时，比如change，而不是changed或changes 第一个字母小写 结尾不加句号（.） BodyBody 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。 1234567More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. Further paragraphs come after blank lines.- Bullet points are okay, too- Use a hanging indent 有两个注意点: 使用第一人称现在时，比如使用change而不是changed或changes。 永远别忘了第2行是空行 应该说明代码变动的动机，以及与以前行为的对比。 FooterFooter 部分只用于以下两种情况： 不兼容变动如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。 1234567891011121314151617BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: { myAttr: 'attribute', } After: scope: { myAttr: '@', } The removed `inject` wasn't generaly useful for directives so there should be no code using it. 关闭 Issue如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。 1Closes #234 Revert还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。 123revert: feat(pencil): add 'graphiteWidth' optionThis reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成This reverts commit &lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。 如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。 Commitizen可以使用典型的git工作流程或通过使用CLI向导Commitizen来添加提交消息格式。 安装1npm install -g commitizen 然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。 1commitizen init cz-conventional-changelog --save --save-exact 以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message。 5.png validate-commit-msgvalidate-commit-msg 用于检查项目的 Commit message 是否符合Angular规范。 该包提供了使用githooks来校验commit message的一些二进制文件。在这里，我推荐使用husky，只需要添加&quot;commitmsg&quot;: &quot;validate-commit-msg&quot;到你的package.json中的nam scripts即可. 当然，你还可以通过定义配置文件.vcmrc来自定义校验格式。详细使用请见文档 validate-commit-msg 生成 Change log如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。生成的文档包括以下三个部分： New features Bug fixes Breaking changes. 每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。 conventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。 123$ npm install -g conventional-changelog$ cd my-project$ conventional-changelog -p angular -i CHANGELOG.md -w 参考文章Commit message 和 Change log 编写指南 Angular.js Git Commit Guidelines","link":"/2021/12/13/js/gitcommit/"},{"title":"websocket","text":"浅谈webscoket原理及其应用什么是 webSocketWebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。 在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 WebSocket 解决了什么问题：在不使用 WebSocket 时，如果我们需要建立一条长连接，有以下几种方法： 轮询 长轮询（常用） SSE(Server Send Event) 当出现类似体育赛事、聊天室、实时位置之类的场景时，客户端要获取服务器端的变化，就只能通过轮询(定时请求)来了解服务器端有没有新的信息变化。WebSocket 的出现，让服务器端可以主动向服务器端发送信息，使得浏览器具备了实时双向通信的能力,这就是 WebSocket 解决的问题 带宽问题：WebSocket 相对于 HTTP 来说协议头更加小，同时按需传递。 数据实时性问题：WebSocket 相对于轮询和长轮询来说，能够实时传递数据，延迟更小。 状态问题：相较于 HTTP 的无状态请求，WebSocket 在建立连接后能够维持特定的状态。 WebSocket 与 HTTP 对比基本使用客户端123456789101112131415161718const ws = new WebSocket('ws://localhost:8888')ws.onopen = () =&gt; { console.log('WebSocket onopen')}ws.onmessage = e =&gt; { console.log(e) console.log(e.data)}ws.onclose = e =&gt; { console.log('WebSocket onclose')}ws.onerror = e =&gt; { console.log('WebSocket onerror')} WebSocket.onopen： 连接成功后调用 WebSocket.onmessage： 当接收到服务器消息时调用 WebSocket.onclose： 连接关闭后调用 WebSocket.onerror： 发生错误后调用 服务端例子(koa)123456789101112131415161718const Koa = require('koa')const WebSocket = require('ws')const app = new Koa()const ws = new WebSocket.Server({ port: 8888 })ws.on('connection', ws =&gt; { console.log('server connection') ws.on('message', msg =&gt; { console.log('server receive msg：', msg) }) ws.send('Information from the server')})app.listen(3000) WebSocket 可以传递 String、ArrayBuffer 和 Blob 三种数据类型，因此在收到消息时可能是其中的任意一种。其中，String 和 ArrayBuffer 使用的最多。 如果是 String 类型，直接通过字符串处理函数即可进行相关转换，如 JSON 等格式。 如果是二进制 blob 类型，则需要使用 ArrayBuffer 和 DataView 来进行处理，下面简单介绍。 二进制数据包括：blob 对象和 Arraybuffer 对象，所以我们需要分开来处理。 123456789101112131415161718192021// 接收数据ws.onmessage = function(event) { if (event.data instanceof ArrayBuffer) { // 判断 ArrayBuffer 对象 } if (event.data instanceof Blob) { // 判断 Blob 对象 }}// 发送 Blob 对象的例子let file = document.querySelector('input[type=&quot;file&quot;]').files[0]ws.send(file)// 发送 ArrayBuffer 对象的例子var img = canvas_context.getImageData(0, 0, 400, 320)var binary = new Uint8Array(img.data.length)for (var i = 0; i &lt; img.data.length; i++) { binary[i] = img.data[i]}ws.send(binary.buffer) webSocket.bufferedAmount 属性，表示还有多少字节的二进制数据没有发送出去 如果发送的二进制数据很大的话，可以这样判断 12345678var data = new ArrayBuffer(10000000)socket.send(data)if (socket.bufferedAmount === 0) { // 发送完毕} else { // 发送还没结束} 总结 WebSocket 的优点 双向通信(一开始说的，也是最重要的一点)。 数据格式比较轻量，性能开销小，通信高效 协议控制的数据包头部较小，而 HTTP 协议每次通信都需要携带完整的头部 更好的二进制支持 没有同源限制，客户端可以与任意服务器通信 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器 转载：https://juejin.cn/post/6844904009728262152","link":"/2018/07/15/js/websocket/"},{"title":"公共政策学笔记","text":"《公共政策学》笔记 政策分析的内涵","link":"/2021/01/28/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/%E5%85%AC%E5%85%B1%E6%94%BF%E7%AD%96/%E7%AC%94%E8%AE%B0/"},{"title":"笔记","text":"一些常见问题及知识点 人民代表大会制度民族区域自治制度特别行政区制度基层民主制度一般地方行政制度 政治制度的特点：历史性、稳定性、强制性、合法性","link":"/2021/03/01/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/%E5%BD%93%E4%BB%A3%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB%E5%88%B6%E5%BA%A6/%E7%AC%94%E8%AE%B0/"},{"title":"名词解释","text":"名词解释 2020/01/15 家庭: 是个有婚姻血缘或收养关系的人们组成的长期共同生活的群体，是人类生活中最基本最重要的一种群体形式。 社会：社会是人们交互作用中产生的各种社会关系的总和。 集体行为： 集体行为是指在缺乏确定组织程序和制度规范的条件下，很大程度上自发形成的，由许多个体参加的非制度化的行为。 社会分层：社会分层是指社会资源不均等分配。 城镇化：城镇化是指人口和社会职能向城镇或城市聚集，生成方式、文化模式和社会角色发生变更，使城乡接近、融合的过程。 统计调查: 根据调查的目的与要求，运用科学的调查方法，有计划、有组织地搜索数据信息资料进行统计。 社会化：社会化是社会对个人文化教化和个人对社会主动选择与能动调试的统一过程。 组织：组织是指人们为了达到特定的目标有计划的建立起来的具有比较严格的结构的制度化的群体。 消费：消费是为满足生产和生活需要而消耗物质和文化财富的活动，消费不仅仅是人们生活中的消费，还包括生产本身的生产消费。 社会变迁：社会变迁是个人与社会的关系基本形态的变异。 2021/01/20 实地研究实地研究又称田野调查，是一种深入研究对象内部，以参与观察和非结构访问的方式收集资料，并通过这些资料进行定性分析，解释社会现象的一种研究方法。 社会关系社会关系：是人们在物质生产活动和社会交往过程中形成的相互关系的总称。 社会化是社会对个人的文化教化和个人对社会主动选择与能动调适的统一的社会过程。 既得利益集团指对公共资源享有支配权的社会阶层，为了共有的特殊利益而结成的共同体。 社区指以一定地域为基础的社会生活共同体。 2021/01/21 社会学本土化社会学本土化是一种是外来社会学与本土社会的实际结合，形成具有本土特色的社会学理论与研究方法的学术过程 宗教宗教是人们对超人类、超自然的神的幻想、敬畏与信仰，是现实世界人的头脑里的歪曲反应 交换交换指在一定的规则下，行为者为了获得回报而行动、并获得回报的社会互动形式 私人部门私人部门指为私人拥有，并以利润最大化为组织目标，通过在市场上出售其产品或者提供服务以求得利润的各类工商企业组织 社会变迁社会变迁是个人与社会的关系基本形态的变异 2021/01/22 定量方法定量方法是对社会现象的数量特征、数量关系与数量变化进行分析的一种方法。 社会问题社会问题是指因个人与社会的关系的失调或社会结构与环境失调而影响相当数量社会成员的正常生活，妨碍社会协调发展的问题 家庭家庭是具有婚姻、血缘或收养关系的人们组成的长期共同生活的群体 角色社会角色是指由一定的社会地位所决定的、符合一定社会期望的行为模式 社会互动社会互动是人与人之间通过一定的符号和交往形式而产生相互影响的过程 2021/01/25","link":"/2021/01/12/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/%E7%A4%BE%E4%BC%9A%E5%AD%A6/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"},{"title":"社会学人物总结表","text":"社会学人物总结表","link":"/2021/01/15/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/%E7%A4%BE%E4%BC%9A%E5%AD%A6/%E7%A4%BE%E4%BC%9A%E5%AD%A6%E4%BA%BA%E7%89%A9%E6%80%BB%E7%BB%93%E8%A1%A8/"},{"title":"社会学错题集","text":"错题整理 2021/1/14 帕森斯认为任何社会若要生存就必须具备维持系统所必须的一般条件，必要条件包括四个方面：1. 适应； 2. 达鹄；3. 整合；4. 维模 社会学符号互动论源于美国社会学家米德，主要代表人物：布鲁默和戈尔曼 文化交流中文化杂交成为：文化采借 梅约和罗伊斯里斯伯格等人知道的著名霍桑实验中形成的组织管理理论是：人际关系理论 社会学者对社区的研究始于德国社会学家滕尼斯的： 类型学研究 社区发展的原则：① 民主的原则；② 民众需要的原则；③ 自力原则；④ 自下而上与自上而下相结合的原则。⑤ 物质文明、精神文明和政治文明建设并重原则。 墨印模式：属于政治主导型城镇化。 是发展经济学中所谓的“无工业化的城镇化”，是与西欧资本主义城镇化截然相反的低水准的城镇化 在解释集体行为理论中，斯梅尔瑟提出的是：搭便车理论 社会化的类型： （1）基本社会化 ：生物人通过社会文化教化，获得人的社会性和社会生活资格的过程 （2）继续社会化：人在成年以后的社会化，即二次社会化 （3）在社会化：基本社会化的延续、完善和发展 （4）正向社会化和反向社会化 集体行为的特征：群体性，自发性，非组织性和非制度化 有关我国城镇化发展道路的讨论，主要观点有： （1）大中城市论 （2）均衡发展论 （3）多元模式论 （4）小城镇重点论 2021/1/15 在社会学传人中国之时，酋次提出“社会学”之名的是谭嗣同 孪达的代表性著作之一是《中国社会学》 我国明确地采用社会建设概念，是在中国共产党的十六届四中全会 文化交流开始于文化传播 人在成年以后的社会化，被称为继续社会化 在一些农业地区逐步形成大家一起收获庄稼的合作习惯，属于制度化的传统合作 以个人和社会网络的连接的紧密程度不同来区分，社会网络的形态可以分为稳固形态和松散形态 在组织管理理论的权变理论中，较著名的是超 Y 理论 滕尼斯分析了两种对立的社会联系类型，即社区和社会 琼·戈特曼创立了城市群理论 毛泽东把农民阶级分为四个阶层 以帕森斯、列维、勒纳、摩尔、英格尔斯、麦克勒兰德、布莱克、艾森斯塔德等为主要代表的现代化理论属于依附理论 社会学的社会管理功能主要表现在 （1）建立规范 （2）提供模式 （3）反馈信息 自然资源的特征有：有限性、无限性、系统性、不均匀性 从城镇化与工业化发展水平关系来考察，城镇化可分为：同步城镇化、过度城镇化、滞后城镇化、低度城镇化和逆城镇化 社会变迂的特点有：必然性，前进性，非直线式，全面性 2021/01/19 改革开放以来，我国城镇阶层结构大体分为 16个阶层 结合关系可以表现为 强制关系 表现在劳动者身上的以劳动者数量和质量表示的资源，被称为 人力资源 教育科学制度属于 派生制度 进入 20 世纪之后，社区研究的一个重大发展，就是开拓了对当代社会的城市社区的研究，其中最著名的学派就是 芝加哥学派 美国社会学家布劳和邓肯提出了一个美国社会中的 地位获得模式 社会学在教育方面的功能主要有:① 帮助人们自觉地完成社会化；② 帮助人们合理选择 社会学的社会管理功能:① 建立规范。② 提供模式。③ 反馈信息。 社会学的社会批评功能:对旧的思想、旧的观念和阻碍社会进步的事物、行为进行揭露，实事求是地进行理论分析，提出克服和解决问题的意见与建议。 文化传播有一个过程，美国人类学家林顿把文化传播分为:A 接触与显示阶段 B 选择阶段 C 采纳融合阶段 组织的特征表现为:（1）有一定数量的社会成员（2）有一定的为群体成员所接受的目标（3）有明确的成员关系，并形成归属感（4）有一定的行为准则（5）时间上具有一定的连续性 据美国学者马列比和杰克林概括，男女在各方面的差别有:在逻辑思维、数学能力方面，男性较高于女性在触觉方面，女性比男性敏感，反应更快 社会变迁的特点包括:（1）必然性（2）前进性（3）非直线式（4）全面性 2021/01/20 文化的整合功能包括:价值整合、规范整合和结构整合 符号互动论的主要倡导者是 布鲁默 我国家庭的生命周：期建立、扩展、抚育、收缩、空巢、消亡 中国学者自己的社区研究始于 20 世纪 20 年代末的 乡村建设运动期间 介于农村社区和城市社区之间的中间形态是 集镇社区 社会控制的类型:宏观控制、 微观控制、 制度化控制、 非制度化控制、 外在控制、 积极性控制、 消极性控制 欧洲社会学在战后的发展表现出来的特点:社会学研究领域的多元化社会学的理论研究趋向多元化社会学的制度化取得很大进展社会学的研究重心转向现实社会 中国目前的家庭制度兼具传统和现代双重特征，主要表现有:家庭结构和功能的过渡性家庭关系和分工的过渡性家庭问题的复杂性 2021/01/21 在文化的功能中，表现为提供知识和积累成果两方面的是: 社会导向功能 我国的农村社区大致有两种形态: 集村和乡镇 韦伯主张从三项标准来进行社会分层: 阶级范畴（经济）、地位范畴（社会）、政党范畴（政治） 美国社会学家特纳提出了两种形式的社会流动，即: 竞争式流动和赞助式流动 社会控制的类型:宏观控制：是指社会利用政权、法律、政策、条令等手段对整个社会在总体上加以控制，包括政治、经济、文化和意识形态等方面的控制。微观控制：是相对于宏观控制而言，在社会生活的各个具体领域所实现的控制，这些领域涉及人们最基本的社会生活需求。制度化控制：指按照一整套条文规定，有某种组织体系加以推行的一种社会控制形式。非制度化控制：指社会控制的形式并不以明文规定的条文来实现，而是通过社会成员日常互动所形成的共识来实现。外在控制：指利用外部社会力量促使社会成员遵从社会规范。内在控制：指行为者个人将社会规范内化为自己持有的观点，从而自觉地按照社会规范的要求约束自己的社会行为。积极性控制：指利用奖赏性手段来鼓励社会成员按照社会规范行事。这些手段包括物质性奖励和精神性奖励。消极性控制：指利用惩罚性手段来防治社会成员的偏差行为。 社会问题研究理论：(1) 社会病理学：理论基础主要是社会有机体理论，它把违背道德期望的人和事物视为“病态的”，也就是社会问题。对于社会病理学来说，社会问题产生的直接原因都是人的社会化的失败，个人的社会化结果违背了社会的道德期望。(2) 社会解组理论：社会问题最有效的解决方法是尽快建立社会规范和秩序，重建社会的均衡体系。所谓社会解组，是指社会中的各种规则对约束个人的行为失去了效力，社会既不能提供给人们以预期的奖赏和回报，也不能对违规的行为加以惩罚。(3) 价值冲突理论：认为由于所处的社会经济地位和既得利益的不同，人们对同一问题可能会有不同的价值评判标准和不同的立场、态度，因此在采取某种行为措施改变某一社会现象时，常常会引起矛盾和冲突，而这种矛盾和冲突往往发生在群体之间。而所谓社会问题，是一种被相当多的人认为是偏离于他们所持有的价值观念的社会状况。这一理论的持有者认为文化价值或兴趣上的冲突是造成社会问题的根本原因，提倡研究社会实际存在的利益关系。(4) 行为偏差理论：把社会问题看作偏离社会规范的偏差行为的结果。(5) 社会构建理论：不存在客观意义上的社会问题，所谓社会问题是人们主观建构出来的，社会问题仅仅是人们对某种社会情况的界定过程的主观产物，因此研究社会问题的社会学家真正面对的研究对象不是社会问题本身，而是某种情况如何被定义为社会问题的社会建构过程及其客观条件。 家庭矛盾冲突的一种极端行为表现是: 家庭暴力 我国家庭出现了一些变迁，这些变化的主要表现有: ★★★A. 家庭规模趋于缩小B. 家庭功能有所变化C. 家庭价值观的认识趋向现代化 2021/01/22 后工业社会有五个特征：经济方面从产品经济转变为服务性经济；专业与技术人员处于主导地位；理论知识处于社会中心地位；控制技术发展,对技术进行鉴定；创造新的“智能技术” 埃里克森 对个人心理成长历程的划分1, 婴儿期, 出生到 2 岁2, 儿童早期, 2 岁到 4 岁3, 学前期(游戏期), 4 岁到 7 岁4, 勤奋期, 7 岁到 12 岁5, 青年期, 12 到 18 岁6, 成年早期, 18 到 25 岁7, 成年中期, 25 到 50 岁8, 成年晚期, 50 岁以后 现在的家庭暴力与过去相比出现的新特点是 攻击性增强，后果严重 价值冲突理论认为，造成社会问题的根本原因是 文化价值或兴趣上的冲突 社会化的主要功能包括:文化传承、社会稳定发展、个体自我完善 社会学创立的历史条件：(1)社会变革的需要(2)自然科学发展的推动(3)社会思想和社会经验研究的产物 第三部门概念：在政府组织和营利组织之外，还有一类组织，它们既不是政府的某个部门或下属组织，又不追求组织拥有者的私人利益。它介于国家和市场之间，一般统称为第三部门。特征：① 以公共利益为组织目标，向社会提供公共物品或准公共物品② 独立于政府组织③ 不以营利为组织目标④ 是自主管理的自治组织⑤ 依靠组织成员的志愿参与在现代社会的作用：① 可以提供公共部门尚未提供的公共物品② 可以满足不同人群对公共物品的多样化需求③ 可以向弱势群体提供他们所需要的物品④ 常常是更可靠的物品和服务提供渠道⑤ 公民参与的一条重要途径⑥ 是倡导公民意识和志愿精神的实践领域。","link":"/2021/01/14/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/%E7%A4%BE%E4%BC%9A%E5%AD%A6/%E7%A4%BE%E4%BC%9A%E5%AD%A6%E9%94%99%E9%A2%98%E9%9B%86/"},{"title":"社概主观题","text":"主观题梳理 主观梳理第二章 社会学研究对象 什么是社会学 社会学的特征 社会学研究的对象 社会学的功能 研究功能有哪些 教育功能 社会管理功能 社会批判功能 社会学的研究方法 社会学研究的一般程序 问卷调查法 实地研究 社会实验法 非介入性研究法 定性分析法 定量分析法 定量和定性法的不同点 结构功能论及作者 冲突理论及作者 交换理论论及作者 符号互动论及作者 第三章 社会 什么是社会 社会的基本特征 社会结构 社会结构类型 个人与社会相互关系的层次性体系 什么是社会关系 社会建设 社会管理 社会基本要素 人口数量 人口质量 人口资源 人力资源 自然资源 自然资源的特点 社会环境 社会环境的特点 第四章 文化 什么是文化 文化的特征 文化构成要素 文化结构 文化功能 习俗 道德 法律 宗教 什么是文化交流 文化多样性 文化自觉 亚文化 文化中心主义 文化相对主义 第五章 社会化 什么是社会化 社会化的主要功能 社会化的内容 社会化对个人角色能力培养的体现 社会化类型 社会化条件 社会实践的概念 社会实践的主要表现 社会化基本目标 社会化最高目标 社会角色 社会角色类型 社会角色扮演 社会角色失调 第六章 社会互动 什么是社会互动 社会互动的构成要素 社会互动理论 社会互动的形式 什么是社会互动符号 社会互动重要的符号 语言的重要性 个人空间的含义 个人空间理论 符号互动论 拟剧论 常人方法论 社会网络的含义 社会网络的特征 社会网络形态 社会网络功能 简答题2020/01/19 简述社会学方法论探讨的主要问题。(1) 社会现象的性质(2) 社会学的研究方法和基础假设(3) 价值在社会研究中的作用 简述社会角色的扮演过程。(1) 角色期待(2) 角色领悟(3) 角色实践 简述社会网络的特征。(1) 普遍性(2) 多重性(3) 滚珠性(4) 多向性(5) 隐蔽性 简述农村社区的特点。(1) 人口密度低(2) 经济活动相对简单(3) 社会结构相对简单(4) 传统农村社会变迁较缓慢 简述偏差行为的正功能(1) 有助于人们进一步认识社会规范(2) 有助于加强社会团结(3) 有助于社会预警(4) 有助于促进社会进步 简述初级群体的特征。(1) 规模小(2) 有长期的面对面互动(3) 成员的人格特征可以得到比较全面的表现(4) 成员之间的角色位置难以替代(5) 习惯、伦理道德和感情在维系体中发挥着重要作用 简述社会的特征。(1)社会以人为主体；(2) 社会以人们的物质生产活动为基础；(3) 社会以人与人的交往为纽带； 简述家庭与婚姻观念的变化。(1) 性观念多元化(2) 地位平等化(3) 行为理性化 简述社区的内涵。(1) 社区是一定的地理区域空间(2) 社区是一个社会关系网(3) 社区是集体认同的一个标志 简述社会问题防治的意义。(1) 可以有效的维护社会秩序和社会稳定，增强社会和民众的安全感(2) 可以避免和减少社会问题给社会造成的损失(3) 可以保障社会主义现代化大业(4) 可以促进社会主义精神文明建设(5) 可以改善提高有关机构的应对能力和效率 2020/01/18 简述中国早起社会学学科地位的确立（1）队伍和制度化建设：社会学队伍的形成；学校教育制度化；学术团体的建立；期刊和论著的发表。（2）社会调查的兴起。（3）马克思主义社会学的传入与实践。 简述社会学研究筹划阶段的主要工作第一，选择研究题目。有新意，要适中，可操作。第二，初步探索，收集相关文献资料，接触研究对象，做到“心中有底”。第三，建立研究假设，作出理论解释，明确概念。第四，制订研究方案，选择调查地点，确定调查对象和研究单位，确定研究方式方法，制定调查问卷、量表和访谈提纲，准备调查工具，统筹与预算研究经费。第五，组织工作，包括研究人员的组成和培训，以及与协作单位的沟通等。 简述引起调适的原因由冲突引起的调适；由社会发展或变迁引起的调适；由文化交流或迁移引起的调适。 简述群体的特征(1) 有一定数量的社会成员。(2) 有一定的为群体成员所接受的目标。(3) 有明确的成员关系，并形成归属感。(4) 有一定的行为准则。(5) 时间上具有一定的连续性。 简述社会控制的必要性社会控制的必要性首先表现在社会生活中个人与个人之间、个人与社会之间的目标不一致上。其次，社会控制的必要性表现在稳定各种社会关系上。最后，社会控制的必要性还体现在制止社会生活中各种失控现象方面。 2021/01/20 简述社会学的特征(1) 整体性(2) 综合性(3) 经验性(4) 应用性 简述如何建立与发展新型的社会关系(1) 逐步建立新型的社会主义社会关系(2) 推进社会主义精神文明建设(3) 加强党风和社会风气的建设 简述公共部门的基本特征① 公共部门向社会提供的主要是公共物品② 对公共事务的管理是公共部门的主要职能③ 掌握的资源属于公共资源④ 用来从事公共管理的权力是一种公共权力⑤ 目标在于实现公共利益。 简述社会控制的必要性① 社会生活中个人与个人之间、个人与社会之间的目标不一致上② 稳定各种社会关系上③ 制止社会生活中各种失控现象方面 简述我国社会主义现代化的特点① 四项基本原则是社会主义现代化的基本前提② 社会主义现代化是物质文明和精神文明的协调发展③ 坚持对外开放，走自力更生、艰苦奋斗的社会主义现代化道路。 2021/01/21 简述马克思和恩格斯对社会学的贡献(1)马克思将唯物主义和辩证法应用于社会历史领域，创立了历史唯物主义。历史唯物主义的基本原理是马克思主义社会学的基础理论。(2)马克思主义社会学不但有其宏观方面的理论体系，而且有其实践内容。马克思注意社会调查，把实际材料作为理论研究的必要前提，恩格斯也非常重视对工人阶级状况的社会考察。马克思和恩格斯注重社会调查的实践证明，社会调查是社会学研究的基本途径，是社会学理论的源泉。 简述继续社会化的意义(1)继续社会化是人在成年以后的社会化，或称二级社会化。(2)社会是不断变化发展的，一个人要适应未来社会的环境和要求，只有在个人与社会的交互作用中继续学习、不断提高。(3)现代社会中，人们面临着知识的增长与更新急剧加快的潮流，需要继续学习。(4)基本社会化时期的教育范围有较大的局限性，需要充实更多的社会生活经验。(5)成年人肩负发展社会文化的责任，需要更加主动地继续学习。 简述利益群体的相互关系利益群体的存在不是独立静止的，都是处于其他利益群体相互联系，相互作用的动态过程中. 简述我国户籍制度的特点(1) 以城乡化界，把人固定在自己的出生地(2) 户籍与劳动用工制度、人事档案制度和生活资源供应制度相匹配 简述全球化在一般意义上的特征① 全球化是一个客观的历史进程② 全球化是一个多维度的过程③ 全球化是世界各国的共同性与差异性相统一的客观要求④ 全球化过程是一个不断出现矛盾和冲突的过程。 2021/01/22 简述基本社会化的任务A 生理性成熟，即通过人的生理发育过程，形成完善健全的身心基础。B 社会性成年，即通过社会文化的教化与自我内化，成为具有独特个性行为能力的社会成员。 简述社会流动的意义社会流动是社会变迁的一种反映。合理的社会流动是现代化社会生存和发展必需的。① 社会化大生产客观上要求实现劳动力流动和人才流动，实现劳动力的合理配置；② 在现代社会中，传统的基于个人出身的地位获得模式正逐步被基于个人业绩的现代模式所取代，社会流动成为个人取得社会地位的重要途径；③ 社会流动加强了个人才能和成就与其社会地位之间的联系，有利于造成一种积极向上的精神，增强社会的活力；④ 社会流动有利于加强各社会集团之间的联系，消除可能存在的隔阂，促进社会成员目标方面的一致认同，从而对社会发展起积极的推动作用。 简述初级社会关系的特点(1) 最简单和初步的关系(2) 人们之间的直接互动关系，交往最密切、互相最了解和最优影响的关系 简述社区的功能经济生活、社会化、社会控制、社会参与、社会保障 简述社会控制的特点普遍性、规范性、多重性 试述可持续发展可持续发展的概念：既满足当代人的需要又不对后代人满足他们需要的能力和机会构成危害的发展。可持续发展的内在矛盾：人与自然、人与人之间的矛盾的不可调和性决定了可持续发展的内在矛盾。可持续发展的意义：强调的是环境与经济的协调发展，追求的是人与自然的和谐，意义深远的。 试述科层制的特征并分析其优点和弊端。特征：① 明确规定的固定权限；② 明确规定的职位等级；③ 执行职务建立在公文基础上；④ 职务的专业化和量才录用；⑤ 照章办事。优点：相比其它组织体系和管理方式，行政管理效率高弊端：形式方义、繁文缛节、用人不当、欠缺人情味、对外界变化反应不灵敏 2021/01/25 (201804) 简述常见的角色失调现象及其角色调试角色紧张，角色冲突，角色不清，角色中断，角色失败 试述中国城市群演进中面临的主要问题1，城市群形成过程的人口认为因素过大，行政干预过高，缺乏市场机制自然发育2，城市群形成发展受限于现存行政体制的束缚3，城市群的人口和经济总量在全国的比重不够高4，城市群内部结构不完善缺乏中间环节5，城市空间分布不均衡，人口和经济分布不协调，产业结构重叠严重 试述社会问题防治的战略措施1，解放和发展生产力2，改革上层建筑和意识形态3，发展科学防治技术4，完善社会保障制度5，建立社会预警系统6，发挥社会舆论监督作用 简述实证主义方法论的基本观点(1) 遵循自然科学的客观规律(2) 提倡经验研究和社会调查(3) 以数学和统计为取向，注重量化的研究方法 简述自然资源在社会发展中的地位提供了生产生活的资料影响社会生产部门的布局和发展方向影响社会生产部门发展速度 简述集体行为的特征群众性，自发性，非组织化，非制度化 简述社会互动的构成因素(1) 必须要有两个或两个以上的互动主体(2) 互动主体必须发生某种形式上的接触(3) 参与互动各方有意识考虑行动符号所代表的意义 简述社会问题防治的意义(1) 有效维护社会秩序和社会稳定(2) 避免和减少社会问题给社会造成的损失(3) 保障社会主义现代化大业(4) 促进社会主义精神文明假设(5) 改善、提高有关机构的应对能力和效率 试述新时代社会建设的内涵(1) 解决人民关系的利益问题,推进社会体制改革,是经济发展成果更多的体现在改善民生上(2) 公平公正的正确的处理人与人人与社会之间的各种利益关系(3) 促进科学发展和社会和谐 试述社区发展的原则民主原则,民众需要原则,自力原则,自上而下和自下而上相结合的原则,物质文明、精神文明和政治文明建并重的原则 试述全球化对中国的挑战及应对策略全球化对中国的冲击和挑战:中国经济增长过于依赖贸易,霸权主义、强权政治等影响世界和平的因素使得我们面临的国际环境不太乐观面对全球化挑战的应对策略:明确中国在全球化进程中的位置,不断解放思想、深化改革、发展自己,增强总和国力确保国家安全 简述怎样做好实地研究(1) 搜索相关文献,了解研究对象背景(2) 制定实地研究方案(3) 做好个体或小组的定性访谈(4) 尊重对方,做好观察记录(5) 分析综合,撰写研究报告 筒述网络对青少年社会化产生的正面影响(1) 为青少年的教育提供了选择权(2) 有助于青少年更好的了解社会(3) 为青少年提供了很好地与人沟通的环境(4) 开阔了青少年的视野 简述社会学的社会批评功能(1) 社会学参与社会必须实事求是的进行理论分析,提出客服和解决问题的意见和建议(2) 社会批判的目的是通过矛盾的分析,促进社会的稳定与发展(3) 社会学应该敢于拿起批评的武器,促进社会的进步和发展 简述消费社会的特征(1) 消费成为社会核心(2) 消费水平和规模不断扩张(3) 消费主义盛行 简述社会问题与个人困扰的区别(1) 社会问题所牵涉的事情超出个人的局部环境(2) 社会问题涉及的是公众(3) 社会问题具有公众的特点,常常包含着制度上、结构上的危机 试述文化自觉的意义和内容意义:(1) 文化自觉指生活在一定文化中的人对自己的文化有”自知之明”,对他人文化有”识人之明”;(2) 当代中国处于转型时期,提高文化自觉性,增强文化意识,促进社会发展,以显得尤为迫切;内容:(1) 文化自觉关注中国现代化的反思;(2) 文化自觉关注文化断裂的主题再造;(3) 文化自觉提出了美美与共的价值诉求; 试述失范理论的基本观点(1) 默顿提出的失范理论存在两种观点,一种是社会对个人追求目标的规范,另一种是对个人追求目标所使用手段的规范(2) 社会成员完成了社会规范的目标,但社会无法提供实现这些目标的合乎规范的手段(3) 失范理论的建立是用于解释偏差行为的产生(4) 社会失范会使人们处于失范性紧张状态,为缓解这种紧张,默顿认为人们可能有五种适应的方式,即遵从、革新、形式主义、退缩主义和反叛 试述影响中国社会流动的因素与机制因素: 人口因素、自然因素、地区发展因素、制度因素、政策因素和个人因素机制: 工业化和科学技术进步(根本动力); 城镇化; 农村经济体制的改革","link":"/2021/01/20/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/%E7%A4%BE%E4%BC%9A%E5%AD%A6/%E7%A4%BE%E6%A6%82%E4%B8%BB%E8%A7%82%E9%A2%98/"},{"title":"闭包","text":"[译]发现 JavaScript 中闭包的强大威力 原文地址： Discover the power of closures in JavaScript原文作者： Cristi Salcescu译者： wcflmy 闭包是一个可以访问外部作用域的内部函数，即使这个外部作用域已经执行结束。 作用域作用域决定这个变量的生命周期及其可见性。 当我们创建了一个函数或者 {} 块，就会生成一个新的作用域。需要注意的是，通过 var 创建的变量只有函数作用域，而通过 let 和 const 创建的变量既有函数作用域，也有块作用域。 嵌套作用域在 Javascript 中函数里面可以嵌套函数，如下： 12345678(function autorun(){ let x = 1; function log(){ console.log(x); } log();})();复制代码 log() 即是一个嵌套在 autorun() 函数里面的函数。在 log() 函数里面可以通过外部函数访问到变量 x。此时，log() 函数就是一个闭包。 闭包就是内部函数，我们可以通过在一个函数内部或者 {} 块里面定义一个函数来创建闭包。 外部函数作用域内部函数可以访问外部函数中定义的变量，即使外部函数已经执行完毕。如下： 1234567(function autorun(){ let x = 1; setTimeout(function log(){ console.log(x); }, 10000);})();复制代码 并且，内部函数还可以访问外部函数中定义的形参，如下： 12345678(function autorun(p){ let x = 1; setTimeout(function log(){ console.log(x);//1 console.log(p);//10 }, 10000);})(10);复制代码 外部块作用域内部函数可以访问外部块中定义的变量，即使外部块已执行完毕，如下： 1234567{ let x = 1; setTimeout(function log(){ console.log(x); }, 10000);}复制代码 词法作用域词法作用域是指内部函数在定义的时候就决定了其外部作用域。 看如下代码： 1234567891011121314(function autorun(){ let x = 1; function log(){ console.log(x); }; function run(fn){ let x = 100; fn(); } run(log);//1})();复制代码 log() 函数是一个闭包，它在这里访问的是 autorun() 函数中的 x 变量，而不是 run 函数中的变量。 闭包的外部作用域是在其定义的时候已决定，而不是执行的时候。 autorun() 的函数作用域即是 log() 函数的词法作用域。 作用域链每一个作用域都有对其父作用域的引用。当我们使用一个变量的时候，Javascript引擎 会通过变量名在当前作用域查找，若没有查找到，会一直沿着作用域链一直向上查找，直到 global 全局作用域。 示例如下： 123456789101112131415let x0 = 0;(function autorun1(){ let x1 = 1; (function autorun2(){ let x2 = 2; (function autorun3(){ let x3 = 3; console.log(x0 + &quot; &quot; + x1 + &quot; &quot; + x2 + &quot; &quot; + x3);//0 1 2 3 })(); })();})();复制代码 我们可以看到，autorun3() 这个内部函数可以访问其自身局部变量 x3 ，也可以访问外部作用域中的 x1 和 x2 变量，以及全局作用域中的 x0 变量。即：闭包可以访问其外部(父)作用域中的定义的所有变量。 外部作用域执行完毕后当外部作用域执行完毕后，内部函数还存活（仍在其他地方被引用）时，闭包才真正发挥其作用。譬如以下几种情况： 在异步任务例如 timer 定时器，事件处理，Ajax 请求中被作为回调 被外部函数作为返回结果返回，或者返回结果对象中引用该内部函数 考虑如下的几个示例： Timer1234567(function autorun(){ let x = 1; setTimeout(function log(){ console.log(x); }, 10000);})();复制代码 变量 x 将一直存活着直到定时器的回调执行或者 clearTimeout() 被调用。 如果这里使用的是 setInterval() ，那么变量 x 将一直存活到 clearInterval() 被调用。 译者注：原文中说变量 x 一直存活到 setTimeout() 或者 setInterval() 被调用是错误的。 Event1234567(function autorun(){ let x = 1; $(&quot;#btn&quot;).on(&quot;click&quot;, function log(){ console.log(x); });})();复制代码 当变量 x 在事件处理函数中被使用时，它将一直存活直到该事件处理函数被移除。 Ajax1234567(function autorun(){ let x = 1; fetch(&quot;http://&quot;).then(function log(){ console.log(x); });})();复制代码 变量 x 将一直存活到接收到后端返回结果，回调函数被执行。 在已上几个示例中，我们可以看到，log() 函数在父函数执行完毕后还一直存活着，log() 函数就是一个闭包。 除了 timer 定时器，事件处理，Ajax 请求等比较常见的异步任务，还有其他的一些异步 API 比如 HTML5 Geolocation，WebSockets , requestAnimationFrame()也将使用到闭包的这一特性。 变量的生命周期取决于闭包的生命周期。被闭包引用的外部作用域中的变量将一直存活直到闭包函数被销毁。如果一个变量被多个闭包所引用，那么直到所有的闭包被垃圾回收后，该变量才会被销毁。 闭包与循环闭包只存储外部变量的引用，而不会拷贝这些外部变量的值。 查看如下示例： 123456789function initEvents(){ for(var i=1; i&lt;=3; i++){ $(&quot;#btn&quot; + i).click(function showNumber(){ alert(i);//4 }); }}initEvents();复制代码 在这个示例中，我们创建了 3 个闭包，皆引用了同一个变量 i，且这三个闭包都是事件处理函数。由于变量 i 随着循环自增，因此最终输出的都是同样的值。 修复这个问题最简单的方法是在 for 语句块中使用 let 变量声明，这将在每次循环中为 for 语句块创建一个新的局部变量。如下： 123456789function initEvents(){ for(let i=1; i&lt;=3; i++){ $(&quot;#btn&quot; + i).click(function showNumber(){ alert(i);//1 2 3 }); }}initEvents();复制代码 但是，如果变量声明在 for 语句块之外的话，即使用了 let 变量声明，所有的闭包还是会引用同一个变量，最终输出的还是同一个值。 闭包与封装性封装性意味着信息隐藏。 函数与私有状态通过闭包，我们可以创建拥有私有状态的函数，闭包使得状态被封装起来。 工厂模式与私有原型对象我们先来看一个通过原型创建对象的常规方式，如下： 1234567891011let todoPrototype = { toString : function() { return this.id + &quot; &quot; + this.userName + &quot;: &quot; + this.title; }}function Todo(todo){ let newTodo = Object.create(todoPrototype); Object.assign(newTodo, todo); return newTodo;}复制代码 在这个例子中，todoPrototype 原型对象是一个全局对象。 我们可以通过闭包，只用创建原型对象一次，也能够被所有 Todo 函数调用所公用，并且保证其私有性。示例如下： 1234567891011121314let Todo = (function createTodoFactory(){ let todoPrototype = { toString : function() { return this.id + &quot; &quot; + this.userName + &quot;: &quot; + this.title; } } return function(todo){ let newTodo = Object.create(todoPrototype); Object.assign(newTodo, todo); return newTodo; }})();let todo = Todo({id : 1, title: &quot;This is a title&quot;, userName: &quot;Cristi&quot;, completed: false });复制代码 这里，Todo() 就是一个拥有私有状态的函数。 工厂模式与私有构造函数查看如下代码： 1234567891011let Todo = (function createTodoFactory(){ function Todo(spec){ Object.assign(this, spec); } return function(spec){ let todo = new Todo(spec); return Object.freeze(todo); }})();复制代码 这里，Todo() 工厂函数就是一个闭包。通过它，不管是否使用 new ，我们都可以创建不可变对象，原型对象也只用创建一次，并且它是私有的。 123456let todo = Todo({title : &quot;A description&quot;});todo.title = &quot;Another description&quot;;// Cannot assign to read only property 'title' of objecttodo.toString = function() {};//Cannot assign to read only property 'toString' of object复制代码 而且，在内存快照中，我们可以通过构造函数名来识别这些示例对象。 翻译功能与私有 map通过闭包，我们可以创建一个 map，在所有翻译调用中被使用，且是私有的。 示例如下： 1234567891011let translate = (function(){ let translations = {}; translations[&quot;yes&quot;] = &quot;oui&quot;; translations[&quot;no&quot;] = &quot;non&quot;; return function(key){ return translations[key]; }})();translate(&quot;yes&quot;); //oui复制代码 自增生成器函数通过闭包，我们可以创建自增生成器函数。同样，内部状态是私有的。示例如下： 123456789101112131415function createAGenerate(count, increment) { return function(){ count += increment; return count; }}let generateNextNumber = createAGenerate(0, 1);console.log(generateNextNumber()); //1console.log(generateNextNumber()); //2console.log(generateNextNumber()); //3let generateMultipleOfTen = createAGenerate(0, 10);console.log(generateMultipleOfTen()); //10console.log(generateMultipleOfTen()); //20console.log(generateMultipleOfTen()); //30复制代码 译者注：原文中依次输出 0,1,2,0,10,20 是有误的，感谢@Round 的指正 对象与私有状态以上示例中，我们可以创建一个拥有私有状态的函数。同时，我们也可以创建多个拥有同一私有状态的函数。基于此，我们还可以创建一个拥有私有状态的对象。 示例如下： 123456789101112131415161718192021222324function TodoStore(){ let todos = []; function add(todo){ todos.push(todo); } function get(){ return todos.filter(isPriorityTodo).map(toTodoViewModel); } function isPriorityTodo(todo){ return task.type === &quot;RE&quot; &amp;&amp; !task.completed; } function toTodoViewModel(todo) { return { id : todo.id, title : todo.title }; } return Object.freeze({ add, get });}复制代码 TodoStore() 函数返回了一个拥有私有状态的对象。在外部，我们无法访问私有的 todos 变量，并且 add 和 get 这两个闭包拥有相同的私有状态。在这里，TodoStore() 是一个工厂函数。 闭包 vs 纯函数闭包就是那些引用了外部作用域中变量的函数。 为了更好的理解，我们将内部函数拆成闭包和纯函数两个方面： 闭包是那些引用了外部作用域中变量的函数。 纯函数是那些没有引用外部作用域中变量的函数，它们通常返回一个值并且没有副作用。 在上述例子中，add() 和 get() 函数是闭包，而 isPriorityTodo() 和 toTodoViewModel() 则是纯函数。 闭包在函数式编程中的应用闭包在函数式编程中也应用广泛。譬如，underscore 源码中 函数相关小节 中的所有函数都利用了闭包这一特性。 A function decorator is a higher-order function that takes one function as an argument and returns another function, and the returned function is a variation of the argument function — Javascript Allongé 装饰器函数也使用了闭包的特性。 我们来看如下 not 这个简单的装饰器函数： 123456function not(fn){ return function decorator(...args){ return !fn.apply(this, args); }}复制代码 decorator() 函数引用了外部作用域的 fn 变量，因此它是一个闭包。 如果你想知道更多关于装饰器相关的知识，可以查看这篇文章。 垃圾回收在 Javascript 中，局部变量会随着函数的执行完毕而被销毁，除非还有指向他们的引用。当闭包本身也被垃圾回收之后，这些闭包中的私有状态随后也会被垃圾回收。通常我们可以通过切断闭包的引用来达到这一目的。 在这个例子中，我们首先创建了一个 add() 闭包。 1234567let add = (function createAddClosure(){ let arr = []; return function(obj){ arr.push(obj); }})();复制代码 随后，我们又定义了两个函数： addALotOfObjects() 往闭包变量 arr 中加入对象。 clearAllObjects() 将闭包函数置为 null 。 并且两个函数皆作为事件处理函数： 12345678910111213function addALotOfObjects(){ for(let i=1; i&lt;=10000;i++) { add(new Todo(i)); }}function clearAllObjects(){ if(add){ add = null; }}$(&quot;#add&quot;).click(addALotOfObjects);$(&quot;#clear&quot;).click(clearAllObjects);复制代码 当我点击 Add 按钮时，将往 闭包变量 arr 中加入 10000 个 todo 对象，内存快照如下： 当我点击 Clear 按钮时，我们将闭包引用置为 null 。随后，闭包变量 arr 将被垃圾回收，内存快照如下： 避免全局变量在 Javascript 中，我们很容易创建出全局变量。任何定义在函数和 {} 块之外的变量都是全局的，定义在全局作用域中的函数也是全局的。 这里以定义创建不同对象的工厂函数为例。为了避免将所有的工厂函数都放在全局作用域下，最简单的方法就是将他们挂在 app 全局变量下。 示例如下： 123456let app = Loader();app.factory(function DataService(args){ return {}});app.factory(function Helper(args){ return {}});app.factory(function Mapper(args){ return {}});app.factory(function Model(args){});复制代码 app.factory() 方法还可以将不同的工厂函数归类到不同的模块中。下面这个示例就是将 Timer 工厂函数归类到 tools 模块下。 12app.factory(&quot;tools&quot;)(function Timer(args){ return {}});复制代码 我们可以在 app 对象上暴露一个 start 方法来作为应用的入口点，通过 回调函数中 factories 参数来访问这些工厂函数。这里 start() 函数只能被调用一次，如下： 1234567891011app.start(function startApplication(factories){ let helper = factories.Helper(); let dataService = factories.DataService(); let model = factories.Model({ dataService : dataService, helper : helper, timer : factories.tools.Timer() });});复制代码 A Composition Root is a (preferably) unique location in an application where modules are composed together. Mark Seemann loader 对象让我们来将 app 完善为一个 loader 对象，示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function Loader(){ let modules = Object.create(null); let started = false; function getNamespaceModule(modulesText){ let parent = modules; if(modulesText){ let parts = modulesText.split('.'); for(let i=0; i&lt;parts.length; i++){ let part = parts[i]; if (typeof parent[part] === &quot;undefined&quot;) { parent[part] = Object.create(null); } parent = parent[part]; } } return parent; } function addFunction(namespace, fn){ if(typeof(fn) !== &quot;function&quot;) { throw &quot;Only functions can be added&quot;; } let module = getNamespaceModule(namespace); let fnName = fn.name; module[fnName] = fn; } function addNamespace(namespace){ return function(fn){ addFunction(namespace, fn) } } function factory(){ if(typeof(arguments[0]) === &quot;string&quot;){ return addNamespace(arguments[0]); } else { return addFunction(null, arguments[0]); } } function start(startApplication){ if(started){ throw &quot;App can be started only once&quot;; } startApplication(Object.freeze(modules)); started = true; } return Object.freeze({ factory, start });};let app = Loader();复制代码 factory() 方法用于添加新的工厂函数到内部变量 modules 中。 start() 方法则会调用回调函数，在回调函数中访问内部变量。 通过 factory() 定义工厂函数，将 start() 作为整个应用中调用各种工厂函数生成不同对象的唯一入口点，这是如此简洁优雅的方式。 在这里，factory 和 start 都是闭包。 总结闭包是一个可以访问外部作用域中变量的内部函数。 这些被引用的变量直到闭包被销毁时才会被销毁。 闭包使得 timer 定时器，事件处理，AJAX 请求等异步任务更加容易。 可以通过闭包来达到封装性。 最后，想获得更多关于 Javascript 函数相关知识，可以查看以下文章： Discover Functional Programming in JavaScript with this thorough introduction Discover the power of first class functions How point-free composition will make you a better functional programmer Here are a few function decorators you can write from scratch Make your code easier to read with Functional Programming","link":"/2021/05/13/js/closure/"},{"title":"自检清单","text":"[一份的前端工程师的自检清单] 以下文章来源于code秘密花园 ，作者ConardLi 开篇前端开发是一个非常特殊的行业，它的历史实际上不是很长，但是知识之繁杂，技术迭代速度之快是其他技术所不能比拟的。 到现在为止，前端工程师已经成为研发体系中的重要岗位之一。可是，与此相对的是，我发现极少或者几乎没有大学的计算机专业愿意开设前端课程，更没有系统性的教学方案出现。大部分前端工程师的知识，其实都是来自于实践和工作中零散的学习。 一、JavaScript基础 前端工程师吃饭的家伙，深度、广度一样都不能差。 1、变量和类型 JavaScript规定了几种语言类型 JavaScript对象的底层数据结构是什么 Symbol类型在实际开发中的应用、可手动实现一个简单的 Symbol JavaScript中的变量在内存中的具体存储形式 基本类型对应的内置对象，以及他们之间的装箱拆箱操作 理解值类型和引用类型 null和 undefined的区别 至少可以说出三种判断 JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用 出现小数精度丢失的原因， JavaScript可以存储的最大数字、最大安全数字， JavaScript处理大数字的方法、避免精度丢失的方法 2、原型和原型链 理解原型设计模式以及 JavaScript中的原型规则 instanceof的底层实现原理，手动实现一个 instanceof 实现继承的几种方式以及他们的优缺点 至少说出一种开源项目(如 Node)中应用原型继承的案例 可以描述 new一个对象的详细过程，手动实现一个 new操作符 理解 es6class构造以及继承的底层实现原理 3、作用域和闭包 理解词法作用域和动态作用域 理解 JavaScript的作用域和作用域链 理解 JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题 this的原理以及几种不同使用场景的取值 闭包的实现原理和作用，可以列举几个开发中闭包的实际应用 理解堆栈溢出和内存泄漏的原理，如何防止 如何处理循环的异步操作 理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理 4、执行机制 为何 try里面放 return， finally还会执行，理解其内部机制 JavaScript如何实现异步编程，可以详细描述 EventLoop机制 宏任务和微任务分别有哪些 可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法 使用 Promise实现串行 Node与浏览器 EventLoop的差异 如何在保证页面运行流畅的情况下处理海量数据 5、语法和API 理解 ECMAScript和 JavaScript的关系 熟练运用 es5、 es6提供的语法规范， 熟练掌握 JavaScript提供的全局对象（例如 Date、 Math）、全局函数（例如 decodeURI、 isNaN）、全局属性（例如 Infinity、 undefined） 熟练应用 map、 reduce、 filter 等高阶函数解决问题 setInterval需要注意的点，使用 settimeout实现 setInterval JavaScript提供的正则表达式 API、可以使用正则表达式（邮箱校验、 URL解析、去重等）解决常见问题 JavaScript异常处理的方式，统一的异常处理方案 二、HTML和CSS1、HTML 从规范的角度理解 HTML，从分类和语义的角度使用标签 常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式 元信息类标签( head、 title、 meta)的使用目的和配置方法 HTML5离线缓存原理 可以使用 CanvasAPI、 SVG等绘制高性能的动画 2、CSS CSS盒模型，在不同浏览器的差异 CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用 at规则 CSS伪类和伪元素有哪些，它们的区别和实际应用 HTML文档流的排版规则， CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理 水平垂直居中的方案、可以实现 6种以上并对比它们的优缺点 BFC实现原理，可以解决的问题，如何创建 BFC 可使用 CSS函数复用代码，实现特殊效果 PostCSS、 Sass、 Less的异同，以及使用配置，至少掌握一种 CSS模块化方案、如何配置按需加载、如何防止 CSS阻塞渲染 熟练使用 CSS实现常见动画，如渐变、移动、旋转、缩放等等 CSS浏览器兼容性写法，了解不同 API在不同浏览器下的兼容性情况 掌握一套完整的响应式布局方案 2、手写 手写图片瀑布流效果 使用 CSS绘制几何图形（圆形、三角形、扇形、菱形等） 使用纯 CSS实现曲线运动（贝塞尔曲线） 实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点 三、计算机基础 关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要 1、编译原理 理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序 正则表达式的匹配原理和性能优化 如何将 JavaScript代码解析成抽象语法树( AST) base64的编码原理 几种进制的相互转换计算方法，在 JavaScript中如何表示和转换 2、网络协议 理解什么是协议，了解 TCP/IP网络协议族的构成，每层协议在应用程序中发挥的作用 三次握手和四次挥手详细原理，为什么要使用这种机制 有哪些协议是可靠， TCP有哪些手段保证可靠交付 DNS的作用、 DNS解析的详细过程， DNS优化原理 CDN的作用和原理 HTTP请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么 HTTP所有状态码的具体含义，看到异常状态码能快速定位问题 HTTP1. 1、 HTTP2. 0带来的改变 HTTPS的加密原理，如何开启 HTTPS，如何劫持 HTTPS请求 理解 WebSocket协议的底层原理、与 HTTP的区别 3、设计模式 熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等 发布订阅模式和观察者模式的异同以及实际应用 可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用 四、数据结构和算法 据我了解的大部分前端对这部分知识有些欠缺，甚至抵触，但是，如果突破更高的天花板，这部分知识是必不可少的，而且我亲身经历——非常有用！ 1、JavaScript编码能力 多种方式实现数组去重、扁平化、对比优缺点 多种方式实现深拷贝、对比优缺点 手写函数柯里化工具函数、并理解其应用场景和优势 手写防抖和节流工具函数、并理解其内部原理和应用场景 实现一个 sleep函数 2、手动实现前端轮子 手动实现 call、apply、bind 手动实现符合 Promise/A+规范的 Promise、手动实现 asyncawait 手写一个 EventEmitter实现事件发布、订阅 可以说出两种实现双向绑定的方案、可以手动实现 手写 JSON. stringify、 JSON. parse 手写一个模版引擎，并能解释其中原理 手写 懒加载、 下拉刷新、 上拉加载、 预加载等效果 3、数据结构 理解常见数据结构的特点，以及他们在不同场景下使用的优缺点 理解 数组、 字符串的存储原理，并熟练应用他们解决问题 理解 二叉树、 栈、 队列、 哈希表的基本结构和特点，并可以应用它解决问题 了解 图、 堆的基本结构和使用场景 4、算法 可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗 至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度 了解递归和循环的优缺点、应用场景、并可在开发中熟练应用 可应用 回溯算法、 贪心算法、 分治算法、 动态规划等解决复杂问题 前端处理海量数据的算法方案 五、运行环境我们需要理清语言和环境的关系： ECMAScript描述了 JavaScript语言的语法和基本对象规范 浏览器作为 JavaScript的一种运行环境，为它提供了：文档对象模型（ DOM），描述处理网页内容的方法和接口、浏览器对象模型（ BOM），描述与浏览器进行交互的方法和接口 Node也是 JavaScript的一种运行环境，为它提供了操作 I/O、网络等 API 1、浏览器API 浏览器提供的符合 W3C标准的 DOM操作 API、浏览器差异、兼容性 浏览器提供的浏览器对象模型 ( BOM)提供的所有全局 API、浏览器差异、兼容性 大量 DOM操作、海量数据的性能优化(合并操作、 Diff、 requestAnimationFrame等) 浏览器海量数据存储、操作性能优化 DOM事件流的具体实现机制、不同浏览器的差异、事件代理 前端发起网络请求的几种方式及其底层实现、可以手写原生 ajax、 fetch、可以熟练使用第三方库 浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型 浏览器提供的几种存储机制、优缺点、开发中正确的选择 浏览器跨标签通信 2、浏览器原理 各浏览器使用的 JavaScript引擎以及它们的异同点、如何在代码中进行区分 请求数据到请求结束与服务器进行了几次交互 可详细描述浏览器从输入 URL到页面展现的详细过程 浏览器解析 HTML代码的原理，以及构建 DOM树的流程 浏览器如何解析 CSS规则，并将其应用到 DOM树上 浏览器如何将解析好的带有样式的 DOM树进行绘制 浏览器的运行机制，如何配置资源异步同步加载 浏览器回流与重绘的底层原理，引发原因，如何有效避免 浏览器的垃圾回收机制，如何避免内存泄漏 浏览器采用的缓存方案，如何选择和控制合适的缓存方案 3、Node 理解 Node在应用程序中的作用，可以使用 Node搭建前端运行环境、使用 Node操作文件、操作数据库等等 掌握一种 Node开发框架，如 Express， Express和 Koa的区别 熟练使用 Node提供的 API如 Path、 Http、 ChildProcess等并理解其实现原理 Node的底层运行原理、和浏览器的异同 Node事件驱动、非阻塞机制的实现原理 六、框架和类库 轮子层出不穷，从原理上理解才是正道 1、TypeScript 理解 泛型、 接口等面向对象的相关概念， TypeScript对面向对象理念的实现 理解使用 TypeScript的好处，掌握 TypeScript基础语法 TypeScript的规则检测原理 可以在 React、 Vue等框架中使用 TypeScript进行开发 2、React React和 vue选型和优缺点、核心架构的区别 React中 setState的执行机制，如何有效的管理状态 React的事件底层实现机制 React的虚拟 DOM和 Diff算法的内部实现 React的 Fiber工作原理，解决了什么问题 ReactRouter和 VueRouter的底层实现原理、动态加载实现原理 可熟练应用 ReactAPI、生命周期等，可应用 HOC、 render props、 Hooks等高阶用法解决问题 基于 React的特性和原理，可以手动实现一个简单的 React 3、Vue 熟练使用 Vue的 API、生命周期、钩子函数 MVVM框架设计理念 Vue双向绑定实现原理、 Diff算法的内部实现 Vue的事件机制 从 template转换成真实 DOM的实现机制 2、多端开发 单页面应用（ SPA）的原理和优缺点，掌握一种快速开发 SPA的方案 理解 Viewport、 em、 rem的原理和用法，分辨率、 px、 ppi、 dpi、 dp的区别和实际应用 移动端页面适配解决方案、不同机型适配方案 掌握一种 JavaScript移动客户端开发技术，如 ReactNative：可以搭建 ReactNative开发环境，熟练进行开发，可理解 ReactNative的运作原理，不同端适配 掌握一种 JavaScript PC客户端开发技术，如 Electron：可搭建 Electron开发环境，熟练进行开发，可理解 Electron的运作原理 掌握一种小程序开发框架或原生小程序开发 理解多端框架的内部实现原理，至少了解一个多端框架的使用 3、数据流管理 掌握 React和 Vue传统的跨组件通信方案，对比采用数据流管理框架的异同 熟练使用 Redux管理数据流，并理解其实现原理，中间件实现原理 熟练使用 Mobx管理数据流，并理解其实现原理，相比 Redux有什么优势 熟练使用 Vuex管理数据流，并理解其实现原理 以上数据流方案的异同和优缺点，不情况下的技术选型 4、实用库 至少掌握一种 UI组件框架，如 antd design，理解其设计理念、底层实现 掌握一种图表绘制框架，如 Echart，理解其设计理念、底层实现，可以自己实现图表 掌握一种 GIS开发框架，如百度地图 API 掌握一种可视化开发框架，如 Three. js、 D3 工具函数库，如 lodash、 underscore、 moment等，理解使用的工具类或工具函数的具体实现原理 5、开发和调试 熟练使用各浏览器提供的调试工具 熟练使用一种代理工具实现请求代理、抓包，如 charls 可以使用 Android、 IOS模拟器进行调试，并掌握一种真机调试方案 了解 Vue、 React等框架调试工具的使用 七、前端工程 前端工程化：以工程化方法和工具提高开发生产效率、降低维护难度 1、项目构建 理解 npm、 yarn依赖包管理的原理，两者的区别 可以使用 npm运行自定义脚本 理解 Babel、 ESLint、 webpack等工具在项目中承担的作用 ESLint规则检测原理，常用的 ESLint配置 Babel的核心原理，可以自己编写一个 Babel插件 可以配置一种前端代码兼容方案，如 Polyfill Webpack的编译原理、构建流程、热更新原理， chunk、 bundle和 module的区别和应用 可熟练配置已有的 loaders和 plugins解决问题，可以自己编写 loaders和 plugins 2、nginx 正向代理与反向代理的特点和实例 可手动搭建一个简单的 nginx服务器、 熟练应用常用的 nginx内置变量，掌握常用的匹配规则写法 可以用 nginx实现请求过滤、配置 gzip、负载均衡等，并能解释其内部原理 3、开发提速 熟练掌握一种接口管理、接口 mock工具的使用，如 yapi 掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题 理解 TDD与 BDD模式，至少会使用一种前端单元测试框架 4、版本控制 理解 Git的核心原理、工作流程、和 SVN的区别 熟练使用常规的 Git命令、 git rebase、 git stash等进阶命令 可以快速解决 线上分支回滚、 线上分支错误合并等复杂问题 5、持续集成 理解 CI/CD技术的意义，至少熟练掌握一种 CI/CD工具的使用，如 Jenkins 可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括 Web应用、移动客户端应用、 PC客户端应用、小程序、 H5等等） 八、项目和业务1、后端技能 了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言 掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库 2、性能优化 了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案 了解常见的 Web、 App性能优化方案 SEO排名规则、 SEO优化方案、前后端分离的 SEO SSR实现方案、优缺点、及其性能优化 Webpack的性能优化方案 Canvas性能优化方案 React、 Vue等框架使用性能优化方案 3、前端安全 XSS攻击的原理、分类、具体案例，前端如何防御 CSRF攻击的原理、具体案例，前端如何防御 HTTP劫持、页面劫持的原理、防御措施 4、业务相关 能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题 能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题 可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性 九、学习提升 拥有自己的技术博客，或者在一些博客平台上拥有自己的专栏 定期的将知识进行总结，不断完善自己的知识体系 尽量将自己的知识转换成真实的产出，不要仅仅停留在书面理解层面，更重要的是实际应用 坚持输出 自己的代码，不要盲目的扎进公司业 十、技术之外 这部分可能比上面九条加起来重要！ 了解互联网人员术语：CEO、 CTO、 COO、 CFO、 PM、 QA、 UI、 FE、 DEV、 DBA、 OPS等 了解互联网行业术语：B2B、 B2C、 C2C、 O2O等 掌握互联网行业沟通、问答、学习的 有一定的 &quot;PPT&quot;能力 有一定的理财意识，至少了解储蓄、货币基金、保险、指数基金、股票等基本的理财知识 掌握在繁重的工作和长期的电脑辐射的情况下保持健康的方法，建立正确的养生知识体系 小结学习一门知识，最好先阅读官方文档，把所有的 API大概浏览一遍，再继续看大佬们总结的进阶知识，什么东西是搬运过来的，什么是干货，一目了然。 希望你阅读本篇文章后可以达到以下几点： 1、从知识清单中找到自己的知识盲点与欠缺 2、具有知识体系化的思想，开始建立自己的知识体系 3、阅读文章时将知识归类到知识体系中，并不断完善自己的知识体系 4、从文章中获取到了有用的资源","link":"/2021/05/13/js/selfTest/"},{"title":"当代中国政治制度(考试大纲)","text":"00315 当代中国政治制度 考核知识点与考核要求(考试大纲) 第一章 绪论(一) 政治制度和当代中国政治制度1 识记：(1) 制度； (2) 政治制度； (3) 政治制度特点。 2 领会：(1) 政治制度与社会经济制度的关系； (2) 政治制度与社会文化制度的关系； (3) 当代中国的根本政治制度和基本政治制度。 (二) 坚持和完善当代中国政治制度1 识记：(1) 党和国家领导制度的主要弊端； (2) 政治体制。 2 领会：(1) 十一届三中全会以来中国政治体制改革的主要成就； (2) 政治体制改革的总目标； (3) 学习、研究当代中国政治制度的意义。 第二章 当代中国国家制度(一) 当代中国国家制度的建立和发展1 识记：(1) 《共同纲领》； (2) 政务院； (3) 综合经济基础 2 领会：(1) 我国的过渡时期及过渡时期国家政权的过渡性质； (2) 中国中央国家机关体系； (3) 中国政治制度的主要发展时期； (4) 第一个历史发展时期，中国政治制度的发展具有的主要特点； (5) “文化大革命”中，中国政治制度发展的特点。 3. 应用：(1) “文化大革命”结束后，我国社会主义政治制度逐步完善体现在哪些方面？ (二) 当代中国的国体1 识记：(1) 国家实质； (2) 人民民主专政。 2 领会：(1) 近代中国的社会阶级状况和阶级特点； (2) 人民民主专政思想逐步形成的过程； (3) 中国的人民民主专政的特点。 3. 应用：(1) 结合实际说明人民民主专政的历史任务； (2) 怎样理解社会主义民主是新型民主？ 第三章 当代中国国家形式和国家机构(一) 当代中国国家形式1 识记：(1) 国家形式； (2) 国家结构形式； (3) 政体； (4) 单一制； (5) 联邦制。 2 领会：(1) 中国国家机构设置的基本原则； (2) 国家的一切权力属于人民的原则和含义； (3) 议行合一原则； (4) 民主集中制原则。 3.应用：(1) 国家机构的产生与发展和社会经济、文化的发展的紧密关系。 (2) 国家机构变革的依据及社会主义国家机构发展、变革的基本方向和要求。 第四章 当代中国选举制度(一) 当代中国选举制度的形成与发展1 识记：(1) 选举； (2) 选举原则； (3) 选举制度。 2 领会：(1) 社会主义选举制度与资本主义选举制度的主要区别； (2) 我国的《选举法》； (3) 我国 1979 年《选举法》颁布以来的几次修正。 (二) 当代中国选举制度的原则1 识记：(1) “一人一票制”； (2) 直接选举； (3) 间接选举； (4) 秘密投票。 2.领会：(1) 选举权和被选举权的普遍原则； (2) 我国选举制的平等原则； (3) 直接选举和间接选举； (4) 秘密投票的原则。 3.应用：我国选举制度的基本原则怎样体现了社会主义民主？ (三) 直接选举的组织和程序1 识记：(1) 选举委员会； (2) 选区； (3) 选民登记。 2 领会：(1) 选举委员会的组成与职权； (2) 我国划分选区的基本要求； (3) 选民登记的主要工作； (4) 直接选举时，人民代表候选人的提出和确定； (5) 人民代表候选人接受； (6) 投票类型； (7) 代表候选人当选资格。 (四) 间接选举的组织和程序1 识记：(1) 全国人大代表名额； (2) 省、自治区、直辖市人民代表大会名额基数及总名额的确定； (3) 设区的市、自治州的人大代表名额的基数及总名额的确定； (4) 县级以上人大代表选举差额比例； (5) 预选。 2 领会：(1) 主持间接选举的机构； (2) 全国人大代表名额的分配； (3) 台湾省出现全国人大的代表名额的确定与选举； (4) 香港、澳门特别行政区选举全国人大代表； (5) 省、自治区、直辖市选举全国人大代表时，代表候选人的提出和确定； (6) 人民解放军选举全国人大代表； (7) 间接选举时，代表候选人的当选资格。 (五) 人大代表的法律地位、职权及监督、罢免1 识记：(1) 人大代表的法律地位； (2) 视察。 2 领会：(1) 各级人民代表大会会议期间人大代表的职权； (2) 各级人民代表大会闭会期间人大代表的职权； (3) 《代表法》对人大代表执行职务的保障规定； (4) 人大代表人身特别保护权； (5) 罢免人大代表的程序。 (3) 应用：从人大代表的地位和职权分析《代表法》怎样体现了“一切权力属于人民”？ 第五章 当代中国人民代表大会制度(上)(一) 人民代表大会制度是我国的根本政治制度1 领会：(1) 我国人民代表大会制度的建立； (2) 人民代表大会制度是适合我国国情的根本政治制度。 (二) 全国人民代表大会1 识记：(1) 全国人大每届任期； (2) 全国人民代表大会预备会议。 2 领会：(1) 宪法规定全国人大在我国政权机关体系中的地位； (2) 全国人大的立法权； (3) 全国人大选举、决定国家机关领导人的职权； (4) 全国人大对重大问题的决定权； (5) 全国人大对国家机关的监督权及监督形式； (6) 全国人民代表大会会议期间的各代表团组成； (7) 全国人民代表大会会议的主持及其任务； (8) 全国人民代表大会会议的主要议程； (9) 向全国人民代表大会提出议案的机构、组织、人员； (10) 关于全国人民代表大会议案的审议、表决和公布的规定； (11) 我国各国家机构领导人候选人的提名； (12) 全国人民代表大会主席团。 3 应用：全国人民代表大会行使的职权包括哪些方面？ (三) 全国人民代表大会常务委员会的地位、组成、任期、职权1 识记：(1) 全国人大常委会； (2) 委员长会议； (3) 代表资格审查委员会。 2 领会：(1) 全国人大常委会委员长会议； (2) 全国人大常委会职权； (3) 全国人大常委会的立法权； (4) 可以向全国人大常委会提出议案的国家机构、组织、人员； (5) 全国人大常委会对议案审议、表决、公布的规定； (6) 质询案的提出和答复； (7) 全国人大常委会设立的工作机构。 3 应用：(1) 全国人大常委会的法律地位和职权是什么？ (2) 中华人民共和国各级人大常委会行使监督权的有关内容。 (五) 全国人民代表大会专门委员会(1) 全国人大设立的专门委员会； (2) 全国人大专门委员会的主要工作。 第六章 当代中国人民代表大会制度(下)(一) 地方各级人民代表大会1 领会：(1) 地方各级人民代表大会的法律地位； (2) 地方各级人民代表大会任期； (3) 地方各级人民代表大会职权； (4) 地方各级人民代表大会制度地方性法规的职权； (5) 县级以上地方人民代表大会会议的主要内容； (6) 可以向地方人大提出议案的国家机关、组织和成员； (7) 地方人大选举产生地方国家机关领导。 2 应用：地方人大与地方其他国家机关的关系。 (二) 县级以上地方各级人大常委会领会：(1) 县级以上地方各级人大常委会组成人员名额的规定； (2) 县级以上地方各级人大常委会具有的职权； (3) 县级以上地方各级人大常委会主任会议的组成和职权； (4) 可以向地方各级人大常委会提议案的国家机关和组织、成员； (5) 地方各级人大设立的工作机构。 (三) 地方各级人大专门委员会领会：(1) 哪些地方人大可以设立专门委员会； (2) 地方各级人大专门委员会的产生； (3) 地方各级人大专门委员会具有的职权。 (四) 乡级人民代表大会1 识记：(1) 乡级人大的地位； (2) 乡级人大的职权； (3) 乡级人大的任期。 2 领会：(1) 乡级人大主席、副主席职权； (2) 乡级人大主席团。 (五) 坚持和完善人民代表大会制度1 领会：(1) 人民代表大会制度与西方议会制的主要区别； (2) 十一届三中全会以来，我国人民代表大会制度的加强。 2 应用：如何坚持和完善人民代表大会制度？ 第七章 当代中国国家元首制度(一) 国家元首1 识记：(1) 制度； (2) 制度； 2 领会：(1) 君主制政体和共和制政体国家元首的产生方法； (2) 国家元首法律地位的主要类型； (3) 国家元首行使的主要职权； (4) 我国国家主席制度的建立。 3 应用：我国国家主席制度的恢复及重要意义。 (二) 国家主席的产生、任期、职权领会：(1) 法律对国家主席候选人资格规定； (2) 中国国家主席的产生； (3) 中国国家主席的任期； (4) 中国国家主席的法律地位； (5) 中国国家主席行使的对内职权； (6) 中国国家主席行使的对外职权。 第八章 当代中国中央行政制度(一) 国务院的法律地位、组成和任期1 识记：(1) 国务院职权的含义； (2) 法律对国务院组成的具体规定。 2 领会：(1) 国务院的性质及其在国家整个政治制度体系中的地位； (2) 对国务院的组成。 (二) 国务院的职权1 识记：(1) 国务院职权的含义； (2) 法律对国务院职权的具体规定。 2 领会：(1) 《宪法》和《国务院组织法》对国务院职权进行规定的意义； (2) 建国以来我国国务院职权变化的基本特点。 3 应用：国务院职能转变的主要原因是什么？ (三) 国务院的机构设置1 识记：(1) 建国以来，国务院机构设置的沿革； (2) 现阶段国务院机构设置的基本情况。 2 领会：(1) 建国以来，国务院机构设置的变化； (2) 国务院几次较大的机构改革的特点。 3 应用：社会主义市场经济体制的建立与国务院机构改革有些什么关系？ (四) 国务院领导体制和会议制度1 识记：(1) 国务院领导体制的含义； (2) 国务院行政首长负责制的特点； (3) 国务院的会议制度； (4) 依法行政。 2 领会：(1) 国务院领导体制的重要意义； (2) 行政首长负责制同民主集中制的关系； (3) 国务院会议制度的意义； (4) 国务院工作规则； (5) 政务信息公开的内容； (6) 国务院工作的指导思想。 第九章 当代中国一般地方行政制度(一) 地方各级人民政府的法律地位、组成、任期1 识记：(1) 地方各级人民政府的性质和地位； (2) 法律关于地方各级人民政府的组成的规定； (3) 地方各级人民政府的任期规定。 2 领会：(1) 地方各级人民政府的双重性质； (2) 地方各级人民政府的组成和产生； (3) 地方各级人民政府任期规定和意义。 (二) 地方各级人民政府的职权1 识记：(1) 《宪法》所规定的地方各级人民政府职权； (2) 《地方组织法》所规定的地方各级人民政府职权。 2 领会：(1) 地方各级人民政府职权的不同权源； (2) 地方各级人民政府权力规定的意义。 3 应用：地方政府管理地方社会、经济事务的主要职权。 (三) 地方各级人民政府的机构设置和领导体制1 识记：(1) 地方各级人民政府的机构设置的不同规定； (2) 地方行政首长负责制的含义。 2 领会：(1) 地方各级人民政府的行政首长负责制的实施及意义。 (2) 地方各级人民政府的会议制度； (3) 地方政府机构改革； (4) 地方政府的行政原则。 3 应用：我国地方政府机构改革的必要性和意义是什么？ (四) 当代中国中央政府和地方政府关系领会：(1) 中央政府和地方政府关系的概念和实质； (2) 中央政府和地方政府关系的基本原则； (3) 中央政府和地方政府的现状。 第十章 当代中国民族区域自治制度(一) 民族区域自治制度的基本内容1 识记：(1) 民族区域自治； (2) 民族问题。 2 领会：(1) 社会主义时期的民族问题。 (2) 中国解决民族问题的基本原则； (3) 中国解决民族问题的基本政策； (4) 民族区域自治政策制定的客观依据； (5) 中国民族区域自治理论的形成和发展。 3 应用：民族区域自治制度的基本特点。 (二) 中国民族自治区域的自治1 领会：(1) 民族自治地方的建立。 (2) 民族自治地方的性质和任务。 (3) 自治机关的组成。 (4) 自治机关的自治权。 (5) 民族自治地方的人民法院和人民检察院。 (6) 民族自治地方的成效。 2 应用：民族区域自治的优越性。 第十一章 当代中国特别行政区制度(一) “一国两制”的含义1 识记：“一国两制”的概念。 2 领会：“一国两制”的提出。 3 应用：“一国两制”的意义。 (二) 特别行政区的法律地位1 识记：(1) 中央人民政府在特别行政区行使的权力； (2) 特别行政区享有的高度自治权。 2 领会：特别行政区的法律地位。 3 应用：香港、澳门特别行政区建立的重大意义。 (三) 特别行政区长官的法律地位、任职资格1 识记：特别行政区长官的任职资格及选举、任命。 2 领会：特别行政区长官的法律地位。 (四) 特别行政区长官的职权1 识记：特别行政区长官职权的内容。 (五) 特别行政区行政机构的设置、职权与主要官员的任职资格1 识记：(1) 特别行政区行政机构； (2) 特别行政区行政机构的主要职权。 2 领会：(1) 特别行政区行政机构主要官员的任职资格； (2) 廉政公署与审计署的职能。 (六) 特别行政区公务员制度1 识记：(1) 特别行政区公务员制度的基本内容； (2) 特别行政区公务员的任职资格。 (七) 特别行政区立法机关的职权1 识记：(1) 立法机关的职权； (2) 立法会议员的权力。 2 领会：(1) 立法会议员的任职资格与条件； (2) 立法会主席的产生与职权； (3) 立法机关的任期。 第十二章 当代中国司法制度(一) 当代中国审批制度1 识记：(1) 审批制度； (2) 审批机关； (3) 独立审判原则； (4) 依法审判和未经审判对任何人不得确定有罪的原则； (5) 平等审判原则； (6) 民主审判原则； (7) 合议制度； (8) 回避制度； (9) 陪审制度； (10) 审判监督制度； (11) 两审终审制度； (12) 司法解释权； (13) 司法行政权； (14) 司法建议权。 2 领会：(1) 审判机关职权； (2) 审判程序； (3) 审判制度的原则； (4) 审判制度的内容； (5) 人民反应职权； (6) 人民法院组织体系； (7) 法官任职资格； (8) 法官选任方式。 3 应用：中国审批制度和法官制度的改革。 (二) 当代中国检察制度1 识记：(1) 检察制度； (2) 检察机关； (3) 审判监督权； (4) 侦查监督权； (5) 执行监督权； (6) 立案侦查权； (7) 公诉权； (8) 民事、行政诉讼参与权； (9) 检察独立原则； (10) 双重领导原则。 2 领会：(1) 检察制度性质； (2) 检察机关职权； (3) 检察机关领导体制； (4) 检察机关活动原则； (5) 检察官任职资格； (6) 检察官任免形式。 3 应用：中国检察制度和检察官制度的改革。 (三) 当代中国侦查制度领会：(1) 侦查制度； (2) 侦查任务； (3) 侦查程序； (4) 侦查强制措施； (5) 侦查机关。 (四) 当代中国律师制度1 识记：(1) 律师制度； (2) 律师从业资格； (3) 律师执业资格； (4) 执业律师种类； (5) 律师协会； (6) 律师事务所； (7) 国资律师事务所； (8) 合作律师事务所； (9) 合伙律师事务所； (10) 个人律师事务所。 2 领会：(1) 律师管理体制； (2) 律师事务所的责任； (3) 律师事务所的种类； (4) 律师法律活动范围； (5) 律师的权利； (6) 律师的义务。 (五) 当代中国公证制度1 识记：(1) 公证； (2) 公证业务范围； (3) 公证的效力； (4) 公证机构设置、 2 领会：公证程序。 3 应用：如何完善我国的公证制度。 (六) 当代中国法律援助制度1 识记：(1) 法律援助制度； (2) 法律援助机构。 2 领会：法律援助的保障与支持。 3 应用：如何健全与完善我国的法律援助制度。 第十三章 当代中国军事制度(一)军事领导体制领会：(1) 中央军事委员会； (2) 中央军委总部机关； (3) 中央军委军兵种领导机关； (4) 军区领导机关； (5) 人民武装警察部队； (6) 国防部。 (二)军队的干部制度识记：(1) 军衔； (2) 军官； (3) 文职干部。 领会：(1) 军衔制度； (2) 军官制度； (3) 文职干部制度。 (三)兵役制度识记：兵役制度 领会：(1) 中国兵役制的沿革； (2) 新兵役制度的基本内容； (3) 现役的平时征集和战时动员。 (四)军队政治工作制度领会：(1) 政治工作的地位、内容和原则； (2) 党委工作制度； (3) 政治委员制度； (4) 政治机关制度； (5) 军内民主制度； (6) 党支部建在连队的制度。 应用：我军政治工作的特点和意义。 第十四章 当代中国政党制度(一) 中国共产党在国家政治生活中的核心领导地位1 识记：(1) 政党； (2) 政党制度 2 领会：(1) 中国共产党的领导地位是中国近百年历史发展的必然结果； (2) 中国共产党的性质； (3) 党的政治领导、组织领导、思想领导。 (二) 中国共产党的组织制度和组织机构1 识记：(1) 民主集中制； (2) 党的全国代表大会； (3) 党的中央委员会； (4) 党组。 2 领会：(1) 党的民主集中制； (2) 中国共产党全国代表大会的职权； (3) 党的基层组织担负的主要任务； (4) 党中央与各地方党委的关系； (5) 上级党组织与下级党组织的关系； (6) 党的纪律处分； (7) 党的纪律检查机关； (8) 党的各级纪律检查委员会的主要任务。 (9) 党组的任务。 3 应用：(1) 坚持党的民主集中制的重要意义； (2) 加强党的纪检工作对反腐倡廉的重要作用。 (三) 加强中国共产党执政能力建设，提高中国共产党的领导水平和执政水平1 领会：改革和完善中国共产党领导体制和工作机制，最重要的是规范党与人大、政府、政协和人民团体的关系。 2 应用：改革干部人事制度的主要内容和意义。 (四)中国共产党领导的多党合作制1 领会：(1) 中国共产党领导的多党合作制的形成； (2) 中国共产党领导的多党合作制的特点和优势； (3) 中国共产党与民主党派合作的基本方针； (4) 为什么必须坚持中国共产党的领导。 2 应用：(1) 中国共产党领导的多党合作制是我国长期实行的一项基本政治制度。 (2) 中国共产党领导的多党合作制的重要现实意义。 (五) 中国的民主党派1 识记：(1) 中国国民党革命委员会； (2) 中国民主同盟； (3) 中国民主建国会； (4) 中国民主促进会； (5) 中国农工民主党； (6) 中国致公党； (7) 九三学社； (8) 台湾民主自治同盟。 2 领会：在社会主义初级阶段中国民主党派的性质。 3 领会：中国民主党派参政方式：参政议政；民主协商；民主监督。 第十五章 当代中国政治协商制度(一) 中国人民政治协商制度的形成与发展1 识记：(1) 政治协商制度 2 领会：(1) 中国形成政治协商制度的特殊条件； (2) 中国人民政治协商会议经历的发展阶段。 (二) 中国人民政治协商会议的性质、职能和任务1 识记：(1) 人民政协； (2) 参政议政。 2 领会：(1) 社会主义时期中国人民政治协商会议的性质。 (2) 人民政协的主要职能。 (3) 人民政协的政治协商职能； (4) 人民政协的民主监督职能。 3 应用：人民政协在现阶段的主要任务。 (三) 中国人民政治协商会议的组织原则和组织机构领会：(1) 人民政协委员具有的权利和义务； (2) 政协全国委员会行使的职权； (3) 政协全国委员会设置的专门委员会； (4) 人民政协地方各级委员会行使的职权。 第十六章 当代中国基层民主制度(一) 职工代表大会制度1 识记：(1) 职工代表大会； (2) 工会。 2 领会：(1) 《职代会条例》规定职工代表大会的性质； (2) 《职代会条例》规定职工代表大会的组织机构和工作制度； (3) 职代会具有的职权。 3 应用：在市场经济条件下职代会与“新三会”的关系。 (二) 村民委员会1 识记：(1) 村民委员会性质； (2) 村民会议； (3) 《村民委员会组织法》 (4) 村民委员会组织原则； (5) 村民委员会任期。 2 领会：(1) 《村民委员会组织法》关于村民委员会组成人员的规定； (2) 村民委员会成员的选举产生； (3) 罢免村民委员会成员的程序； (4) 村民委员会具有的职权； (5) 须经村民会议讨论决定的事项； (6) 村民会议的职权。 3 应用：(1) 关于村务公开制度的规定和意义。 (2) 村民委员会与农村基层党组织的关系； (3) 村民委员会与乡镇基层政府的关系。 (三) 城市社区居民委员会1 识记：(1) 社区居民委员会； (2) 社区； (3) 社区服务； (4) 《居民委员会组织法》； (5) 社区居民会议。 2 领会：(1) 社区居民委员会的性质； (2) 社区居民委员会的任务； (3) 社区居民委员会的组成； (4) 社区居民委员会成员的产生； (5) 社区居民委员会具有的职权； (6) 社区居民自治的内容。 3 应用：(1) 加强城市社区建设的重要性； (2) 城市社区建设的基本原则； (3) 城市社区建设的主要任务。","link":"/2021/03/01/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/%E5%BD%93%E4%BB%A3%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB%E5%88%B6%E5%BA%A6/%E5%88%B6%E5%BA%A6%E5%A4%A7%E7%BA%B2/"},{"title":"公共政策总结","text":"[这里是文章说明] 第一章 公共政策学的学科要素1、政策研究、政策分析、公共政策的概念、内涵以及三者的关系 1、政策研究与政策分析的比较 在学科发展的早期阶段，学者认为两者是同一概念，在学科发展的现阶段，主流认识认为两者在内涵上有明显的差异： —-研究主体不同。政策研究的主体是学者；政策分析的主体是政府及其他公共组织的专业人员，以及民间政策研究人员。 —-研究重点或范围不同。政策研究的重点或范围是政策过程、政策系统、政策影响等；政策分析的重点或范围是政策制定。 —-研究目的或目标不同。政策研究的主要目的是建构政策理论，推动学科发展；政策分析的主要目的是有效解决社会问题。 —-对研究成果的评价不同。政策研究的成果主要是得到学界同仁的认同；政策分析的成果是得到相关决策层的采纳。 公共政策学的定义及内涵 定义：运用科学的方法去研究政策内容、政策系统、政策过程，探索公共政策的规律，并运用这些规律运用到政策实践，以期改进政策系统，提高政策质量。 内涵： —学科对象是公共政策以及与之紧密相关的政策系统、政策过程； —学科方法论具有准科学特征，表现在理性与非理性思考结合，定量与定性分析结合，实证研究与理论研究结合； —学科性质：跨学科性。综合性、交叉性； —学科目的：理论研究与应用研究结合，以期改进政策系统，提高政策质量，更好地促进学科发展和更好地解决社会问题。 政策研究、政策分析与公共政策学的关系 公共政策学是政策研究与政策分析的总和。 2、公共政策学的学科要素构成：研究对象、研究方法、概念体系 研究对象—公共政策：具体的个别的政策；政策群、政策链；政策一般 —政策系统 —政策过程 研究方法 —研究程序的设计：拟定选题—确定假设—收集资料—分析资料—提出对策—撰写报告 —资料收集法：一手资料与二手资料的收集方法 —研究视角和路径：系统分析法；矛盾分析法；历史分析法；比较分析法；个案分析法；经济分析法；制度分析法；价值分析法 概念体系 —核心概念 —次级概念 —边际概念 公共政策制定系统内部的结构：线性结构，职能结构，线性——参谋结构，矩阵结构 3、公共政策学的产生时间、标志、创立者及其对公共政策学的界定 (1)学科诞生标志：《政策科学：视野与方法的近期发展》(勒纳、拉斯韦尓；1951 年) (2)学科创立者：拉斯韦尓 拉斯韦尓对公共政策学的界定： —学科产生发展前提必然以民主的政治体制为前提； —学科研究方法主张逻辑实证； —学科性质具有跨学科性； —学科研究主体：学者和政府 —学科研究对象：公共政策、社会变迁、社会发展 拉斯韦尓认为政策过程依次为： 信息—建议—制定—执行—运用—评价—终止公共政策学的发展 (1)公共政策学产生时期：20 世纪 50 年代初 (2)公共政策学初步发展时期：20 世纪 50 年代和 60 年代前半期 (3)公共政策学发展的第二个阶段：20 世纪 60 年代后期到 20 世纪 80 年代末。 —进入第二个发展阶段的标志：德洛尔《重新审查公共政策的制定过程》、《政策科学探索：概念与使用》、《政策科学构想》 —政策科学在第二个发展阶段的成就：方法论多样(公共选择方法、博弈论、个案研究等)；研究重点由政策制定转向政策执行、评估和终结；开始对政策从价值和伦理视角去研究；开始采用比较研究。 (4)公共政策学的近期发展：20 世纪 90 年代以来 该阶段所取得的进展： —课题选择的伦理、管理、政府改革取向； —方法论的非科学取向；(80 年起) —公共政策学的建制化：学会成立以及学术刊物面世(70)；专门研究机构的建立(70 兰德研究学院)；大学专业以及课程设置(70) 4、公共政策学中国化的含义 (1)强调在引进、消化和吸收当代国外的公共政策学研究成果的基础上，坚持以马克思主义为指导，立足中国的国情，紧密结合当代中国的公共决策实践，取其所需，为我所用。 (2)吸收公共政策学的概念、理论等，在马克思主义的指导下，对当代中国的公共政策问题进行实证研究。 (3)考察、总结当代中国公共决策实践，在马克思主义的指导下，对公共政策学的概念、理论、模型等进行重构和创新。 第二章 公共政策与政策工具1、公共政策概念的定义及内涵 (1)著名学者对公共政策概念的不同界定 —艾斯顿：公共政策是政府机构与周围环境之间的关系； —戴伊：公共政策是一个政府选择要做的任何事或者它选择不去做的事情； —安德森：由政府机关和政府官员所制定的政策； —拉斯维尔：公共政策是一种含有目标、价值与策略的大型计划； —伊斯顿：公共政策是对一个社会进行的权威性的价值分配 (2)公共政策概念的定义 公共政策：是公共权力机关为了解决公共问题、实现公共目标和公共利益，而经过政治过程制定、选择的方案。 (3)公共政策的涵义 —公共政策是决策的一种特殊形态； —公共政策是由公共权力机关制定，因此具有强制性和权威性； —公共政策是经过政治过程而拟定方案、优化方案、最后选择方案的结果； —公共政策的三大要素是：公共问题、公共目标和公共利益； —公共政策的实质是对价值进行的权威性的分配； —公共政策有积极形式和消极形式。 2、公共政策产生的初始条件。 —公共问题的形成 —公共决策机关的产生 —公共强制机构的出现 提醒：注意“公共政策产生的三要素”与“公共政策的三要素”的区分。 3、公共政策的本质 (1)公共政策的认识论本质就是公共政策是理论与实践的中间环节。体现在： —理论是政策的指导思想,政策是理论的具体化。理论的内容影响或决定政策的内容，理论内容不同可能导致政策不同；理论的正确与否，决定政策的成败。 —政策是实践经验的提升并在实践中得到完善和发展。 (2)公共政策的社会本质是公共政策是公共性与偏好性的对立统一 —公共政策是公共权力机关为着一定目标而进行的社会资源配置和社会价值的分配。所谓一定目标是自利性、阶级性和公共性的混合物；社会资源的配置是指政策主体为实现一定政策目标而进行的人力、物力、财力资源的调配；所谓社会价值的分配是指生产资料、生活资料、权力、财富等在不同社会群体间的分布，一般情况下，政府倾向于把社会价值分配给与其价值取向一致的社会群体。 —公共政策的公共性体现为公共政策是公共权力机关为解决公共问题实现公共利益而制定的。 —公共政策的偏好性是指政策过程，即政策问题认定、政策方案制定、政策执行、政策评估以及政策调整与终结等每个环节在一定程度上均是政策主体基于一定偏好而做出的选择。这种基于偏好的选择要受到政策主体价值观、自利以及不同利益诉求者力量大小的影响。 —公共政策的公共性与偏好性的对立统一体现为利益相关者之间的互动推动。 4、公共政策的基本功能 (1)管制功能 所谓管制就是政策主体通过制定政策使政策对象不做什么来达到政策目的。管制有积极性管制和消极性管制之分：积极性管制就是通过政策使政策对象不能、不敢做政策主体不愿意发生的行为；消极性管制就是对政策对象做出的行为进行处罚，使其以后不再发生。 (2)引导功能 引导功能就是通过政策对政策对象的观念、行为以及事物发展进行引导。其作用结果有正向引导和负向引导，如果政策根据事物发展规律进行引导，就会收到正向引导之效，反之就会是负向功能。 (3)调控功能 运用政策对社会公共事务中出现的各种社会矛盾进行调节和控制。 (4)分配功能 公共政策的实质就是对社会价值和资源进行权威性的分配，一般来讲社会价值和资源分配易倾向于那些与政策主体偏好一致的政策对象。 5、公共政策的基本特征 (1)公共政策具有政治性、权威性与强制性 (2)公共政策是公共性与偏好性的对立统一 (3)公共政策是应然与实然的统一 (4)公共政策是回应性与普遍性的统一 6、元政策、基本政策与部门政策之间的关系。 7、公共政策的形式划分类型。 8、政策工具的定义、类型及其划分意义。 政策工具：为实现一定政策目标而采取的各种措施、策略、方法、机制、以及配置的人力、资金、资源等手段。 政策工具的类型 (1)加拿大学者郝赖特和腊梅什依据政策工具的强制性程度划分为：自愿性工具、混合性工具、强制性工具 (2)艾尔莫尔把政策工具划分为：命令性、激励性、能力构建、系统变迁。 政策工具类型划分的意义 意义：政策工具的分类政策工具比较选择、配置的基础，科学的划分有助于政策主体准确地把握各种政策工具的特性，对政策工具做出恰当的选择和合理的配置，进而有效促进政策目标的实现。 9、公共政策与法之间的关系。 政策与法的相同点 —在法治国家，公共政策要具有合法性，必须程序合法和内容合法。 —法和政策都是调整人的行为或社会关系的准则、标准； —在法治国家，法和政策的制定可以具有相同的程序 政策与法的不同—获得法的形态的公共政策与法的不同 (1)侧重不同：政策侧重按照一定规则进行价值分配和资源配置；法侧重纠察、校正价值分配和资源配置中有关方违背既定规则的行为； (2)执行的主动性不同：政策执行具有主动性；除了刑事诉讼和违宪审查，司法一般实行“不告不理”原则； (3)对权利、义务的统一性不同：法对其对象一般是规定权利与义务的统一；而政策对政策对象的权利与义务有时并不对称； (4)对实质与形式的要求不同：法的适用要求形式与实质的统一；而政策执行强调实质重于形式； (5)强制性程度不同：法的强制性重于政策的强制性； (6)对稳定性程度的要求不同：法的稳定性要强于政策； (7)干预范围不同：政策的干预范围更大。 —未获得法的形态的公共政策与法的不同 未获得法的形态的公共政策具有获得法的形态的公共政策的全部特质，但其文本不具有法的特质和规定。 关系：政策是法的来源与动力，对法的制定和执行具有方向性的指导作用；法为政策提供制定和执行保障，转化为法律的政策具有更强的稳定性。 第三章 政策系统与公共决策体制1、政策系统的构成 (1)定义：是由政策主体系统、政策支持系统和政策反馈系统等所构成的有机整体。 (2)政策系统的子系统构成 —主体系统：政策制定系统：在政策系统中处于核心地位；政策执行系统；间接主体系统 —支持系统：信息传播系统：政策系统的神经，政策咨询系统，政策监控系统，政策评估系统 —反馈系统：多层次、多网络是政策反馈系统的特点 2、政策系统的环境(包括一般环境和工作环境) (1)政策系统的一般环境(又称生态环境) —定义：指作用和影响公共政策的所有外部条件的总和。 —构成： ① 地理自然环境：对政策系统和政策内容有着巨大、持久的影响。 ② 经济环境：对公共政策具有决定性的影响。 ③ 政治法治环境： ④ 社会文化环境： ⑤ 国际环境： (2)政策系统的工作环境(又称主体认知环境) 定义：指政策系统在制定和实施某项公共政策的过程中直接地对政策系统运行产生影响的政策环境。 3、政府权力、政府职能与公共政策的关系 (1)政府权力、政府职能的二重性决定了公共政策的二重性 —政府权力就是政府行使的公共权力； —政府行使公共权力必须履行政府职能； —政府职能有政治统治和社会管理，政治统治具有阶级性，社会管理具有社会性； —政府行使权力就是通过制定公共政策和执行公共政策来履行政府职能； —公共政策是政府推行政治统治的基本工具； —公共政策是政府实施社会管理的重要手段。 (2)政府权力性质和大小，政府职能结构和多少决定公共政策的性质、类型和数量。 4、政府能力与公共政策的关系 (1)政府能力的定义：指政府在其职责范围内，运用公共权力，制定政策和执行政策的能力。 (2)政府能力包括政策制定和政策执行两个层次的能力。 (3)公共政策能力对政府能力有双重影响：如果政府正确制定并有效实施公共政策，那么就会提升政府能力；相反，则降低政府能力。因此，能否在其职责范围内正确地制定并有效地实施公共政策，是判断政府能力强弱的根本标准。 治理能力与公共政策关系 (1)治理能力的定义：指政府运用公共权威，协调各类主体(如：公共部门、私人部门和第三部门等)，维持公共秩序，满足公共需要，维护、实现和增进公共利益的能力。 (2)在治理理论下，政府主要是承担公共政策的制定。 (3)在治理理论下，公共政策的主体多元。 (4)在治理理论下，公共政策的权力运行是双向的。 (5)治理理论更为强调政府的政治责任。 5、公共利益的内涵 (1)界定：公共利益是指能代表一个社会里大多数公民的最好的利益。 (2)重要性：谋求和增进公共利益是一切政策的出发点，是公共政策的灵魂和归宿，是公共政策获得合法性的基础。 (3)公共利益的确定 —直接利益与间接利益 —现实利益与未来利益 —形式利益与内容利益 6、公民与公共政策的关系(包括公民的双重身份以及参与公共政策的途径) (1)公民与公共政策 —公民与公共政策的紧密联系：公共政策过程的基轴是公共权力与公民的关系。 —公民的双重身份：既是公共政策主体，又是公共政策客体。只有公民充分参与政策过程且政策结果体现和维护公民利益时，公民的双重身份才会得到有机的统一。 —公民参与并影响公共政策的途径 ① 以国家主权者身份，采取全民公决，直接行使个人权利；② 通过推选代表参与政策过程，而间接行使个人权利；③ 通过参加利益集团等组织，借助团体力量来影响公共政策；④ 通过个人的知识为公共政策提供指导； ⑤ 通过制造社会舆论来影响公共政策； ⑥ 采取消极抵抗或不合作，或使用各种威胁和抗拒的方式来影响公共政策。 7、大众传媒与公共政策的关系(以政策过程为逻辑) (1)大众传播与政策制定 —提出公共问题并推动问题认定，表现在：促进信息交流，释放社会多元需求，及时发现和提出公共问题；催生热点和焦点公共问题。 —有效影响政策议程的设置，体现在：推动公众议程尽快转化成政策议程；价值取向和利益导向的引领者。 —影响公共政策的抉择 (2)大众传播与政策执行和监控 —为政策执行提供良好的舆论支持； —监督政策执行过程。(3)大众传播与政策评估与调整 —及时收集和反馈公众对政策的意见； —以自己的方式进行政策评估； —推动公共政策的及时调整。 8、公共决策规则 (1)公共决策体制的定义：指围绕决策权的分配与配置而设计出来的包括决策程序、决策规则和决策方式等制度的总称。 (2)公共决策权的配置 —首长制与委员会制； —集权制与分权制； (3)公共决策的规则 —全体一致规则，又称一票否决制； —简单多数规则，又称相对多数规则； —绝对多数规则，又称过半数规则、比例多数制。 —中国的公共决策的基本规则是民主集中制 (4)公共决策体制的类型 —总统制：美国 —议会制：英国 —半总统半议会制：法国 —超级总统制：俄罗斯 —委员会制：瑞士 —人民代表大会制：中国 第四章 政策过程及其理论模型1、政策过程理论模型的含义及其认识论意义； 理论模型的定义 理论模型又称概念模型，指由一组概念或命题按照其相互间的本质联系而组织在一起的，具有逻辑结构严整特点的网络或框架。 模型的认识论意义 (1)借助模型有助于认识研究对象的本质规定； (2)借助模型有助于发现研究对象的规律；(3)借助模型有助于明确研究工作的重点和优先顺序。 2、揭示认识论本质的理性主义模型、渐进主义模型、规范最适模型与混合扫描模型、政治系统模型的含义及运用； 理性主义模型，又称完全理性模型 (1)人性假设：把决策者视为“理性人” (2)决策目标：追求最佳决策 (3)主要内容 —决策者要解决一个既定的、明确的问题； —决策者能对决策目标、价值等的重要性进行排序； —决策者能够想到解决问题的所有方案； —决策者能对每个方案进行投入产出的分析； —决策者基于每个方案分析的基础上选择一个最优方案。 有限理性模型，又称理性优化模型 (1)理论提出者：西蒙 (2)假设：把决策者视为“有限理性” (3)决策目标：追求满意决策 渐进主义模型 (1)提出者：林德布洛姆 (2)主要内容：公共政策制定就是政策制定者根据经验对现行政策的局部调整。 综合模型(试图调和理性主义模型与渐进主义模型) (1)规范最适模型：提出者是德洛尔 (2)混合扫描模型：提出者是埃齐奥尼 3、揭示社会本质的机构—制度模型、集团模型、精英模型的含义及运用 精英模型 (1)主要观点：公共政策就是社会中的精英的价值或利益偏好。 (2)该模型认为：公共政策在本质上总是统治阶级的政策。 集团模型 (1)提出者：莱瑟姆 (2)核心观点：公共政策就是各利益集团之间相互竞争、斗争的结果。 其主要内容如下： —政治过程的决定性阶段就是制定公共政策，政治过程就是各集团争取影响公共政策的过程； —公共政策制定过程就是各利益集团相互竞争的过程； —在现代政治生活中，各利益集团要获得政策资源的竞争不可避免； —公共政策一般反映在支配地位的利益集团的利益。 政治系统模型 (1)提出、阐释和完善政治系统分析的是：戴维.伊斯顿 (2)政治系统模型认为决策主体是：政治系统 (3)该模型主要观点：认为政策过程就是输入—决策—输出—反馈的过程 (4)重要性：该模型是公共政策分析中最具有解释力，并且具有普适性的一个模型 机构-制度模型 (1)主要观点：现存国家机构以及各种制度均会对公共政策的制定有一定影响。 (2)该模型在公共政策分析中应用最广泛而又最缺乏理论色彩。 4、中国公共政策过程模型的含义及特点中国政策过程模型的内容 “上下来去”政策过程模型：这是基于中国经验而构建的政策过程模型。其主要内容是：政策制定是一个自下而上的过程，政策执行是一个自上而下的过程，政策主体与政策客体的关系是从群众中来，到群众中去。 上下来去”政策过程模型的特点 特点：具有容纳性和开放性。“上下来去”政策过程模型的科学追求是科学决策，而且该模型又是由一些亚模型，如领导–群众模型等组成，因此，以科学决策为根本诉求的其他决策理论，决策模型都可以引进、整合、吸纳到该模型中，同时西方现代社会调查的一些方法与手段等也可以在该模型中得以应用。 5、公共决策过程的科学化与民主化。 由于政策问题数量增加以及政策难度加大，因此需要公共决策科学化、民主化 (1)决策过程的理性化：指公共政策制定者要以科学理论为指导，经过合法程序来制定公共政策，获得公共政策的合法性和强制性。 (2)决策过程的专业化：由于政策问题复杂性加大了决策难度，因此，为了填补决策者的职责与实际能力的差距，需要专业技术人员参与到决策过程，专业技术人员在决策过程发挥的作用主要体现为在政策议程确立、政策目标确立、政策方案制定与论证、政策执行，以及政策效果评估方面从专业角度给予指导、建议。 (3)决策过程的科学化：决策者和决策参与者要采用合理的决策程序，充分利用现代科学技术的成果，从实际出发，对政策问题进行实事求是的分析，在此基础上科学地决策。 (4)决策过程民主化：在决策过程中，通过构建民主的体制、民主程序，充分保障公民、社会团体、研究组织的参与，公共政策制定要充分反映民意。 第五章 政策问题与议程设定1、政策问题的定义、内涵及属性 (1)政策问题的定义 指统治集团或社会上大多数人感觉到现实中出现的某种情况与他们的利益、期望、价值和规范有相当严重的矛盾或冲突，进而通过社会团体或组织活动要求社会公共组织和政府采取行动加以解决，并被后者纳入政策议程的社会问题或公共问题。 (2)政策问题的内涵 —客观事实或客观情景存在 —问题被察觉 —问题表现为现实与期望的差距或冲突 —借助团体或组织活动 —政府和社会公共组织有必要采取行动来加以解决 政策问题的属性 —关联性与公共性 —客观性与主观性 —历史性与动态性 2、问题分析方法 —边界分析法：对公共问题的本质属性和实际范围进行分析、界定。如贫困问题，留守儿童问题 —多角度分析：个人角度、组织角度、技术角度 —类别分析：包括逻辑划分与逻辑归并 —层次分析：可能原因、合理原因、可诉原因 —头脑风暴法：指由一定数量的人从各自角度来讨论一个公共问题，通过设置规则来产生对公共问题的大量观点、看法的一种方法。其过程为：组建团队—意见产出—意见评估—意见排序 —假设分析：采用该方法来解决一些复杂的问题，尤其是涉及到存在多方冲突的公共问题 3、政策议程的含义及类型 (1)定义：指受到政府或公共组织高度重视的公共问题被纳入其讨论，以求解决的过程。 (2)政策议程的类型 —系统议程，又称公众议程 —政府议程，又称正式议程 4、进入政策议程的条件及障碍 进入政策议程的条件 —问题明朗而严重 —政治权威或专家学者的预测性发动 —正确、民主、开放的民主机制 进入政策议程的障碍 —问题模糊或不太严重 —没有政治权威或专家学者的预测性发动 —没有民主、开发的机制 —不符合社群的价值规范 —受现有制度或程序的限制 —问题的诉求方式欠当 5、政策议程确立模型 科珀的模型 —外在创始模型：首先由公众提出，再进入政府议程。该模型适用于民主、平等的社会； —内在创始模型：政府直接提出。该模型在财富和权力高度集中的社会中常用； —动员模型：政府直接提出，然后扩散到公众议程。该模型常出现在不太民主的社会里。 金登的模型 —问题流：关注问题的定义； —政策流：关注与解决问题的建议或方案； —政治流：关注政治对解决方案的影响 第六章 政策方案的规划与抉择1、公共政策目标 —政策目标的含义：共政策目标就是有关公共组织特别是政府为了解决有关政策问题而采取行动所要达到的目的、指标和效果。 —-特征(1)问题的针对性：任何政策都是针对特定政策问题而提出。 (2)未来的预期性：由于制定方案、执行方案需要一定时间，以及政策问题一旦产生会随着时间的推移而有所变化，因此要求政策目标的设置要有预期性。 (3)目的多元性：政策问题的复杂性要求政策目标多元。 —–意义:(1)指导政策方案的制定 (2)评估政策执行效果以及检验政策质量的标准 —-原则:(1)实事求是—可行性、可达性 (2)面向未来—预期性 (3)系统协调性—多元性(如修正关于个税起征点和税率结构调整) (4)明确具体—政策目标意义所要求 (5)伦理(如关于设立禁讨区) —公共政策的基本目标:(1)公平：分配对象、分配物、分配方式 (2)效率：投入产出比(3)自由(4)安全 2、政策规划 —政策规划特征:—政策规划主体呈现主体多元和政府主导的特征； —政策规划在时间进程上处于政策目标确定与政策抉择之间。 —政策规划模式: (1)韦默和维宁的政策分析框架 问题分析：理解问题—选择和解释目标与约束—选择解决方法 解决方案分析：确定政策方案评估标准—设计、阐释备选方案—评估备选方案—选定方案，并说明选择依据 (2)帕顿与沙维奇的政策分析模式 ① 认定、细化问题 ② 建立评估标准 ③ 设计政策方案 ④ 评估方案 ⑤ 展示、区分备选方案 ⑥ 监督和评估政策实施 —政策方案的设计原则:(1)紧扣政策目标 (2)设计多重方案(3)方案彼此独立(4)方案要创新(5)方案要具有可行性 3、公共政策抉择:公共政策抉择是公共政策制定过程中最具有实质性意义的阶段。 —公共政策抉择的环节: —公共政策抉择主体(1)国家元首(2)行政首长 (3)民意代表(4)法官(5)执政党首脑以及军事首长 —公共政策抉择原则:(1)尊重科学分析的价值 (2)考虑各方利益平衡(3)发挥决策者的能动作用(4)遵照有关程序的规定 —政策方案的评估与择优(注：预测性评估方法和可行性评估方法)： —预测性评估 ① 预测性评估的重要性：它是政策方案评估的一种最基本方法。 ② 预测性评估步骤：方案调查—详细研究—进一步分析—试验式证实 ③ 预测性评估的方法： 外推预测：预测人员根据目前的和历史的数据，来判断未来社会状况。(经验数据为基础，归纳法)理论预测：主要以立论假设和以前现在的一些数据，来判断未来社会状况。(经验数据和立论为基础，演绎法) 判断预测：对各种判断进行推导和合成(以各种判断为基础) —可行性评估：① 技术可行 ② 经济可行 ③ 政治可行 ④ 行政可行 —政策抉择的合法化： (1)公共政策抉择合法化的含义：指决策主体依据有关法律，按照法定程序对政策方案加以审查、通过或批准、签署及发布的过程。 (2)公共政策抉择合法化的内容 ① 政策内容的合法化 ② 决策程序的合法化 公共政策制定过程： 政策问题确认政策议程建立 政策目标拟定政策规划政策抉择：政策论证，政策审议，政策采纳 政策抉择合法化 4、危机决策 —危机决策的含义：指组织在有限时间、有限资源等约束条件下，做出应对危机的具体措施。 —危机决策的构成要素： ① 问题发生、发展具有突然性、急剧性； ② 决策者可利用的时间、资源有限；③ 决策问题危及到很多方面； ④ 决策后果难以预料 —危机决策与常规决策间的关系：危机决策根源与常规决策不当有关，通过危机决策可以进一步完善常规决策 第七章 公共政策执行1、公共政策执行的含义、特点、作用； 含义：是政策执行主体通过各种措施和手段作用于公共政策对象，使公共政策的内容变为现实，从而实现公共政策目标的行动过程。其本质是遵循政策所进行的所有行动的总和。 特点：(1)目标导向性 (2)内容务实性 (3)行为的能动性 (4)手段权威性 作用： (1)是实现政策目标的重要途径 (2)是检验政策质量的唯一环节 (3)是制定后继政策的基本依据 2、“上下来去”政策执行模型； 3、政策执行机关的特性； (1)执行性：是政策执行机关最主要、最核心的特性 (2)服务性 (3)权威性 (4)法制性 4、下级执行人员执行行为的作用； (1)下级行政人员的执行行为是政策执行的主体行为 (2)下级行政人员的执行行为是实现政策目标的重要保证 (3)下级行政人员的执行行为是塑造政府形象的重要途径 5、提升公共政策执行力的方法； —优化公共决策机制 —创新政策执行的动力机制，主要是要优化公民参与机制，创新激励机制 —构建政策执行的功能共享机制，主要是构建信息沟通机制，强化责任追究机制，完善执行监督机制 —完善政策执行的利益均衡机制，主要是构建利益表达机制，利益引导机制，利益约束机制，利益调节机制和利益补偿机制 6、影响公共政策执行的主要因素； (1)政策本身 —政策的合理性 —政策的具体性 —政策的稳定性 (2)执行主体 —执行组织的情况：包括执行组织的结构的合理性，执行组织的权责的明确性。 —政策执行人员的情况：包括执行人员的利益、心理、知识和能力。 (3)政策对象 (4)政策环境：包括自然环境、政治环境、经济环境(是政策执行的最深层的环境，是政策执行的物质基础)、文化环境。 7、公共政策执行偏差的含义、表现形式以及矫正偏差的对策； 含义：指政策执行者在实施政策过程中，由于主客观因素的作用，其政策效果偏离政策目标并产生不良后果的政策现象。 表现形式：(1)象征式政策执行—“阳奉阴违” (2)附加式政策执行—“土政策” (3)残缺式政策执行—“断章取义，为我所用” (4)替代式政策执行—“挂羊头，卖狗肉”，“上有政策，下有对策” (5)观望式政策执行—“软拖” (6)照搬式政策执 矫正偏差的对策：(1)加强公共政策执行的成本—收益分析 (2)加强公共政策的认知度 (3)提高公共政策执行者的素质 (4)加强公共政策执行的控制和监督(5)加强公共政策执行的制度创新 8、公共政策无效执行的具体表现； —执行机制与执行者的素质缺陷； —利益群体的影响； —政策执行原则把握不好； —政策执行环境影响 —政策目标群体影响 9、公共政策有效执行的原则与机制 (1)政策有效执行的原则 —忠实原则 —民主原则 —法治原则 —创新原则 (2)公共政策有效执行机制 —公共政策信息沟通机制(单个执行组织，多个执行组织) —公共政策的公民参与机制，参与执行计划拟定、参与执行监督与执行评估。 —公共政策的激励机制 —公共政策的责任追究机制 —公共政策的监督机制 第八章 公共政策的评估与监控1、政策评估的作用、类型、过程 政策评估过程 (1)评估准备阶段 –明确评估目的 –确定评估对象 –制定评估计划 –明确评估条件 (2)评估实施 (3)评估总结 公共政策评估的类型 (1)正式评估与非正式评估 正式评估是占主导地位的评估方式 (2)内部评估与外部评估 (3)预评估、过程评估、结果评估 (4)单一政策评估、符合政策评估 政策评估内容 (1)政策成本评估 (2)政策需求评估 (3)政策效益评估 (4)政策过程评估 (5)政策影响评估 (6)政策价值评估 公共政策评估的作用 (1)是获取政策运行相关信息的手段 (2)是进行政策调整的重要依据 (3)是检验政策结果的必要途径 (4)是合理配置政策资源的前提 (5)是构建良好公共关系的策略 (6)是管理科学化和民主化的必要保证 2、影响政策评估的因素 (1)政策相关信息 (2)政策制定者与执行者 (3)政策目标 (4)政策的成点成本 (5)政策评估方式、方法 3、政策评估的标准 (1)事实标准 —政策效率 —政策效益 —政策影响 —政策回应性 (2)技术标准 —多样化 —系统化 —数量化 (3)价值标准 —社会生产力标准 —社会公正标准 —社会可持续发展标准 4、政策监控的内容、类型、功能、过程 公共政策监控功能 (1)使政策制定过程合法化、科学化、民主化 (2)保证政策执行有力 (3)保证政策评估的客观、真实、准确 (4)明确政策调整方向 公共政策监控类型 (1)预防性监控、过程性监控、结果监控 (2)经常性监控、引发性监控 公共政策监控过程 (1)对公共政策制定过程的监控 (2)对公共政策执行过程的监控 (3)对公共政策评估过程的监控 (4)对公共政策调整过程的监控 公共政策监控的内容 (1)政策监控主体 (2)政策监控对象 (3)政策监控目的 (4)政策监控过程 第九章 公共政策的稳定、变动与终结1、政策稳定的内涵、意义、动力因素 (1)政策稳定的内涵 政策稳定是指在多种因素影响下，政策目标不变，且仍由既定的执行机构继续实施。政策稳定是相对的。因为在时间上它是阶段性与连续性的统一，在空间上，它是局部性和全局性的统一。 (2)政策稳定的意义 —有利于国家和社会的稳定 —有利于贯彻决策者的决定 —有利于提高政策的可预见性，提高政策效果 —有利于降低政府的成本 (3)政策稳定的动力因素 —决策主体的相对稳定 —政策问题还没有完全解决 —政策本身稳定(政策目标未变；政策有效；政策合法；修改政策复杂；接续政策失败；终结政策失败) —政策环境稳定 2、政策变动的含义、原因 (1)政策变动的含义 是指政策系统对内外部环境的变化所做出的适应性改革。 (2)政策变动的原因 —决策者变动 —政策环境变化 —政策资源限制 —政策失效或低效 —政策合法性受质疑 3、政策创新的含义、动力 (1)政策创新的内涵 政策创新是指政策主体根据政策所处内外环境的变化，改变现有政策，创造新政策的过程。政策创新与政策变动的不同。 (2)政策创新的动力 —内部动力(政策主体的变革愿望；政策本身的低效等) —外部动力(经济体制的变革；公众的诉求；地区竞争的需要；国际竞争的需要) 4、政策调整的含义、内容、形式、原因、作用、原则 (1)政策调整的含义 指根据政策评估或者政策监控所反馈的信息对原政策进行增删、修正、更新，时期更加适应政策对象和政策环境。政策调整具有渐进性、局部性、动态性 (2)政策调整的内容 —政策目标调整 —政策主体、客体调整 —政策方案调整 —政策执行方案调整 —政策关系调整 (3)公共政策调整的形式 —政策的增删 —政策的修正 —政策的更新。 (4)政策调整的原则 —实事求是原则(首要原则) —渐进调适原则 —追踪反馈原则 (5)政策调整的原因 —利益刚性的限制 —现有政策的限制 —公共意志的集中 —变革成本的约束 —人类理性的局限 —社会稳定的需要 (6)政策调整的作用：—及时纠偏、预防失误—协调关系—发展完善 5、政策终结的含义、对象、原因、作用、策略 (1)政策终结的含义 依据政策评估结果，终止错误的、过时的、多余的或无效的政策。 (2)政策终结对象：—功能终结(最难)—组织的终结—政策本身的终结—政策执行方案的终结 政策终结的作用：—节省政策资源—提高政策绩效—促进政策优化 政策终结的策略：—重视说服工作—营造有利于气氛—公开评估结果，争取支持力量—废旧立新，缓和终结压力—先试点，避免矛盾激化—终结部分，减少代价 (3)政策终结方式：政策废止(是最直接、最彻底的方式)，政策替代，政策分解，政策合并，政策缩减 第十章 公共政策学知识的应用1、政策分析的含义、作用 2、政策分析的要素、原则、过程 政策分析的要素与政策内容和政策过程的构成要素是一致的(1)政策问题 (2)政策目标(是政策分析过程的中心任务) (3)政策方案 (4)政策模型(5)评估标准(6)实施结果(7)环境(8)信息 政策分析原则 (1)民主化原则 (2)系统性原则 (3)协调性原则(4)多样性原则 (5)分合原则 (6)预测原则 政策分析的过程(1)问题构建 (2)预测 (3)规定 (4)描述 (5)评估 3、政策研究组织的作用、类型 应用性政策研究组织的作用 (1)向决策者提供政策建议 (2)提供新的理论、方法 (3)提供有关政策实践的信息 (4)向政府输送高政策素质的人员 (5)对公众进行政策教育 应用性政策研究组织的类型 (1)行政型政策研究组织 (2)事业单位法人型政策研究组织 (3)学术型政策研究组织 (4)产业型政策研究组织 (5)民办非企业法人型政策研究组织 4、政策分析师的素质、职业伦理 政策分析师的素质要求 (1)具有政治头脑 (2)具有总体、全局观念 (3)具有弹性思维 (4)具有洞察力 (5)具有预测力 (6)具有创新精神 政策研究组织和政策分析师的职业伦理 (1)道德品质要求，实现目的性与责任性的统一 (2)行为要规范 (3)要有正确的价值判断","link":"/2021/03/23/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/%E5%85%AC%E5%85%B1%E6%94%BF%E7%AD%96/%E5%85%AC%E5%85%B1%E6%94%BF%E7%AD%96%E6%80%BB%E7%BB%93/"},{"title":"当代中国政治制度","text":"中国政治制度总结 第一章 政治制度第一节 政治制度和当代中国政治制度一、政治制度的涵义 制度及政治制度的定义 特点：（多选）稳定性、强制性、合法性、历史性 二、政治制度与社会经济、文化制度的关系 在社会各项制度中，根本性的、起决定性作用的制度是社会的经济制度，经济制度是社会结果的基础，是社会经济基础的主要成分。它决定社会的上层建筑。 需了解的： 丹尼尔《后工业社会》，即知识经济。 思想文化意识对政治制度主要起导向作用。 美国政治学家亨廷顿的《文明的冲突》 选择：建设有中国特色社会主意的文化，就是以马克思主义为指导，以培育有理想、有道德、有文化、有纪律的公民为目标，发展面向现代化、面向世界、面向未来的，民族的科学的大众的社会主义文化。 三、当代中国政治制度的内容 简答：如何建设有中国特色的社会主义的政治（其实现在应只会当选择题考）记住红体部分 建设有中国特色的社会主义的政治，就是在中国共产党领导下，在人民当家作主的基础上，依法治国、发展社会主义民主政治。 人民民主专政构架图（后补） 人大制度：元首制度、选举、立法、行政（含国家公务员）、司法、军事。 单一结构制度：民族区域自治、特别行政区 第二节 坚持和完善当代中共政治制度一、坚持当代中共社会主义政治制度 政治制度与政治体制的区别（简答，非重点）（详见书 P7） 二、推进政治制度改革，完善当代中共政治制度 改革成果即可改善的地方 废除领导干部终身制，建立了干部离退休制度，视线了干部队伍的年轻化、革命化、专业化、知识化，保持了党和国家的活力。(1) 实现了党政智能分开，调整了党的组织形式和工作机构。(3) 加强了社会主义基层民主自治制度建设。（居委会组织法，颁布工业企业职工代表大会条例）(4) 事实国家公务员制度。93 年制定了《中华人民共和国公务员条例》(5) 根据高效、精简、统一的原则，进行了行政机构改革。98 年幅度最大，改变了政府职能，实行政企分开，使政府更换地为市场经济服务。(6) 调整了重要和地方的政治经济关系，更有利于调动重要和地方两个积极性。(7) 加快人大立法速度，提出依法治国方略，建立社会主义法治国家。 论述：坚持和完善当代中国政治制度 1. 突出弊端。主要弊端是官僚主义，权力过分集中的现象，家长制现象，干部领导职务终身制现象和形形色色的特权现象。 为何要完善。(1)基本矛盾矛盾，是人民日益增长的物质文化需求同落后的社会生产之间的矛盾。(2)文革带来的破坏。(3)改革实践方面（经济体制改革入手－政治体制改革）(4)政治文化方面 3.如何完善（重点）即改革成果中的 7 点 第二章 当代中国国家制度国家制度即国体，是国家政治制度的重要方面。 中国的国体是：人民民主专政。 第一节 中国社会主义政治制度的建立和发展一、中国社会主义政治制度的建立 中国社会主义政治制度的建立过程 1948.4.30《五一宣言》，召开政协会议，成立民主联合政府。 1949.9.21 一届政协通过了《共同纲领》（临时宪法作用），据此建立新民主主义国家政权。 1954 一届人大召开，改变两级政府为一级政府，国务院即重要人民政府，由人(武汉自考)大产生，受他监督，对他负责。1956 年底 改造社会主义审查资料私有制――社会主义经济制度确立（选择） 另外，以下几点也需记忆。 中央人民政府委员会行使最高国家权力，对外代表中华人民共和国，对内统一领导国家政权。行使国家权利机关和中央行政机关的职权，兼有国家最高权力机关和最高行政机关的双重性质。 《共同纲领》规定中华人民共和国为新民主主义即人民民主的国家，实行工人阶级领导的、以工农联盟为基础的、团结各民主阶级和国内各民族的人民民主专政。 我国的新民主主义是建立在工人阶级、农民阶级、小资产阶级和民族资产阶级四个民主阶级联盟上的。 新民主主义社会是一个过渡性质的社会，新民主主义国家政权具有较多过渡性和不完备性。 二、中国社会主义政治制度的发展（非重点） 1956-1966 年开始全面建设社会主义时期，主要特点：党的一元化领导 1966-1976 文革时期，该阶段为颓废期，基本不考。 1978 年党的十一届三中全会以来新的历史时期――伟大转折文革结束后，我国社会主义政治制度逐步完善体现在哪些方面？（简答） 党的领导制度得到了完善和加强。成立中央纪律检察委员会。1982 年，规定只设总书记。形成了中央书记处、中央政治局和政治局常委三个层次的领导制度。 人民代表大会制度得到了全面恢复和加强。通过 82 年宪法 共产党领导的多党合作制度和政治协商制度得到巩固和加强。提出“长期共存，互相监督，肝胆相照，荣辱与共”的十六字方针。 国家立法、司法、监督制度也进一步完善。 第二节 当代中国国家制度一、中国是人民民主专政的社会主义国家国家制度是统治阶级依据法律确定其政治领导和政治统治权以及统治与被统治关系的制度，是统治阶级为 维护自己的政治统治而确定的根本制度。国家制度表面社会各阶级在国家中的地位，即统治的和被统治的地位，表面国家政权的性质，反应国家政权的阶级本质。社会主义国家制度是共产党领导的以工农联盟为基础的无产阶级专政或人民民主专政国家。82 年宪法规定“中华人民共和国是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家。 二、中国人民民主专政的特点 （简答）人民民主专政的特点与历史任务。详见书 P25-26 第三章 当代中国国家形式和国家机构第一节 当代中国国家形式一、国家形式的涵义 国家形式（政体），是指国家政权的组织形式。也包括过结构形式，即国家政权的区域组织形式（单一制、复合制）；国家治理形式（集权制、民主制）。 国家本质与国家形式的关系：国家本质决定国家形式、国家决定政体、政体为国体服务，起维护国家本质的作用。国家形式在根本上是由国家的阶级本质、社会的经济基础、阶级关系决定的。 政体有君主制和共和制之分。 君主制： l 古代： n 等级君主制－中世纪欧洲 n 贵族君主制－古罗马？ n 专制君主制（中国） l 近代： n 君主立宪制 u 议会制君主立宪制（英国） u 二元制君主立宪制（二战前日本&amp;一战前德国） 共和制： l 古代： n 贵族－古罗马 n 城邦君主－古希腊 l 近现代： n 议会制－德国 n 总统制－美国 n 半总统制－法国、瑞典 n 委员会制－瑞士 国家结构形式主要分为单一制和复合制（邦联制和联邦制）两种形式。 单一制国家和联邦制国家最主要的区别集中表现在中央和地方的权力划分上。P32 我国的人民代表大会充分体现了民主集中制的原则。（选择） 三、中国国家结构形式 中国人大制度的内容和特色 P33 四点（非重点简答） 我国单一制的三种形式：民族区域自治、设立特别行政区、在一般地方行政区域，设置地方国家机关。P34（选择） 第二节 当代中国国家机构一、国家机构概念 国家机构是形式国家权力，执行国家内部只能和外部只能，进行立法、行政和(武汉自考)司法管理等各种活动的国家机关的总和。 官吏和常备军是资产阶级国家的两个最主要的特征。――恩格斯（多选） 二、中国国家机构概况 我国国家机构系统，按其性质和职能分为：国家权力机关、国家行政机关、国家军师机关、国家审批机关和国家检察机关。 国家主席：国家主席的职权是根据全国人大及其常委会的决定来行使的。（2 届连任） 国务院：是最高国家权力机关的执行机关，由人大产生，对他负责受他监督。 中央军事委员会：是中国国家军事机关，是全国武装力量的领导机关。 人民法院：国家审批机关。 中国人民检察院：是国家的法律监督机关。 在中国国家机关体系中，国家权力机关居于首要地位。 三、中国国家机构的设置原则（简答） 三个原则：国家的一切权力属于人民、议行合一、民主集中制 第四章 当代中国选举制度第一节 当代中国选举制度的形成与发展一、选举和选举制度 选举：指人们根据公认的规则，从所有人或一些人中选择几个人或一个人担任一定职务的行为。 选举制度：指由选举法规定的有关选举国家代表机关或公职人员的各项制度的总称，其内容包括选举的基本原则、选举的机构、选举程序、选举方法。 二、当代中国选举制度的形成和发展 选择：当代中国的选举制度渊源于革命根据地的选举制度。 发展过程： 53 年中央人民政府委员会颁布《选举法》 79 年通过第二部选举法（简答）书上共 9 点，老师又加了两点(1) 直接选举人们代表的范围由乡、镇一级扩大至县级。(2) 差额选举(3) 53 年中只需出席过半数即可通过改为全体过半数。 82 年对第二部选举法做第一次修改(1) 将“人民公社”改为“乡、民族乡”(2) “另行选举”即第一次投票不过半数，则第二次投票只需过 1/3 86 年对第二部选举法做第二次修改(1) 选民或代表 10 人以上联名，可推荐代表候选人(2) 取消预选，规定了差额选举的比例（间接选举：1/3-1？直接选举 1/2-1/5） 95 年对第二部选举法做第三次补充和修改（简答）(1) 将乡、镇选举委员会受县（区）级选举委员会领导改为受县（区）级人大常委会领导。(2) 五倍改为“四倍”(3) 增加了罢免内容，县和乡级人大代表，原选区选民 30 人以上联名可提出，半数通过则可罢免，县级以上，主席团或 1/10 以上代表联名，可对上一级人代会代表提成罢免。 第二节 当代中国选举制度的原则一、选举权和被选举权的普遍原则（简答） 选举权和被选举权：除 1. 年满 18 岁 2. 未被剥夺政治权力的人（被剥夺的罪犯以及精神病人）都享有该权利。 普遍原则：(1) 平等原则 “一人一票”？“城镇各选区每一代表所代表的人口数应大体相当。(2) 直选和间选相结合的原则 多选：不设区的市、市辖区、县、自治县、乡、民族乡、镇的人大代表，由选民直接选举。(3) 秘密投票――无记名(4) 差额原则 第三节 直接选举的组织和程序（简答）一、主持选举的机构――选委会（临时机构） 不设区的市、市辖区、县、自治县的选举委员会受本级人民代表大会常务委员会的领导。 二、选区划分 农村： 县级：按几个村一个选区 （人数特多的村或人口少的乡可称为一个选区） 乡级：按几个村民小组一个选区（人数特多的村民小组或人可少的村可划为一个选区） 城镇： 独立选区：1 个生产（工作、事业）单位或 1 个居民区 联合选区：几个生产（工作、事业）单位或几个居民区 混合选区：1 个居民区与它辖区内的若干个生产（工作、事业）单位 三、选民登记 精神病患者不能形式选举权利的，经选委会确认，不列入选民名单。 对于申诉意见，选委会应在 3 天作出处理决定。申诉人对处理决定不服着，可在选举日的五日前向人民法院起诉。 四、代表候选人的提出与确定 由选民直接选举的代表候选人名额，应多于应选代表民额的 1/3-1 倍。 由选民直接选举人代会候选人（选民 10 人联名即可推荐） 五、投票选举和当选 过半数 另行选举时，需过 1/3 直接选举流程详见下图：（简答） 成 立选委会――制定选举工作流程――规定选举日――划分选区、分配代表名额――培训选举工作人员――宣传选举法――选民登记――审查(武汉自考)选民资料――公布选民名 单（前 20 日）――提出候选人――选委会汇总――公布候选人名单（前 15 日）――小组协商讨论――汇总情况――各方协商会议――公布正式候选人名单（前 5 日）――介绍候选人――投票（选举日）――选区汇总计票――选区公布选举结果――选委会汇总审核――选拔当选人名单――选委会总结归纳――选委会撤销 第四节 间接选举的组织和程序中共县级以上人民代表大会代表实行间接选举 一、主持机构――全国人民代表大会常务委员会 二、全国和县级以上地方各级人民代表大会名额及分配 不超过 3000 人 名额分配情况：各省、自治区、直辖市、解放军、港澳台 省、自治区、直辖市代表名额基数为 350，设区的市、自治州代表名额基数为 240 三、全国和县级以上地方各级人民代表大会代表候选人的提名、确定和正式选举 10 人以上联名 差额选举时，代表候选人名额，应多于应选代表民额的 1/5-1/2 倍 第五节 人民代表的地位、职权及监督、罢免一、人民代表的地位、职权及保障（考点较少） 基本的三项权利：审议、表决、选举 附带的七项权利：提案、提名、建议、批评、询问、视察、质询 保障的三项权利：发言，表决，免责、人身特别保护权、物质保障权 二、对人民代表的监督、罢免（选择） 30 以上联名，可提出罢免 对县级以上人代会提出罢免条件：主席团或 1/10 以上代表联名 无记名投票，半数通过 第五章 当代中国人民代表大会制度（上）人民代表大会是当代中国的政权组织形式和根本政治制度。 第一节 人民代表大会制度是当代中国的根本政治制度一、人民代表大会制度的确立 人民代表大会制度就是由选民或代表依照民主集中制原则依法选举代表，组成全国及地方各级权力机关体系即全国及地方各级人民代表大会，通过国际权力机关组织其他国家机构，行使人民当家作主的权力。 人大制度是在中国人民长期革命斗争中产生和发展起来的。 31 年 成立中华苏维埃共和国 执委会 34 年 人民委员会 执行机关 49 年 《共同纲领》人民代表大会由人民用普选方法产生。 53 年 普选（第一次） 54 年 人大一次会议召开 五年一次 二、人民代表大会制度是中国的根本政治制度（简答） (1) 我国的人民代表大会制度是与我国人民民主转正的国家制度相适合的政权组织形式。体现了人民民主专政国家一切权力属于人民的根本原则和核心内容，也体现了人民管理国家事事务的权利的实现。(2) 我国的人民代表大会制度具有深厚的群众基础和广泛的代表性，从政治上和组织上保证全体人民掌握国家权力，真正成为国家的主人。(3) 我国的人民代表大会根据议行合一的原则设置国家机关，可以有效地保证国家权力机关的决定得到迅速执行，人民的意志得到有效实现。 第二节 全国人民代表大会一、全国人民代表大会的地位、组成、任期、职权 法律地位：1. 全国人民代表大会统一行使国家权力，它在国家权力机关中处于最高地位。 2. 中央其他国家机关如行政机关、审判机关、检察机关都由人民代表大会产生，受它监督，对它负责。 代表的组成：省、市、自治区、特别行政区（港澳台）、解放军 四大职权：立法、决定、任免、监督 （详见书 P68-69） 任免权： 由主席提名，决定国务院总理人选 监督权：工作监督和法律监督。 听一府两院的报告 质询和询问。 爸妈任免代表大会选举或决定的其他国家机关的领导人 审查执行报告，审查国家预算。 二、全国人民代表大会会议 每年举行一次，有 2/3 以上的代表出席，才能举行。若有必要，或有 1/5 以上的全国人大代表提议，可以召开临时会议。 召开程序详见书 P70-71 选择 主席团是临时性机构 第三节 全国人民代表大会常务委员会全国人民代表大会常务委员会是常设机构，对全国人大负责并报告工作。 闭会期间，其他国家机关：一府两院、中央军委主席也要对全国人大常委会负责。 人员组成：委员章，副委员长若干人，秘书章，委员若干人、适当少数民族代表。 五大职权(1) 国家法权：解释宪法和法律。(2) 国家某些重大事项的决定权。（与第七章内容重叠）(3) 人事决(武汉自考)定和任免权：根据最高人民法院院长的提请，任免最高人民法院副院长。 批准省、自治区、直辖市的人民检察院检察长的任免。(4) 监督权(5) 其他职权（无重点） 二、全国人大常委会的会议制度和工作程序 委员长会议是委员长主持常委会工作的一种工作方式，不是一级国家权力机关，不能代替人大常委会行使职权。全国人大常委会是合议制机关，实行即讨论几天决定的集体领导制度。两个月举行一次，常委会组成人员 10 人以上联名。 全国人大常委会生意法律草案实行三审制。 P78 质询需 10 人以上联名。 三、全国人大常委会机构 （多选） 代表资格审查委员会： 必要时可组织特定问题调查委员会（临时性组织） 办公厅 ：性质：日常工作的机构，由全国人大常委会秘书长领导 工作委员会：组成人员不限于人民代表。 第四节 全国人民代表大会专门委员会二、工作职责 概括为提案、审议、调研三项。（详见 P82-83） 第六章 当代中国人民代表大会制度（下）第一节 地方各级人民代表大会一、地方各级人民代表大会的地位、组成、任期、职权 地位：规定省、自治区、直辖市、自治州、县、自治县、市、市辖区、乡、民族乡、镇设立人民代表大会。 乡、民族乡、镇每届任期三年，其余为五年。 省、自治区、直辖市的人大可制定地方性法规。15 项职权可归纳为五方面：保证权、决定权、任免权、监督权、保护权。 二、地方各级人民代表大会会议和工作程序(1) 每年至少举行一次。(2) 县级以上人大每次会议举行预备会议。（县级以下无人大常委会）(3) 本级人代会议主席团、常委会、各专门委员会、本级人民政府可提案；县级以上地方人大代表 10 人以上联名，乡、镇 5 人以上联名。（国家是 30 以上联名） 第二节 县级以上地方各级人大常委会一、县级以上地方各级人大常委会的地位、组成、任期、职权(1) 名额：省、自治区、直辖市 35 人至 65 人，人口超过 8 千万的省不超过 85 人，设区的市、自治州 13 人至 35 人，人口超过 8 百万的设区的市不超过 45 人，县、自治、不设区的市、市辖区 11 人至 23 人。（历届考过）(2) 县级以上地方人大，每届任期 5 年。(3) 省、自治区、直辖市和省级人民政府所在地的市、较大城市的人大常委会可以制定和颁布地方性法规。（选择） 二、县级以上地方各级人大常委会的会议和工作程序 设区的市人大常委会主人会议由本级人大常委会主任、副主任和秘书长组成。 县级人大常委会主任会议由本级人大常委会主任、副主任组成。 提案：县级以上，提案 5 人以上联名。县级，3 人以上联名。 质询：县级以上，5 人联名，县级，3 人联名 三、县级以上地方各级人大常委会机构多选）详见书 P93 第三节 方各级人大专门委员会一、地方人民代表大会专门委员会 县级人大不设类似政法财经等专门委员会，但可以成立特定问题调查委员会。 二、专委会职责（不需记忆，知道全国人大的即可） 专委会的性质是常设机构 第四节 坚持和晚上人民代表大会制度 （重点）一、人民代表大会制度和西方议会制的主要区别 产生的社会历史条件不同 资产阶级意会产生于封建社会末期资产阶级革命过程中。中国的人民代表大会是在中国人民长期斗争中产生和发展起来的。 法律地位不同 西方：议会作为三权分立中的立法机关，行使国家立法权。 我国：人民代表大会作为国家权力机关，同意行使国家权力，且具有唯一性和最高性。 与政党关系不同 中国共产党是执政党，任何别的政党都不能代替中国共产党的执政地位，因此(武汉自考)在中国不存在通过竞选各党轮流执政的问题。在中国只有执政党和参政党的区别，没有执政党和反对党的区别。 西方国家政党与议会的关系，主要是通过议会选举来确立的。划分为执政党和在野党。 人民代表和议员的区别 1）选举方式：西方国家议员大多通过竞选产生，而我国人民代表是按民主集中制原则通过差额选举产生。 2）阶级基础：我国：具有深厚的群众基础和广泛的代表性； 西方：行使上是代表选民的，但实质并不代表它是选民的代表。，议员是转职的，另外从代表性上来看，美英等国议员代表的是不同的利益集团。（阿尔蒙德提出） 组织行使、组织机构不同 1）议会体制有一院制（中国）、两院制（欧美）等。 2） 西方议会由议员、议长、委员会、议会党团、工作机构、国家元首组成。 二、加强人民代表大会制度，发展社会主义民主政治。 社会主义的本质是人民当家作主。 人民代表大会值得得到了加强和完善？（简答） 详见书 P103 页，共五点 建设社会主义民主政治，最重要的是坚持和完善人民代表大会制度。（选择） 如何进一步坚持和完善人民代表大会制度，充分发挥这一制度的优势和作用？（论述） 详见书 P104-105 第七章 当代中国国家元首制度第一节 当代中国国家元首制度的演变一、国家元首概述 国家元首的性质是国家对内对外的代表，是整个国家机关的一个组成部分，它的设立由宪法予以规定。 在君主制政体国家，元首一般经世袭产生，实行终身制。 在共和制政体国家，由选举产生，实行限任制。 四种选举方式：(1) 由立法机关（议会）选举产生(2) 由人民直接选举产生（法国）(3)通过选举团选举产生（美国）(4)由混合团体产生（德国） 三种类型：(1) 总统制国家，（美国）国家元首兼任政府首脑，领导政(2) 议会制国家，（英德等），既有元首，又有政府首脑，只行使国家元首的职权。(虚位元)(3) 议会制总体制国家（即半总统制）（法国，俄罗斯等），总统是国家元首，行使大部分国家行政权，并有权通过议会任命政府首脑，掌握主要国家权力。 国家元首还有单一元首和集体元首（瑞士）之分。 二、中国国家主席制度的演变 中央任命政府委员会集体行使国家元首职权1949 年 9 月，《共同纲领》规定 1954 年宪法规定设置国家主席，这部宪法规定，中华人民共和国主席为独立的国家机构，对外代表中华人民共和国，并根据全国人民代表大会的觉得和全国人大常委会的决定行使国家元首的职权。宪法还规定了中华人民共和国主席统率全国武装力量，担任国防委员会主席。 1975 年和 1978 年宪法规定不设置国家主席第一部宪法规定的国家主席的职权，分别由党中央和全国人大常委会行使。1978 年宪法，规定原国家主席行使的部分职权由全国人大常委会委员长行使。三、恢复国家主席制度（简答） 详见 P112 第二节 国家主席的产生、任期、职权一、国家主席的产生、任期 候选人资格，1982 年宪法规定，有选举权和被选举权的年满 45 周岁的中华人民共和国公民。 提名、选举、任期1982 年宪法规定国家主席，副主席由全国人民代表大会主席团提名，全国人民代表大会选举产生。主席缺位时，由副主席继任，主、副主席都缺位，由全国人民代表大会补选，由全国人大常委会委员长暂时代理主席职位。连任不超过两届。 法律地位代表中华人民共和国；由全国人民代表大会选举产生，全国人民代表大会(武汉自考)有权罢免、根据全国人民代表大会的决定和全国人大常委会的决定行使职权。全国人民代表大会 &gt; 国家主席 &gt; 国务院 二、国家主席职权 对内：公布法律、任免国务院总理和国务院其他组成人员、授予国家的勋章和荣誉称号、发布特赦令、发布戒严令（1989 年，国务院决定选拔北京市九个区实行戒严（选择））、选拔战争状态、发布动员令。 对外：代表中华人民共和国，接受外国使节，根据全国人民代表大会常委会决定，派遣和召回驻外全权代表；根据全国人大常委会决定，批准和非常同外国缔结的条约和重要协定。 第八章 当代中国中央行政制度性质制度的基本内容：行政组织、行政及至、行政机构只能以及行政力体制等到方面的内容。 第一节 国务院的法律地位、组成、任期一、国务院的法律地位 国务院的前身是建国初期的中央人民政府委员会政务院，54 年后才改。 82 年宪法规定，中华人民共和国国务院，即中央人民政府，是最高国家权力机构的执行机关，是最高国家行政机关。 二、国务院的组成和任期 组成：总理、副总理若干人、国务委员若干人、各部部长、各委员会主任、审计长、秘书长。 总理由国家主席提名。连任不超过两届，每届 5 年。 第二节 国务院的职权二、国务院职权的行使 国务院有权根据宪法和法律，规定行政措施，制定行政法规，发布决定和命令。（特指的行政法规，只有国务院能颁布，如名称为 ×× 条例，×× 规定，×× 办法等。） 批准省、自治区、直辖市的区域划分，批准自治州、县、自治县、市的建置和区域划分，决定省、自治区、直辖市的范围内部分地区的戒严，等等。 第三节 国务院机构设置 （重点）一、建国以来国务院机构设置的沿革 我国政府机构的设置遵循的原则：需要、统一、精简、效能原则。 49-50 年代末 三增一减。政务院下设政治法律、文化教育、财政经济、人民监察四个委员会。52 年，在地方设六大行政区行政委员会，作为中央的派出机关，增设国家机会委员会（相当于政务院）。54 年 政务院改名为国务院，即中央人民政府。56 年，国务院工作部门达 81 个。58 年对机构进行精简。撤销、何必了 9 个部委等。 60-70 年代初 一增一减。60-64 年 八字方针：调整、巩固、充实、提高，增设到 77 个。66 年文革 减到 32 个部门。 70-80 年代 三增一减。71-75 年 43 个75 年 52 个78 年 76 个81 年 52 个 80-80 年代末 一增一减83-86 年 72 个87 年 68 个 召开的党的十三大提出政府职能转变，指出，“为了避免重走过去”精简－膨胀－再精简－再膨胀“的老路，必须抓住职能转变这个关键。 90 年代 一增二减 二、现街道国务院机构设置 97 年 9 月，党的十五大召开，这次改革目标是“建立办事高效……行政管理体制。 该方案明确指出改革遵循以下几个原则。（详见 P128） （一）国务院组成机构 国务院，列入其组成部门序列的共 29 个部、委、行、署，分四种类型： 宏观调控部门：国家经济贸易委员会、财政部、国家发展计划委员会、中国人民银行。 专业经济管理部门：国防科学技术工业委员会、建设部、铁道部、交通部、信息产业部、水利部、农业部、对外贸易经济合作部。 教育科技文化、社会保障和资源管理部门：教育部、科学技术部、人事(武汉自考)部、劳动和社会保障部、国土资源部、文化部、卫生部、国家计划生育委员会。 国家政务部门：国家民族食物委员会、公安部、国家安全部、监察部、民政部、司法部、审计署。 重点：03 年的变动 （现共 28 个） 体改委＋计委＝国家发展改革委员会 经贸委＋对外贸易经济合作部＝商务部 “计生委”改为“人口和计划生育委员会” （二）国务院直属机构 （选择） 前五项自己将平时经常听到的背一下是属于什么机构即可。（详见书 P130-131） 03 年增设银监会，98 年新增 政监会、保监会。 （六）议事协调机构（非常设）如：防汛抗洪总指挥部、妇女儿童协调委员会等。 （七）企业单位（经济实体） 特大型国企。 （八）中国中央、国务院 如：中共中央台湾事务办公室、国务院新闻办公室等。 第四节 国务院领带体制和会议制度建国初期直到 82 年，国务院从总体上看实行的是集体负责的领导制度－委员会制。（选择） 一、行政首长负责制（“三权一责”） 总理负责的具体内容：全面领导权、最后决定权、人事提名权、行政首长负全面责任。（选择） 二、国务院会议制度国务院会议由国务院全体会议（两个月或一个季度召开一次）、常务会议（每周一次）和办公会议（不定期召开）构成。（选择）","link":"/2021/01/28/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/%E5%BD%93%E4%BB%A3%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB%E5%88%B6%E5%BA%A6/%E5%BD%93%E4%BB%A3%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB%E5%88%B6%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"title":"公务员主观题","text":"公务员主观题梳理 第一章 公务员制度的产生 我国推行公务员制度的意义(1) 为坚持党的基本路线提供组织保证(2) 为国家机关的廉政建设提供有效保障(3) 对国家机关的民主化、科学化、法制化建设起促进作用。 我国公务员制度产生的原因(1) 市场经济需要职业化、高素质的人才 (2) 我国原有干部人事制度不能适应市场经济的需要。 资本主义国家公务员制度形成的原因(1) 从经济上看，公务员制度适应了资本主义市场经济发展的需要(2) 从政治上看，公务员制度适应了资产阶级正常政治的需要(3) 从管理方式变革上看，公务员制度适应了资产阶级保持局面稳定和提高行政效率的需要 我国推行公务员制度的指导思想(1) 坚持邓小平理论与三个代表重要思想(2) 继承和发展我国干部人事管理的优良传统，并吸收和总结了十多年来我国干部人事制度改革的成功经验。(3) 学习和借鉴国外人事管理的有益经验和科学做法。 我国公务员制度对原干部人事制度的继承(1) 坚持党的基本路线(2) 坚持党管干部的原则(3) 坚持德才兼备的用人标准(4) 坚持全心全意为人民服务的宗旨(5) 坚持中国特色的分类制度。 我国公务员制度对原有干部人事制度的发展(1) 实行分类管理体制 (2) 实行激励竞争机制 (3) 实行新陈代谢机制(4) 实行勤政廉政保障机制 (5) 法制化管理体制。 第二章 公务员义务与权利 规定公务员义务与权利的意义(1) 有利于形成一支优化、廉洁、稳定、高效的公务员队伍(2) 既是对公务员执行公务的有力约束，也是对公务员执行公务的有力保障(3) 有利于实现公务员管理的法制化、民主化、科学化。 规定公务员义务的原则(1) 违法必究原则 (2) 平等原则 (3) 服务与稳定原则。 我国公务员的义务(1) 忠于宪法的义务：模范遵守宪法和法律(2) 依法履职的义务：按照规定的权限和程序认真履行职责，努力提高工作效率(3) 为民服务的义务：全心全意为人民服务，接受人民监督(4) 忠于国家的义务：维护国家的安全、荣誉和利益(5) 服从命令的义务：忠于职守，勤勉尽责，服从和执行上级依法作出的决定和命令(6) 保守秘密的义务：保守国家秘密和工作秘密(7) 保持操行的义务：遵守纪律，恪守职业道德，模范遵守社会公德(8) 公正清廉的义务：清正廉洁，公道正派(9) 法律规定的其他义务。 公务员的法律责任(1) 身份处分：丧失公务员身份(2) 行政处分：承担行政责任，包括名誉、职级等(3) 赔偿责任：公务员因故意或过失使所管财务遭到损失，或因执行公务不当给行政相对人带来财产损失(4) 刑事责任：公务员因职务犯罪承担刑事责任。 规定公务员权利的原则(1) 保护原则 (2) 民主原则 (3) 权利可放弃和不可放弃原则。 我国公务员的权利(1) 获得工作条件权：获得履行职责应当具有的工作条件(2) 身份保障权：非因法定事由、非经法定程序，不被免职、降职、辞退或者处分(3) 获得报酬权：获得工资报酬，享受福利、保险待遇(4) 参加培训权(5) 批评建议权：对机关工作和领导人员提出批评和建议(6) 申诉、控告权：提出申诉和控告(7) 申请辞职权(8) 法律规定的其他权利。 公务员权利的法律保障(1) 行政复议 (2) 申诉 (3) 控告 (4) 诉讼。 第三章 公务员职务与级别 我国设置公务员级别的目的(1) 为公务员管理提供科学的管理基础 (2) 增强职务和级别的激励作用 (3) 便于借鉴国外公务员分类制度的合理因素。 职位分类的作用(1) 为职务设置提供基础 (2) 为各项管理提供依据 公务员职位类别的标准与类别的划分(1) 专业技术类：纯技术性 不可替代性 技术权威性。(2) 行政执法类：纯执行性 现场强制性(3) 综合管理类。 (4) 法官、检察官类。 (5) 其他。 公务员的职务序列(1) 公务员职务分为领导职务和非领导职务。领导职务层次分为：国家级正职、国家级副职、省部级正职、省部级副职、厅局级正职、厅局级副职、县处级正职、县处级副职、乡科级正职、乡科级副职。(2) 综合管理类的非领导职务分为：巡视员、副巡视员、调研员、副调研员、主任科员、副主任科员、科员、办事员。 公务员级别的功能(1) 确定工资及其他待遇的依据 (2) 平衡比较各类职务序列的标尺。 公务员级别与职务的对应关系(1) 合理增加级别数量 (2) 一职数级，上下交叉 (3) 向基层倾斜。 公务员职位设置依据的四大要素：(1)职能 (2)规格 (3)编制限额 (4)职数以 (5)结构比例 第四章 公务员录用 我国公务员录用的意义(1) 有利于为国家机关选拔一批高素质的优秀人才，更好地为发展社会主义市场经济与构建和谐社会服务(2) 有利于抵制用人上的不正之风，加强国家机关的廉政建设(3) 有利于激励人们积极进取，奋发向上，形成良好的社会风气 公务员录用的资格条件A－基本条件(1) 具有中华人民共和国国籍(2) 年满十八周岁(3) 拥护中华人民共和国宪法(4) 具有良好的品行(5) 具有正常履行职责的身体条件(6) 具有符合职位要求的文化程度和工作能力(7) 法律规定的其他条件。B－限制性条件下列人员不得录用为公务员：(1) 曾因犯罪受过刑事处罚的(2) 曾被开除公职的(3) 有法律规定不得录用为公务员的其他情形的 公务员录用的原则(1) 公开考试 (2) 平等竞争 (3) 严格考察 (4) 择优录用 公务员录用考试的内容(1) 知识测验 (2) 智力测验 (3) 技能测验 公务员录用的程序(1) 发布考试公告(2) 资格审查(3) 对审查合格者进行公开考试(4) 对考试合格者进行考察(5) 体检(6) 录用：提出拟录用人员名单，公示 审批、备案。 公务员录用工作过程中，承担违纪责任的条件(1) 不按编制限额录用 (2) 不按所需职位要求录用 (3) 不按规定的资格条件录用 (4) 不按规定的程序录用 公务员录用考试的种类：(1) 公开竞争性考试(2) 非公开竞争性考 适用非公开竞争性考试办法的情况有：(1) 因职位特殊不宜公开招考的(2) 因专业特殊，难以形成竞争的 (3) 录用主考机关规定的其他情况 公务员录用考试的内容：(1) 知识测验 (2) 智力测验，或叫能力测验 (3) 技能测验 公务员录用考试的方式：(1) 笔试 (2) 面试 (3) 实际操作 (4) 情景模拟和心理测试 务员录用的主管部门：(1) 中央国家机关公务员录用主管部门(2) 省级公务员录用主管部门(3) 设区的市级公务员录用主管部门 工作中违纪工作人员的处罚：(1) 取消工作人员资格 (2) 调离考录工作岗位 (3) 给予行政处分 第五章 公务员考核 公务员考核的含义与类型公务员考核，是指公务员主管部门和各机关按照管理权限，依据一定的程序和方法，对所管理的公务员的政治业务素质和履行岗位职责、完成工作目标的情况，进行了解、核实和评价。 公务员考核的类型包括：(1) 平时考核 (2) 定期考核。 公务员年度考核与录用考察、晋升考察的区别 区别 年度考核 录用考察 晋升考察 目的不同 评价公务员的全年表现 评价拟录用公务员的一贯表现，以确定是否录用 为晋升公务员职务而评价 法律依据不同 《公务员法》 公务员录用相关规定，如《公务员录用规定》 公务员晋升相关法规 考核组织不同 行政首长或考核委员会 用人部门 任免机关 考核方法和程序不同 规范 简单 严格 公务员年度考核的特点(1) 范围广泛：考核的范围全员性 考察则针对一部分特定对象(2) 定期进行：年度考核为一年一度 考察则视情况需要进行(3) 目的单一：年度考核针对公务员一年的工作情况进行 考察针对公务员的职业倾向、工作表现、个性特征等。 公务员考核的意义(1) 有利于客观公正地评价公务员，激励公务员提高自身素质，改进工作绩效(2) 有利于对公务员严格管理和严格监督(3) 为公务员管理其他环节提供依据。 公务员考核的原则(1) 全面考核和重点考核相结合(2) 客观公正与民主公开(3) 分类考核(4) 考用结合。 公务员考核的内容《公务员法》规定，“对公务员的考核，按照管理权限，全面考核公务员的德、能、勤、绩、廉，重点考核工作实绩。”(1) 德，是指思想政治素质及个人品德、职业道德、社会公德等方面的表现。(2) 能，是指公务员从事本职工作所需具备的业务素质和工作能力。(3) 勤，是指公务员的责任心、工作态度、工作作风和勤奋精神。(4) 绩，是指公务员的工作实绩。(5) 廉，是指公务员的廉洁自律等情况。 公务员确定为优秀等次须具备下列条件(1) 思想政治素质高(2) 精通业务，工作能力强(3) 工作责任心强，勤勉尽责，工作作风好(4) 工作实绩突出(5) 清正廉洁。 公务员确定为称职等次须具备下列条件(1) 思想政治素质较高(2) 熟悉业务，工作能力较强(3) 工作责任心强，工作积极，工作作风较好(4) 能够完成本职工作(5) 廉洁自律。 公务员具有下列情形之一的，应确定为基本称职等次(1) 思想政治素质一般(2) 履行职责的工作能力较弱(3) 工作责任心一般，或工作作风方面存在明显不足(4) 能基本完成本职工作，但完成工作的数量不足、质量和效率不高，或在工作中有较大失误(5) 能基本做到廉洁自律，但某些方面存在不足。 公务员具有下列情形之一的，应确定为不称职等次(1) 思想政治素质较差(2) 业务素质和工作能力不能适应工作要求(3) 工作责任心或工作作风差(4) 不能完成工作任务，或在工作中因严重失误、失职造成重大损失或者恶劣社会影响(5) 存在不廉洁问题，且情形较为严重。 我国公务员考核的基本方法(1) 领导考核和群众考核相结合(2) 平时考核和定期考核相结合(3) 定性考核和定量考核相结合。 对非领导成员公务员的定期考核程序(1) 被考核公务员按照职位职责和有关要求进行总结，并在一定范围内述职(2) 主管领导在听取群众和公务员本人意见的基础上，根据平时考核情况和个人总结，写出评语，提出考核等次建议和改进提高的要求(3) 对拟定为优秀等次的公务员在本机关范围内公示(4) 由本机关负责人或者授权的考核委员会确定考核等次(5) 将考核结果以书面形式通知被考核公务员，并由公务员本人签署意见。 公务员考核委员会的主要职责(1) 根据年度考核的统一要求和本部门工作的实际情况，制定考核工作计划(2) 拟定考核的具体方法和标准(3) 向本部门公务员公布考核计划，组织学习(4) 审核主管领导人员对公务员所写的评语和提出的考核等次意见，并将审核后的意见报部门负责人审定(5) 组织、指导、协调本部门各单位的考核工作(6) 监督考核程序(7) 受理公务员不服考核结果所提出的复核申请。 对领导成员公务员的定期考核程序(1) 考核准备 (2) 述职 (3) 民主测评 (4) 个别谈话(5) 调查核实 (6) 撰写考核材料 (7) 综合分析，评定考核结果 (8) 反馈。 公务员考核结果的使用A.公务员年度考核被确定为称职以上等次的，按照下列规定办理：(1) 累计两年被确定为称职以上等次的，在所定级别对应工资标准内晋升一个工资档次(2) 累计五年被确定为称职以上等次的，在所任职务对应级别范围内晋升一个级别(3) 确定为称职以上等次，且符合规定的其他任职资格条件的，具有晋升职务的资格 连续三年以上被确定为优秀等次的，晋升职务时优先考虑(4) 被确定为优秀等次的，当年给予嘉奖 连续三年被确定为优秀等次的，记三等功(5) 享受年度考核奖金。B.公务员年度考核被确定为基本称职等次的，按照下列规定办理：(1) 对其诫勉谈话，限期改进(2) 本考核年度不计算为按年度考核结果晋升级别和级别工资档次的考核年限(3) 一年内不得晋升职务(4) 不享受年度考核奖金C.公务员年度考核被确定为不称职等次的，按照下列规定办理：(1) 降低一个职务层次任职(2) 本考核年度不计算为按年度考核结果晋升级别和级别工资档次的考核年限(3) 不享受年度考核奖金(4) 连续两年年度考核被确定为不称职等次的，予以辞退。 第六章 公务员职务任免与升降 公务员职务任免与升降的意义(1) 对于机关来说，是保证机关中各职位获得合适人选的主要途径(2) 对于公务员来说，是有效的激励手段(3) 是实现职务管理的保证 公务员委任制的优缺点A.优点： (1) 体现治事与治人相统一 (2) 保证公务员队伍相对稳定 (3) 操作简便。B.缺点： (1) 用人上主要根据上级领导的意志，容易滋生主观随意性,缺乏透明度 (2) 对委任制公务员中不胜任职务者不易调整，容易造成能上不能下、能进不能出的弊端等 委任制公务员的任职程序(1) 提出拟任职的人选 (2) 考察 (3) 决定任命 (4) 下发任职通知 聘任制公务员的特点(1) 合同管理 (2) 平等协商 (3) 任期明确。 实行职位聘任的意义(1) 有利于健全用人机制，增强公务员制度的生机、活力。(2) 有利于满足机关吸引和使用多样化人才的需求(3) 有利于提高公务员的整体素质，提高公务员队伍的专业化水平。 实行聘任制的条件(1) 工作需要 (2) 机关选择 (3) 省级以上公务员主管部门的批准 (4) 在规定的编制限额和工资经费限额内进行。 委任制公务员免职的情形A. (1) 转任职位 (2) 晋升和降低职务 (3) 调出机关 (4) 被辞退、开除、撤职等。B. 单纯性免职的情形： (1) 离职学习超过一年以上 (2) 因健康原因，不能坚持正常工作一年以上的 (3) 退休的。C. 自行免职的情形： (1) 受到刑事处罚或劳动教养 (2) 受到行政撤职或开除处分 (3) 被辞退 (4) 因机构变动失去职位 (5) 死亡。 委任制公务员免职的程序(1) 提出拟任职的建议 (2) 审核 (3) 提出免职决定 (4) 发布免职通知。 公务员职务晋升的原则(1) 德才兼备，任人唯贤 (2) 注重工作实绩 (3) 公开、公平、竞争、择优 (4) 逐级晋升。 公务员职务晋升的程序(1) 民主推荐 (2) 组织考察 (3) 讨论决定 (4) 按照规定履行任职手续。 公务员竞争上岗的程序(1) 制定并公布实施方案 (2) 报名与资格审查 (3) 笔试、面试 (4) 民主测评，组织考察(5) 党委 (党组) 讨论决定 (6) 办理任职手续。 公务员公开选拔的程序(1) 发布公告 (2) 报名与资格审查 (3) 统一考试(4) 组织考察，研究提出人选方案 (5) 党委党组讨论决定。 (6) 办理任职手续。 公务员降职的程序(1) 所在单位提出降职安排意见(2) 对降职事由进行审核，并听取降职公务员的意见(3) 按照管理权限由有关领导集体研究决定，并依法任免。 选任制公务员的范围：(1) 中国共产党机关(2) 人大机关(3) 行政机关(4) 审判机关(5) 检察机关(6) 政协机关(7) 民主党派机关 选任制公务员的任职情形：(1) 通过选举方式任职(2) 有些选举产生的职务，在一定条件下也可决定任命 委任制方式的优点：(1) 体现治事与用人相统一 (2) 保证公务员队伍相对稳定 (3) 操作简便委任制 公务员的任职情形：(1) 新进入公务员队伍的，需要进行任职(2) 公务员职位发生变化，任免机关应及时予以任职，以确认新的职务关系 委制制的任职程序：(1) 提出拟任职人选 (2) 考察 (3) 决定任命 (4) 下发任职通知 聘任制的特点：(1) 合同管理 (2) 平等协商 (3) 任期明确 实行职位聘任的作用：(1) 实行聘任制有利于健全用人机制、增强公务员制度的生机和活力(2) 实行聘任制有利于满足机关吸引和使用多样化人才的需求(3) 实行聘任制有利于提高公务员整体素质，提高公务员队伍的专业化水平 可以实行聘任制的范围：(1) 专业性较强的职位 (2) 辅助性职位 实行聘任制的条件：(1) 工作需要 (2) 机关的选择 (3) 省级以上公务员主管部门批准 (4) 在规定的编制限额和工资经费限额内进行 聘任人选的产生：(1) 公开招聘 (2) 直接选聘 对领导成员职务实行任期制，具有重要意义：(1) 有利于实现领导职务的能上能下，形成正常的新老交替机制，建立充满生机与活力的用人机制(2) 有利于加强对领导成员的监督管理，增强领导班子的整体能力(3) 有利于保持领导班子相对稳定 国外公务员的任职权属大致分三种情形：(1) 由国家元首任用 (2) 按层次高低分别任用 (3) 由各部委首长任用 选任制公务员的免职：(1) 任期届满不再连任，所任职务自然免除(2) 任期内辞职、被罢免、被撤职的，所任职务免除 委任制公务员的免职：(1) 程序性免职的情形 (2) 单纯性免职的情形 (3) 自行免职的情形 免职的程序：(1) 提出拟免职的建议 (2) 审核 (3) 作出免职决定 (4) 发布免职通知 公务员职务晋升的原则：(1) 德才兼备、任人唯贤原则(2) 注重工作实绩原则(3) 公开、平等、竞争、择优原则(4) 逐级晋升原则 公务员职务晋升的条件：(1) 具有履行职责所需要的马克思列宁主义、毛泽东思想、邓小平理论的水平，认真实践“三个代表”重要思想，努力用马克思主义的立场、观点、方法分析和解决实际问题，坚持讲学习、讲政治、讲正气，经得起各种风浪的考验(2) 具有共产主义远大理想和中国特色社会主义坚定信念，坚决执行党的基本路线和各项方针、政策，立志改革开放，献身现代化事业，在社会主义建设中艰苦创业，作出实绩(3) 坚持解放思想，实事求是，与时俱进，开拓创新，认真调查研究，能够把党的方针、政策同本地区、本部门的实际相结合，卓有成效地开展工作，讲实话，办实事，求实效，反对形式主义(4) 有强烈的革命事业心和政治责任感，有实践经验，有胜任领导工作的组织能力、文化水平和专业知识(5) 正确行使人民赋予的权力，依法办事，清正廉洁，勤政为民，以身作则，艰苦朴素，密切联系群众，坚持党的群众路线，自觉接受党和群众的批评和监督，做到自重、自省、自警、自励，反对官僚主义，反对任何滥用职权、谋求私利的不正之风(6) 坚持和维护党的民主集中制，有民主作风，有全局观念，善于集中正确意见，善于团结同志，包括团结同自己有不同意见的同志一道工作。晋升领导职务的资格 竞争上岗工作的程序：(1) 制定并公布实施方案(2) 报名与资格审查(3) 笔试、面试(4) 民主测评、组织考察(5) 党委 (党组) 讨论决定(6) 办理任职手续 公开选拔工作的程序：(1) 发布公告 (2) 报名与资格审查 (3) 统一考试(4) 组织考察，研究提出人选方案 (5) 党委 (党组) 讨论决定 (6) 办理任职手续 国外公务员的职务晋升制度有：年资晋升制、功绩晋升制、考试晋升制、委任晋升制、越级晋升制、自荐晋升制等。 公务员降职的原则：(1) 能上能下原则 (2) 逐级降职原则 公务员降职的条件：(1) 本人不称职 (2) 不能胜任现职工作 公务员降职的方式：(1) 职薪同时降 (2) 降职不降薪 第七章 公务员奖励与惩戒 公务员奖励的基本特征(1) 公务员奖励的主体是公务员所在机关或上级机关，即具有授奖权限的机关(2) 公务员奖励的对象是公务员个人或集体(3) 公务员奖励必须依法进行。 实施公务员奖励与惩戒的意义(1) 公务员管理体系的必要环节(2) 保证党和国家的路线、方针、政策和各项法规落实的有效措施(3) 提高公务员素质的重要保障(4) 实现党政机关廉洁、高效运行的切实需要。 公务员奖励的原则(1) 精神奖励与物质奖励相结合，以精神奖励为主(2) 公平、公正、公开(3) 定期奖励与及时奖励相结合。 公务员纪律的内容A.政治纪律：(1) 不得散布有损国家声誉的言论，组织或者参加旨在反对国家的集会、游行、示威等活动(2) 不得组织或者参加非法组织，组织或者参加罢工(3) 不得在对外交往中损害国家荣誉和利益。B.组织纪律：(1) 公务员不得拒绝执行上级依法作出的决定和命令(2) 旷工或者因公外出、请假期满无正当理由逾期不归C.工作纪律：(1) 公务员不得玩忽职守，贻误工作(2) 公务员不得压制批评，打击报复。(3) 公务员不得弄虚作假，误导、欺骗领导和公众(4) 公务员不得滥用职权，侵害公民、法人或者其他组织的合法权益(5) 公务员不得泄露国家秘密或者工作秘密D.廉政纪律：(1) 公务员不得贪污、行贿、受贿，利用职务之便为自己或者他人谋取私利(2) 公务员不得违反财经纪律，浪费国家资财(3) 公务员不得从事或者参与营利性活动，在企业或者其他营利性组织中兼任职务。E.道德纪律：(1) 公务员不得参与或者支持色情、吸毒、赌博、迷信等活动(2) 公务员不得违反职业道德、社会公德。 公务员惩戒的程序(1) 初步调查 (2) 立案 (3) 正式调查 (4) 陈述和申辩 (5) 决定 (6) 告知 (7) 归档和备案。 务员奖励种类：(1) 嘉奖 (2) 记三等功 (3) 记二等功 (4) 记一等功 (5) 授予荣誉称号 行政机关公务员奖励程序：(1) 公务员所在单位提出奖励意见，上报审批机关(2) 审批机关的人事部门审核(3) 审批机关批准，并予以公布 撤销奖励的情形：(1) 弄虚作假，骗取奖励的(2) 申报奖励时隐瞒严重错误或者严重违反规定程序的(3) 有法律、法规规定应当撤销奖励的其他情形的 惩戒的条件： (1) 政治纪律，主要包括① 公务员不得散布有损国家声誉的言论，不得组织或者参加旨在反对国家的集会、游行、示威等活动② 公务员不得组织或者参加非法组织，不得组织或者参加罢工③ 公务员不得在对外交往中损害国家荣誉和利益 (2) 组织纪律① 公务员不得拒绝执行上级依法作出的决定和命令② 公务不得旷工或者因公外出、请假期满无正当理由逾期不归 (3) 工作纪律① 公务员不得玩忽职守，贻误工作② 公务不得压制批评，打击报复③ 公务员不得弄虚作假，误导、欺骗领导和公众④ 公务员不得滥用职权，侵害公民、法人或者其他组织的合法权益⑤ 公务员不得泄露国家秘密或者工作秘密 (4) 廉政纪律① 公务员不得贪污、行贿、受贿，利用职务之便为自己或者他人谋取私利② 公务员不得违反财经纪律，浪费国家资财③ 公务员不得从事或者参与营利性活动，不得在企业或者其他营业性组织中兼任职务 (5) 道德纪律① 公务员不得参与或者支持色情、吸毒、赌博、迷信等活动② 公务员不得违反职业道德、社会公德 (6) 其他纪律 惩戒的种类：(1) 警告 (2) 记过 (3) 记大过 (4) 降级 (5) 撤职 (6) 开除 行政任免机关处分公务员的程序：(1) 初步调查 (2) 立案 (3) 正式调查 (4) 陈述和申辩 (5) 决定(6) 告知 (7) 归档和备案 不同惩戒的处分期间：(1) 警告：六个月 (2) 记过：十二个月 (3) 记大过：十八个月 (4) 降级：二十四个月(5) 撤职：二十四个月 (6) 开除：不存在有限的处分期间 第八章 公务员培训 公务员培训的含义公务员培训是指国家行政机关根据经济、社会发展需要和公务员的职位要求，以政治理论、政策法规、业务知识、文化素养和技能训练为基本内容，以提高和改进公务员的素质能力为目的，通过各种形式，有组织地为公务员提供教育训练活动。 公务员培训的特点：(1) 公务员培训目标的时代性(2) 公务员培训内容的实用性(3) 公务员培训手段的多样性(4) 公务员培训方式的法定性(5) 公务员培训的持续性 公务员培训的意义(1) 提高政府服务意识，实现政府战略任务的重要保障(2) 提高政府效能，加强政府自身建设和廉政、勤政建设的重要措施(3) 建设高素质、专业化公务员队伍，提升人力资源能力的重要途径(4) 公务员的权利之一，公务员管理的重要组成部分。 公务员培训的基本原则(1) 理论联系实际 (2) 学用一致 (3) 按需施教 (4) 讲求实效。 公务员培训规划与设计(1) 了解组织的工作性质、技能要求，组织绩效的理想状况与实际状况的差距等因素，明确它们如何决定培训的必要性(2) 对培训对象、内容、方式进行分析(3) 培训主管部门所接受的培训对象的范围(4) 培训对象的规模(5) 培训工作的费用支出。(6) 确定承担培训的教育机构(7) 确定教师的素质(8) 确定培训的方式，集中或分散。 公务员培训的评估(1) 培训总体评估：注重考察三方面，即培训需求、培训规划设计、培训机制(2) 受训者的反应评估：对培训内容方面的评估 对培训方法的评估 对培训后勤保障的评估。(3) 受训者的知识、技能学习成果评估：学员在培训中的学识增长情况 学员行为方式的改进。(4) 个人绩效评估：观察法 比较法调查法(5) 组织绩效的评估：客观指标测量法 主观评价法。 公务员培训的相关法律法规和文件规定：(1) 国家法律 (2) 党内条例 (3) 党和政府相关文件 公务员培训的种类：(1) 初任培训 (2) 任职培训 (3) 专门业务培训 (4) 在职培训(5) 其他培训，包括专项培训，对口培训，MPA 专业学位教育，境外培训，通用知识和技能培训 公务员培训的内容：(1) 政治理论和政策法规培训 (2) 业务知识培训 (3) 文化素养培训和技能训练 业务知识培训的课程：(1) 公共必修课，包括公共管理，法律法规，市场经济，现代科技和行为规范(2) 专业选修课 (3) 选修课 公务员培训的施教机构：(1) 国家行政学院 (2) 地方行政学院 (2) 其他培训机构 公务员培训施教机构的管理：(1) 加强培训师资队伍和管理者队伍建设(2) 建立统一规范、科学实用的教材体系(3) 加强培训工作研究，积极推广培训工作中先进经验和做法(4) 建立公务员培训施教机构准 入制度和评估制度我国公务员培训的管理体制培训需求分析的基本要素：(1) 个体层次的培训需求分析 (2) 组织层次的培训需求分析 (3) 国家或地区战略层次的培训需求分析 培训需求分析的主要方法：(1) 培训需求的问题分析法 (2) 培训需求的全面分析法 (3) 引入行为科学或社会调查的一系列方法 问题分析法的环节：(1) 发现和确认问题阶段(2) 收集资料或直接观察(3) 分析、判断和证实造成问题的主要原则(4) 培训需求的分析(5) 说明培训需求分析的结果 全面分析法的环节：(1) 进行工作分析 (2) 编写出组织任务和所需技能的目录清单(3) 分析组织现实的绩效水平状况 (4) 培训规划设计 公务员培训规划设计的内容：(1) 了解组织工作性质、技能要求、组织绩效的理想状况与实际状况差距等因素，明确它们是如何决定培训的必要性的(2) 对培训对象、内容和方式的分析(3) 培训主管部门所接受的培训对象的范围(4) 培训对象的规模(5) 培训工作的费用支出(6) 确定承担培训的教育机构(7) 确定教师的素质(8) 确定培训是采用集中的还是分散的形式进行 公务员培训的技术方法：(1) 课堂讲授法 (2) 研讨法 (3) 案例分析法 (4) 角色扮演法 (5) 合作研究法 公务员培训评估的环节：(1) 培训总体评估 (2) 受训者反应评估 (3) 受训者知识、技能学习成果评估(4) 个人绩效的评估 (5) 组织绩效的评估 第九章 公务员交流与回避 公务员交流的含义公务员交流，是指国家机关根据工作需要或公务员的个人意愿，通过调任、转任、挂职锻炼等形式变换公务员的工作职位，从而产生或变更公务员职务关系或工作关系的一种人事管理活动与过程。(1) 公务员交流的法定形式包括调任、转任、挂职锻炼，每种形式都有特定目的、范围、对象与相应的条件、程序。(2) 交流是机关对公务员的一种管理活动和手段，必须经过机关决定安排或批办手续(3) 交流的原因包括：一是工作需要 二是通过交流锻炼提高领导能力三是避免在一个地方或部门工作时间较长产生腐败行为四是根据规定需要回避 五是照顾公务员的个人愿望。(4) 公务员交流，一般属于同一职务层次的平级调动，但也要与提拔使用、降职相结合。 公务员交流的意义(1) 有利于开阔公务员的视野，使公务员得到等方面的锻炼(2) 促进人才的合理使用(3) 有利于防止腐败行为的发生，突进廉政建设(4) 解决公务员的实际生活困难。 公务员回避的意义(1) 有利于防止腐败产生，促进国家机关廉政建设(2) 有助于公务员健康成长(3) 有助于消除政治上的不稳定因素，提高国家机关工作效率。 公务员的回避具有以下特征：(1) 强制性 (2) 预防性 公务员交流的原则(1) 依法进行原则 (2) 适才使用原则 (3) 个人服从组织原则 (4) 合理原则。 挂职锻炼管理中应当注意的问题(1) 应选好锻炼人选(2) 应选好锻炼去向(3) 应掌握好锻炼时间(4) 应加强对锻炼人员的管理。 公务员回避的原则(1) 政策配套原则(2) 依法回避原则(3) 内外监督原则(4) 自我约束原则 我国公务员回避的形式(1) 任职回避：对有特定亲属关系的公务员，在担任某些某些关系密切的职务方面做出的限制(2) 地域回避：担任一定职务的公务员，为了公正履行职务，不得在亲属比较集中的原籍、成长地等任职(3) 公务回避：公务员在执行公务的过程中，遇有法定情形，避免影响正当履行公务而进行的回避。 公务回避的特点(1) 时限性 (2) 范围更广泛 (3) 对象改更广泛。 国外公务员交流的种类：(1) 部门内同一职系的调动 (2) 跨部门跨职类调动 (3) 竞职式交流 (4) 跨地域交流 我国公务员交流的形式：(1) 调任 (2) 转任 (3) 挂职锻炼 调任的条件：(1) 调任人选要符合公务员法第十一条所规定的担任公务员的七项基本条件，这是所有公务员都应当具备的条件(2) 调任人选要符合拟任职位所要求的资格条件(3) 调任人选还必须符合公务员法第二十四条的规定，即不能是因犯罪受到刑事处罚、被开除公职或有法律规定不得成为公务员的其他情形的人员 转任原因包括：(1) 机关根据工作需要决定公务员转任(2) 经公务员个人申请、机关批准同意的转任 转任必须符合三方面的要求：(1) 转任公务员必须具备拟任职位所要求的资格条件(2) 转任必须在规定的编制限额和职数内进行(3) 转任中如果出现职务升降，应当按照公务员职务升降的有关规定，履行必要的程序 理解领导成员的转任要求，需要把握以下几点：(1) 在领导干部转任的问题上，公务员法充分吸收了《党政领导干部选拔任用工作条例》的成果(2) 公务员法特别强调领导成员交流的重要性，专门规定了领导成员转任的要求(3) 领导成员转任指“省部级正职以下”的领导 理解对担任机关内设机构领导职务和工作性质特殊的非领导职务的公务员转任要求，应当从以下几个方面入手：(1) “工作性质特殊的非领导职务”是指，直接经管“人、财、物”和执行执法监督职能的职务(2) 这类转任的范围主要在本机关内部，一般不跨地区、跨部门进行(3) 这类转任是具有强制性的，公务员个人有义务服从组织决定(4) 这类转任要有计划性，应事先制订计划，确定转任的具体人员、转任去向、转任时机等 与调任、转任相比，挂职锻炼的特殊性：(1) 挂职锻炼不办理调动手续(2) 挂职锻炼有时间性(3) 挂职锻炼是一种内外混合型的交流形式 挂职锻炼的种类：(1) 进行实践锻炼 (2) 进行培养锻炼 (3) 进行使用锻炼 挂职锻炼管理中应注意的问题：(1) 应选好锻炼人选 (2) 应掌握好锻炼时间 (3) 应加强对锻炼人员的管理 在国外，需要回避的亲属关系主要有：(1) 血亲关系 (2) 夫妻关系 (3) 姻亲关系 (4) 拟制亲关系 我国公务员回避的形式：(1) 任职回避 (2) 地域回避 (3) 公务回避 公务回避的特点：(1) 公务回避具有时限性 (2) 公务回避的范围更广泛 (3) 公务回避的对象更广泛 公务回避的范围：(1) 涉及本人利害关系的(2) 涉及与本人有夫妻关系、直系血亲关系、三代以内旁系血亲关系、近姻亲关系人员的利害关系的(3) 其他可能影响公正执行公务的情形 公务员回避的提起有两种情形：(1) 公务员本人主动申请回避(2) 利害关系人发现公务员有法律规定的应当回避的情形，可以提出要求公务员回避 第十章 公务员工资、福利与保险 建立公务员工资保险福利制度的意义 (1) 有利于保障公务员的基本需求 (2) 有利于调动公务员的积极性 (3) 有利于吸纳高素质人才。 制定公务员工资制度的基本原则 (1) 按劳分配原则：体现工作职责、工作能力、工作实绩、资历等因素；体现不同职务、级别之间合理的工资差距。 (2) 正常增资原则：定期增加公务员的工资； (3) 平衡比较原则：公务员工资水平与企业单位相当人员的工资水平大体保持平衡。 (4) 法律保障原则：公务员工资制度以法律形式确定。 在落实平衡比较原则过程中，如何建立工资调查制度 (1) 确定相当人员的界定条件，并对工资收入、福利待遇等进行比较； (2) 确定如何应用工资调查比较结果考虑公务员工资水平，主要考虑国民经济发展水平、财政承受能力、企业相当人员工资水平等因素； (3) 确定机构、人员的抽样条件； (4) 建立调查系统，确定调查方式。 公务员工资构成 (1) 基本工资：包括职务工资、级别工资； (2) 津贴：包括地区附加津贴、艰苦边远地区津贴、岗位津贴； (3) 补贴； (4) 奖金。 公务员福利的作用 (1) 对公务员的基本生活需要给予必要的保障； (2) 提高公务员的物质文化生活需要水平； (3) 增加公务员队伍的吸引力和凝聚力。 公务员福利制度存在的问题和改革趋势 A. 存在的问题： (1) 福利制度比较陈旧，总体水平偏低 (2) 福利发放差距大和平均主义并存； (3) 改革滞后，与各项制度不配套。 B. 改革趋势： 按照“职务与级别相结合的制度，建立公务员激励和保障机制”的要求， 将提高工资和改革福利相结合，坚持福利货币化、透明化、规范化的方向，实行合理的福利待遇。 公务员保险的作用 (1) 为丧失劳动能力的公务员提供基本生活保障； (2) 为暂时丧失劳动能力的公务员提供必要的物质帮助，进而促进经济发展，稳定社会 (3) 使公务员亲身感觉到职业的优越性，工作自豪感和荣誉感，进而调动公务员的工作积极性。 公务员保险制度存在的问题和改革的趋势 A. (1) 没有建立基金积累制度 (2) 保险制度不健全，失业保险尚未建立起来 (3) 管理不科学，缺乏有效的约束监督机制。医疗等经费增长过快，浪费严重。 B. (1) 改变离退休费由国家统包、现收现付的状况，建立养老保险基金由国家、个人共同合理负担，符合机关特点的社会养老保险积极的筹集和运营机制。 (2) 建立失业保险制度。 (3) 实行工伤保险制度。 (4) 按照行政管理和基金运营分开原则，实行养老、实业、工伤、医疗等保险基金管理。 英国公务员的津贴主要有： (1) 伦敦补贴 (2) 超时勤务补贴 (3) 假日勤务津贴 (4) 夜间勤务津贴 (5) 技能津贴 美国公务员的津贴主要有：(1) 地区津贴 (2) 特殊工作津贴 (3) 其他津贴 公务员福利的项目：(1) 休假制度 (2) 优抚制度 (3) 其他福利制度 (4) 公务员工时制度 现阶段公务员福利制度存在的问题：(1) 福利制度比较陈旧，总体水平偏低(2) 福利发放差距大和平均主义并存(3) 改革滞后，与各项制度改革不配套 公务员保险的项目：(1) 基本医疗保险制度 (2) 生育保险制度 新西兰公务员的养老体系主要包括：(1) 养老金制度 (2) 政府养老金基金制度 (3) 节俭计划 公务员保险制度存在的问题：(1) 没有建立基金积累制度(2) 保险制度不健全，失业保险尚未建立起来(3) 管理不科学，缺乏有效的约束监督机制 第十一章 公务员辞职、辞退与退休 建立公务员辞职制度的意义(1) 有利于畅通公务员队伍的出口，形成能进能出的更新机制(2) 落实了自由选择职业的权利，有利于提高员工的积极性(3) 有利于规范机关的人事管理行为。 建立公务员辞退制度的意义(1) 体现优胜劣汰的竞争机制(2) 保证公务员队伍充满活力(3) 建立高效廉洁政府的有效措施。 建立公务员退休制度的意义(1) 有利于公务员队伍新老交替的正常化，增强公务员队伍的生机或活力(2) 是宪法赋予公务员老有所养权利的真正体现，是对公务员履行退休义务的监督(3) 是调节公务员领导职务、克服公务员领导职务终身制的重要形式(4) 有利于廉政勤政建设。 公务员辞去公职的特征(1) 辞去公职是公务员自主择业的权利(2) 辞去公职必须经过法律程序(3) 辞去公职的公务员享受法定的辞职待遇(4) 辞去公职权利的限制性。 辞去公职与擅自离职的区别辞去公职与擅自离职都是公务员本人意愿的表现，其区别包括：(1) 公务员辞去公职的意愿得到法律确认，受法律保护；擅自离职的意愿没有得到法律认定，公务员必须承担不履行义务的后果(2) 辞去公职是公务员自主择业的权利，公务员是否行使该权利及其法律后果，由公务员自行处理；擅自离职是一种违纪行为，要被追究责任。 辞去公职与免职的区别免职是公务员任免机关依照法定事由和法定程序，免除公务员所担任职务的人事行政行为。二者差别：(1) 性质不同：辞去公职是公务员自主择业的权利，是公务员自愿的法律行为；免职是机关的人事行政行为，是任免机关等单方面的法律行为，公务员必须服从。(2) 原因不同：辞去公职出于公务员的个人意愿；免职基于法定事由，如转任。(3) 法律后果不同：辞去公职是公务员与机关职务关系的废除；免职包括两种情况，一是因退休、离休、辞退等原因的免职，终止公务员与机关的职务关系；二是由于公务员职务变更、工作职位变换引起的免职，公务员的职务关系不变，为了任新职。 公务员辞去公职的限制性条件公务员有下列情形之一的，不得辞去公职：(1) 未满国家规定的最低服务年限的(2) 在涉及国家秘密等特殊职位任职或者离开上述职位不满国家规定的脱密期限的(3) 重要公务尚未处理完毕，且须由本人继续处理的(4) 正在接受审计、纪律审查，或者涉嫌犯罪，司法程序尚未终结的(5) 法律、行政法规规定的其他不得辞去公职的情形。 公务员自愿辞去领导职务的限制性条件(1) 在涉及国家安全、重要机密等特殊职位上任职或者离开上述职位不满解密期限的(2) 有重要公务尚未处理完毕，而且须由本人继续处理的(3) 由人大、政协选举、任命、决定任命的领导干部任职不满一年的(4) 正在接受纪检机关 (监察部门) 、司法机关调查或者审计机关审计的； 党政领导干部引咎辞去领导职务的程序 党政领导干部引咎辞职应当经过下列程序： (1) 干部本人按照干部管理权限，以书面形式向党委 (党组) 提出辞职申请，说明辞职原因和思想认识等。 (2) 组织 (人事) 部门对辞职原因等情况进行了解审核，并提出初步意见。 (3) 按照干部管理权限，党委 (党组) 集体研究，作出同意辞职、不同意辞职或者暂缓辞职的决定。 党委 (党组) 的决定应当及时通知干部所在单位和干部本人。 (4) 党委 (党组) 作出同意辞职决定后，按照有关规定办理辞职手续。 辞去公职的法律后果： (1) 职务关系废除、公务员身份消失 (2) 失去公职待遇 辞去领导职务的类型： (1) 因公辞去领导职务 (2) 自愿辞去领导职务 (3) 引咎辞去领导职务 (4) 责令辞去领导职务 责令辞去领导职务的程序 责令辞职应当经过下列程序：(1) 党委 (党组) 作出责令干部辞职的决定，并指派专人与干部本人谈话。责令干部辞职的决定应当以书面形式通知干部本人。 (2) 被责令辞职的干部应当在接到责令辞职通知后 15 日内向任免机关提出书面辞职申请。 (3) 按照有关规定办理辞职手续。由人大、政协选举、任命、决定任命的领导干部，依照法律或者政协章程的有关规定办理。 建立辞去领导职务的相关措施(1) 妥善安置辞去领导职务的公务员(2) 建立科学的岗位责任制和科学的考核评价体系(3) 加强职业道德建设，增强责任意识。 公务员辞退的特点(1) 辞退公务员是国家机关法定的用人权利(2) 辞退公务员基于法定事实(3) 辞退公务员必须基于法定程序(4) 被辞退的公务员享受法定的辞退待遇。 辞退与开除的差别辞退和开除都终止了公务员与机关的职务关系，公务员身份消失，是行政机关的单方面行为。二者差别： (1) 性质不同：开除是行政处分，具有惩戒性；辞退不是行政处分，无惩戒性(2) 原因不同：辞退的原因是公务员的德才表现或主观努力不够而不能胜任公务员职务，无法履行公务员义务；开除的原因是公务员违法乱纪行为。(3) 法律后果不同：辞退的公务员可以获得辞退费，并享受失业保险；被开除的公务员享受失业保险，但不享受其他待遇。 公务员可被辞退的条件公务员有下列情形之一的，予以辞退：(1) 在年度考核中，连续两年被确定为不称职的； (2) 不胜任现职工作，又不接受其他安排的； (3) 因所在机关调整、撤销、合并或者缩减编制员额需要调整工作，本人拒绝合理安排的； (4) 不履行公务员义务，不遵守公务员纪律，经教育仍无转变，不适合继续在机关工作，又不宜给予开除处分的； (5) 旷工或者因公外出、请假期满无正当理由逾期不归连续超过十五天，或者一年内累计超过三十天的。 公务员不能被辞退的条件对有下列情形之一的公务员，不得辞退： (1) 因公致残，被确认丧失或者部分丧失工作能力的； (2) 患病或者负伤，在规定的医疗期内的； (3) 女性公务员在孕期、产假、哺乳期内的； (4) 法律、行政法规规定的其他不得辞退的情形。 确定公务员退休待遇的原则(1) 国家保障原则(2) 法律保障原则(3) 退休待遇与社会发展水平相适应原则(4) 退休金免税原则。 辞退公务员的法定程序：(1) 由拟被辞退公务员所在单位提出建议，陈述辞退事实和理由(2) 所在单位按管理权限报任免机关审批(3) 任免机关批准了辞退的，应以书面形式通知被辞退公务员本人 公务员辞退的法律后果：(1) 公务员与机关的职务关系废除，公务员身份消失(2) 按照规定享受辞退待遇 提前退休的条件有：(1) 工作年限满 30 年的(2) 距国家规定的退休年龄不足五年，且工作年限满 20 年的(3) 符合国家规定的可以提前退休的其他情形的 公务员的退休待遇：(1) 退休公务员的政治待遇 (2) 退休金待遇 (3) 其他待遇 第十二章 公务员申诉与控告 公务员申诉的含义公务员申诉，是指公务员依照公务员法的规定，对国家机关做出的涉及本人合法权益的人事处理决定不服时，向有关机关说明和陈述，并要求采取措施予以纠正和保护的行为。 公务员申诉与其他申诉的不同之处在于： (1) 申诉者仅限于对机关做出的人事处理决定不服的公务员(2) 申诉事由是指机关做出的人事处理决定(3) 申诉对象是具有行政隶属关系或管理关系的行政机关(4) 受理申诉的机关由公务员法确定。 公务员申诉与控告的主要区别(1) 目的不同：申诉目的是使机关改变或撤销人事处理决定，以恢复自己的合法权益，弥补损失；控告目的是为了恢复和补偿自己的合法权益，并追究有关机关或人员的责任。(2) 原因不同：引起申诉的原因是公务员对已经发生效力的人事处理决定不服，要求重新审理；控告的原因是公务员的合法权益受到不法侵害，要求对有关责任人进行惩处。 公务员申诉与控告的意义(1) 实现公务员权利的重要保障(2) 调动公务员积极性的重要保证(3) 有利于促进公务员管理机关公正廉政建设。 申诉事由包括：(1) 处分 (2) 辞退或者取消录用 (3) 降职 (4) 定期考核定为不称职 (5) 免除(6) 申请辞职、提前退休未予批准 (7) 未按规定确定或者扣减工资、福利、保险待遇 (8) 法律、法规规定可以申诉的其他情形 在中国，受理公务员申诉的机关为：(1) 原处理机关 (2) 同级公务员主管部门 (3) 上一级机关 (4) 行政监察机关 公务员申诉程序A. 一般申诉程序：(1) 公务员对涉及本人的人事处理决定不服(2) 向原处理机关提出复核申请(3) 公务员对复核决定不服(4) 向同级公务员主管部门、上一级行政机关提出申诉(5) 公务员对省级以下机关做出的申诉处理决定不服(6) 向上一级机关提出再申诉。 B. 径直申诉程序：(1) 公务员对涉及本人的人事处理决定不服(2) 向同级公务员主管部门或上一级行政机关提出申诉(3) 公务员对省级以下机关做出的申诉处理决定不服(4) 向上一级机关提出再申诉。 C. 特别申诉程序：(1) 公务员对涉及本人的人事处理决定不服(2) 向行政监察机关提出申诉(3) 公务员对省级以下行政监察机关做出的申诉处理决定不服(6) 向上一级机关提出复核申请。 公务员控告的处理程序？(1) 立案(2) 调查(3) 审理(4) 做出处理决定或建议(5) 执行。 人事争议仲裁的原则(1) 合法原则：以事实为依据，以法律为准绳(2) 公正：秉公执法，一视同仁(3) 及时处理：在法定期限内，尽快裁决。 人事争议仲裁书应当载明下列事项：(1) 申请人姓名、性别、年龄、职业、工作单位和住所(2) 被申请人的姓名、性别、年龄、职业、工作单位和住所(3) 仲裁请求和所根据的事实、理由(4) 证据和证据来源、证人姓名和住所","link":"/2021/02/01/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/%E5%85%AC%E5%8A%A1%E5%91%98%E5%88%B6%E5%BA%A6/%E5%85%AC%E5%8A%A1%E5%91%98%E4%B8%BB%E8%A7%82%E9%A2%98/"},{"title":"自检清单1","text":"开篇本文参考文章《一名【合格】前端工程师的自检清单》, 并对其中的部分题目进行了解答，若有遗漏或错误之处望大家指出纠正，共同进步。(点击题目展开答案！) 一、JavaScript 基础前端工程师吃饭的家伙，深度、广度一样都不能差。 变量和类型 1. JavaScript 规定了几种语言类型? JavaScript 中的每一个值都有它自己的类型，JavaScript 规定了七种语言类型，他们是： Undefined Null Boolean String Number Symbol Object 2. JavaScript 对象的底层数据结构是什么? 对象数据被存储于堆中 (如对象、数组、函数等，它们是通过拷贝和new出来的）。 引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。 3. Symbol 类型在实际开发中的应用、可手动实现一个简单的 Symbol？ ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。 symbol类型的 key 不能被 Object.keys 和 for..of 循环枚举。因此可当作私有变量使用。 12345678let mySymbol = Symbol('key');// 第一种写法let a = {};a[mySymbol] = 'Hello!';// 第二种写法let a = { [mySymbol]: 'Hello!'}; 4. JavaScript 中的变量在内存中的具体存储形式 JavaScript 中的变量分为基本类型和引用类型: 基本类型: 保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，通过按值访问 引用类型: 保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript 不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用 5. 基本类型对应的内置对象，以及他们之间的装箱拆箱操作 String(), Number(), Boolean() 装箱：就是把基本类型转变为对应的对象。装箱分为隐式和显示 12345678910// 隐式装箱： 每当读取一个基本类型的值时，后台会创建一个该基本类型所对应的对象。// 在这个基本类型上调用方法，其实是在这个基本类型对象上调用方法。// 这个基本类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立刻被销毁。let num=123;num.toFixed(2); // '123.00'//上方代码在后台的真正步骤为var c = new Number(123);c.toFixed(2);c = null;// 显式装箱: 通过内置对象 Boolean、Object、String 等可以对基本类型进行显示装箱。var obj = new String('123'); 拆箱: 拆箱与装箱相反，把对象转变为基本类型的值。 1234Number([1]); //1// 转换演变：[1].valueOf(); // [1];[1].toString(); // '1';Number('1'); //1 6. 理解值类型和引用类型 JavaScript 中的变量分为基本类型和引用类型: 基本类型: 保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，通过按值访问 引用类型: 保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript 不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用 7. null 和 undefined 的区别 Number 转换的值不同，Number(null) 输出为 0, Number(undefined) 输出为 NaN null 表示一个值被定义了，但是这个值是空值 undefined 表示缺少值，即此处应该有值，但是还没有定义 8. 至少可以说出三种判断 JavaScript 数据类型的方式，以及他们的优缺点，如何准确的判断数组类型 typeof —— 返回给定变量的数据类型，可能返回如下字符串：12345678'undefined'——Undefined'boolean'——Boolean'string'——String'number'——Number'symbol'——Symbol'object'——Object / Null （Null 为空对象的引用）'function'——Function// 对于一些如 error() date() array()无法判断，都是显示object类型 instanceof 检测 constructor.prototype 是否存在于参数 object 的原型链上，是则返回 true，不是则返回 false。12345alert([1,2,3] instanceof Array) // truealert(new Date() instanceof Date) // truealert(function(){this.name=&quot;22&quot;;} instanceof Function) //truealert(function(){this.name=&quot;22&quot;;} instanceof function) //false// instanceof 只能用来判断两个对象是否属于实例关系，而不能判断一个对象实例具体属于哪种类型。 constructor —— 返回对象对应的构造函数。1234567891011121314alert({}.constructor === Object); =&gt; truealert([].constructor === Array); =&gt; truealert('abcde'.constructor === String); =&gt; truealert((1).constructor === Number); =&gt; truealert(true.constructor === Boolean); =&gt; truealert(false.constructor === Boolean); =&gt; truealert(function s(){}.constructor === Function); =&gt; truealert(new Date().constructor === Date); =&gt; truealert(new Array().constructor === Array); =&gt; truealert(new Error().constructor === Error); =&gt; truealert(document.constructor === HTMLDocument); =&gt; truealert(window.constructor === Window); =&gt; truealert(Symbol().constructor); =&gt; undefined // null 和 undefined 是无效的对象，没有 constructor，因此无法通过这种方式来判断。 Object.prototype.toString() 默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，是一个字符串，其中 Xxx 就是对象的类型。1234567891011121314151617Object.prototype.toString.call(new Date);//[object Date]Object.prototype.toString.call(new String);//[object String]Object.prototype.toString.call(Math);//[object Math]Object.prototype.toString.call(undefined);//[object Undefined]Object.prototype.toString.call(null);//[object Null]Object.prototype.toString.call('') ; // [object String]Object.prototype.toString.call(123) ; // [object Number]Object.prototype.toString.call(true) ; // [object Boolean]Object.prototype.toString.call(Symbol()); //[object Symbol]Object.prototype.toString.call(new Function()) ; // [object Function]Object.prototype.toString.call(new Date()) ; // [object Date]Object.prototype.toString.call([]) ; // [object Array]Object.prototype.toString.call(new RegExp()) ; // [object RegExp]Object.prototype.toString.call(new Error()) ; // [object Error]Object.prototype.toString.call(document) ; // [object HTMLDocument]Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用// 比较全面 9. 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用 隐式转换一般说的是 Boolean 的转换 在 if 语句中，null，&quot;&quot;，undefinded, 0, false 都会被转化为 false 一般应用于对接口数据判空时使用 10. 出现小数精度丢失的原因，JavaScript 可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法 精度丢失原因，说是 JavaScript 使用了 IEEE 754 规范，二进制储存十进制的小数时不能完整的表示小数 能够表示的最大数字 Number.MAX_VALUE 等于 1.7976931348623157e+308 ,最大安全数字 Number.MAX_SAFE_INTEGER 等于 9007199254740991 避免精度丢失 计算小数时，先乘 100 或 1000，变成整数再运算 如果值超出了安全整数，有一个最新提案，BigInt 大整数，它可以表示任意大小的整数，注意只能表示整数，而不受安全整数的限制 原型和原型链 1. 理解原型设计模式以及 JavaScript 中的原型规则 A. 所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性； B. 所有的引用类型（数组、对象、函数），都有一个`__proto__`属性（隐式原型），属性值是一个普通的对象； C. 所有的函数，都具有一个 `prototype`（显式原型），属性值也是一个普通对象； D. 所有的引用类型（数组、对象、函数），其隐式原型指向其构造函数的显式原型；`（obj._proto_ === Object.prototype）`； E. 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的 `__proto__` （即它的构造函数的 `prototype`）中去寻找； 2. instanceof 的底层实现原理，手动实现一个 instanceof 简单说就是判断实例对象的__proto__是不是强等于对象的prototype属性，如果不是继续往原型链上找，直到 __proto__ 为 null 为止。 1234567891011function instanceOf(obj, object) {//obj 表示实例对象，object 表示对象 var O = object.prototype; obj = obj.__proto__; while (true) { if (obj === null) return false; if (O === obj) // 这里重点：当 O 严格等于 obj 时，返回 true return true; obj = obj.__proto__; } } 3. 理解 JavaScript 的执行上下文栈，可以应用堆栈信息快速定位问题 执行上下文 就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。 执行上下文总共有三种类型：全局执行上下文, 函数执行上下文, Eval 函数执行上下文 执行栈，在其他编程语言中也被叫做调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。 4. 实现继承的几种方式以及他们的优缺点 详情请点击：《继承的几种实现方式》 5. 可以描述 new 一个对象的详细过程，手动实现一个 new 操作符 new一个对象的详细过程: 12function Test() {}const test = new Test(); 创建一个对象 const obj = {} 设置新对象的 constructor 属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的 prototype 对象 12obj.constructor = Test;obj.__proto__ = Test.prototype; 使用新对象调用函数，函数中的 this 被指向新实例对象 Test.call(obj) 将初始化完毕的新对象地址，保存到等号左边的变量中 实现一个new操作符 12345function myNew(Obj, ...args) { var obj = Object.create(Obj.prototype); //使用指定的原型对象及其属性去创建一个新的对象 Obj.apply(obj, args); // 绑定 this 到obj, 设置 obj 的属性 return obj; // 返回实例} 6. 理解 es6 class 构造以及继承的底层实现原理 ES6 类的底层还是通过构造函数去创建的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 // es6 Parent类实现 class Parent { constructor(name,age){ this.name = name; this.age = age; } speakSomething(){ console.log(&quot;I can speek chinese&quot;); } } // 转化为 var Parent = function () { function Parent(name, age) { _classCallCheck(this, Parent); // 判断实例 Parent instanceof Parent（函数）是否为true this.name = name; this.age = age; } // 此方法通过使用 Object.defineProperty 为 function Parent 的 prototype 添加属性值 _createClass(Parent, [{ key: &quot;speakSomething&quot;, value: function speakSomething() { console.log(&quot;I can speek chinese&quot;); } }]); return Parent;}();````- `ES6` 的继承实现```js//定义子类，继承父类class Child extends Parent { static width = 18 constructor(name,age){ super(name,age); } coding(){ console.log(&quot;I can code JS&quot;); }}// 转化为var Child = function (_Parent) { _inherits(Child, _Parent); function Child(name, age) { _classCallCheck(this, Child); return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).call(this, name, age)); } _createClass(Child, [{ key: &quot;coding&quot;, value: function coding() { console.log(&quot;I can code JS&quot;); } }]); return Child;}(Parent);````这里其实就是多了一个 `_inherits(Child, _Parent);` 方法，实现了以下功能，具体可看文章[《ES6 类以及继承的实现原理》](https://segmentfault.com/a/1190000014798678)![](https://user-gold-cdn.xitu.io/2019/7/16/16bf9e1cf102bbb4?w=800&amp;h=501&amp;f=png&amp;s=116099)```js//实现的结果是：subClass.prototype.__proto__ = superClass.prototype;subClass.__proto__ = superClass; // 实现静态属性的继承 作用域和闭包 1. 理解词法作用域和动态作用域 词法作用域也称静态作用域，javascript 采用静态作用域 静态作用域 —— 函数的作用域基于函数创建的位置。 动态作用域 —— 函数的作用域基于函数的使用位置。 123456789101112var value = 1;function foo() { console.log(value);}function bar() { var value = 2; foo();}bar(); // 输出 1 。JavaScript 采用的是词法作用域，也称为静态作用域。相同的，动态作用域此代码应该输出 2 2. 理解 JavaScript 的作用域和作用域链 作用域（scope）就是变量访问规则的有效范围。 在 JavaScript 中全局变量的作用域是全局的，在代码的任何地方都是有定义的。然而函数的参数和局部变量只在函数体内有定义。另外局部变量的优先级要高于同名的全局变量,也就是说当局部变量与全局变量重名时，局部变量会覆盖全局变量。 3. this的原理以及几种不同使用场景的取值 this的几种不同使用场景的取值 + JavaScript 的 this 原理 4. 闭包的实现原理和作用，可以列举几个开发中闭包的实际应用 原理：闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 作用：闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 应用：1. 匿名自执行函数 2. 结果缓存 3. 封装局部变量 参考链接：《学习 Javascript 闭包（Closure）》 5. 理解堆栈溢出和内存泄漏的原理，如何防止 堆栈溢出 的产生是由于过多的函数调用，导致调用堆栈无法容纳这些调用的返回地址，一般在递归中产生。堆栈溢出很可能由无限递归（Infinite recursion）产生，但也可能仅仅是过多的堆栈层级. 参考链接：《内存泄漏与避免》 6. 如何处理循环的异步操作 将异步操作变同步，使用 async/await. 去掉循环，将循环变成递归 执行机制 1. 为何 try 里面放 return，finally 还会执行，理解其内部机制 在 try 语句中，在执行 return 语句时，要返回的结果已经准备好了，就在此时，程序转到 finally 执行了。 在转去之前，try 中先把要返回的结果存放到局部变量中去，执行完 finally 之后，在从中取出返回结果。 因此，即使finally 中对返回的结果进行了改变，但是不会影响返回结果。 它应该使用栈保存返回值。 2. JavaScript 如何实现异步编程，可以详细描述 EventLoop 机制 JavaScript 如何实现异步编程: callback (回调函数)回调函数代表着，当某个任务处理完，然后需要做的事。比如读取文件，连接数据库，等文件准备好，或数据库连接成功执行编写的回调函数，又比如像一些动画处理，当动画走完，然后执行回调。 发布订阅模式顾名思义，便是先订阅了事件，有人一发布事件你就知道了，接着执行后面的操作。 PromisePromise，简单说就是一个容器，里面保存着某个未来才会结束的事件的结果，相比回调函数，Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Generator (生成器)函数Generator 函数是 ES6 提供的一种异步编程解决方案，其行为类似于状态机。 async/awaitasync/await 本质上还是基于 Generator 函数，可以说是 Generator 函数的语法糖，async 就相当于之前写的 run 函数(执行Generator函数的函数),而 await 就相当于 yield ，只不过 await 表达式后面只能跟着 Promise 对象，如果不是 Promise 对象的话，会通过 Promise.resolve 方法使之变成 Promise 对象。async 修饰 function,其返回一个 Promise 对象。 《浏览器 Event Loop 机制》 3. 宏任务和微任务分别有哪些 宏任务： setTimeout，setInterval，setImmediate (Node独有)，requestAnimationFrame (浏览器独有)，I/O，UI rendering (浏览器独有) 微任务： process.nextTick (Node 独有)，Promise，Object.observe，MutationObserver 4. 可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法 123456789101112131415161718192021222324252627282930313233343536// 执行顺序，先微队列，后宏队列。console.log(1);setTimeout(() =&gt; { console.log(2); setTimeout(() =&gt; { console.log(8); }) Promise.resolve().then(() =&gt; { console.log(3) });});new Promise((resolve, reject) =&gt; { console.log(4) setTimeout(() =&gt; { console.log(10); }) resolve()}).then(() =&gt; { console.log(5); Promise.resolve().then(() =&gt; { console.log(11) }); setTimeout(() =&gt; { console.log(13); })})setTimeout(() =&gt; { Promise.resolve().then(() =&gt; { console.log(9) }); console.log(6); setTimeout(() =&gt; { console.log(12); })})console.log(7); 从头至尾执行一次代码,根据上面分类规则分至不同队列, new promise( function ) 也是立即执行。setTimeout 的回调函数属于宏队列（macrotask），resolve 的回调函数属于微队列 1234// 栈区（stack）console.log(1);console.log(4);console.log(7); 12345678910111213141516171819202122// 宏队列() =&gt; { console.log(2); setTimeout(() =&gt; { console.log(8); }); Promise.resolve().then(() =&gt; { console.log(3); });};() =&gt; { console.log(10);};() =&gt; { Promise.resolve().then(() =&gt; { console.log(9); }); console.log(6); setTimeout(() =&gt; { console.log(12); });}; 12345678910// 微队列() =&gt; { console.log(5); Promise.resolve().then(() =&gt; { console.log(11); }); setTimeout(() =&gt; { console.log(13); });}; 优先执行微队列，微队列执行过程中产生的微队列和宏队列置于队列末尾排序执行，而宏队列产生的微队列和宏队列于新的队列中等待。。 执行微队列：（分类） 123456// 栈区（stack）console.log(1);console.log(4);console.log(7);//////////console.log(5); 1234// 微队列() =&gt; { console.log(11)}); 12345678910111213141516171819202122232425// 宏队列() =&gt; { console.log(2); setTimeout(() =&gt; { console.log(8); }); Promise.resolve().then(() =&gt; { console.log(3); });};() =&gt; { console.log(10);};() =&gt; { Promise.resolve().then(() =&gt; { console.log(9); }); console.log(6); setTimeout(() =&gt; { console.log(12); });};() =&gt; { console.log(13);}; 此时新增了一个微队列console.log(11),因为是微队列产生的，继续执行： 12345678// 栈区（stack）console.log(1);console.log(4);console.log(7);//////////console.log(5);/////////console.log(11); 1// 微队列-空 12345678910111213141516171819202122232425// 宏队列() =&gt; { console.log(2); setTimeout(() =&gt; { console.log(8); }); Promise.resolve().then(() =&gt; { console.log(3); });};() =&gt; { console.log(10);};() =&gt; { Promise.resolve().then(() =&gt; { console.log(9); }); console.log(6); setTimeout(() =&gt; { console.log(12); });};() =&gt; { console.log(13);}; 执行完微队列后执行宏队列： 12345678910111213// 栈区（stack）console.log(1);console.log(4);console.log(7);//////////console.log(5);/////////console.log(11);/////////console.log(2);console.log(10);console.log(6);console.log(13); 1234567// 微队列() =&gt; { console.log(3);};() =&gt; { console.log(9);}; 1234567// 宏队列() =&gt; { console.log(8);};() =&gt; { console.log(12);}; 接下来执行微队列后宏队列，即： 12345678910111213141516171819// 栈区（stack）console.log(1);console.log(4);console.log(7);//////////console.log(5);/////////console.log(11);/////////console.log(2);console.log(10);console.log(6);console.log(13);////////console.log(3);console.log(9);////////console.log(8);console.log(12); 5. 使用 Promise 实现串行 1234567891011 // 一个 promise 的 function function delay(time) { return new Promise((resolve, reject) =&gt; { console.log(`wait ${time}s`) setTimeout(() =&gt; { console.log('execute'); resolve() }, time * 1000) })}const arr = [3, 4, 5]; reduce123 arr.reduce((s, v) =&gt; { return s.then(() =&gt; delay(v))}, Promise.resolve()) async + 循环 + await1234567 ( async function () { for (const v of arr) { await delay(v) } })() 普通循环1234 let p = Promise.resolve()for (const i of arr) { p = p.then(() =&gt; delay(i))} 递归12345 function dispatch(i, p = Promise.resolve()) { if (!arr[i]) return Promise.resolve() return p.then(() =&gt; dispatch(i + 1, delay(arr[i])))}dispatch(0) 6. Node 与浏览器 EventLoop 的差异 《JavaScript 运行机制详解：再谈Event Loop》 《带你彻底弄懂 Event Loop》 7. 如何解决页面加载海量数据而页面不卡顿 分治思想，在一定的时间内多次加载数据，直至渲染完成，使用 window.requestAnimationFrame 和 document.createDocumentFragment() 实现, 可参考文章【如何解决页面加载海量数据而不冻结前端UI】 局部显示，毕竟用户能看到的就一屏内容，监听用户的滚动行为，改变显示元素，可使 DOM 结构最简单化。可参考文章【大数据如何在前端流畅展示】,不过他的 Demo有点问题. 语法和 API 1. 理解 ECMAScript 和 JavaScript 的关系 ECMAScript 是 JavaScript 的规范，JavaScript 是 ECMAScript 的实现。 2. 熟练运用 es5、es6 提供的语法规范 【JavaScript 标准参考教程（alpha）】 【ECMAScript 6 入门】 3. setInterval 需要注意的点，使用 settimeout 实现 setInterval setInterval 需要注意的点: 在使用 setInterval 方法时，每一次启动都需要对 setInterval 方法返回的值做一个判断，判断是否是空值，若不是空值，则要停止定时器并将值设为空，再重新启动，如果不进行判断并赋值，有可能会造成计时器循环调用，在同等的时间内同时执行调用的代码，并会随着代码的运行时间增加而增加，导致功能无法实现，甚至占用过多资源而卡死奔溃。因此在每一次使用setInterval方法时，都需要进行一次判断。 1234567let timer = setInterval(func, 1000)// 在其他地方再次用到setInterval(func, 1000)if (timer !== null) { clearInterval(timer) timer = null}timer = setInterval(func, 1000) 使用 settimeout 实现 setInterval 12345setIntervalFunc = () =&gt;{ console.log(1) //使用递归 setTimeout(setIntervalFunc, 1000);};setInterval() 4. JavaScript 提供的正则表达式 API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题 邮箱校验： 123function isEmail(emailStr) { return /^[a-zA-Z0-9]+([._-]*[a-zA-Z0-9]*)*@[a-zA-Z0-9]+.[a-zA-Z0-9{2,5}$]/.test(emailStr);} URL解析: 123function isUrl(urlStr) { return /^(?:http(s)?:\\/\\/)?[\\w.-]+(?:\\.[\\w\\.-]+)+[\\w\\-\\._~:/?#[\\]@!\\$&amp;'\\*\\+,;=.%]+$/.test(value)} 数组去重： 1234567891011121314151617181920212223// set结构let arr = [1, 1, 2, 2, 3, 3];arr2 = [...new Set(arr)];console.log(arr2); // [1,2,3]// Object.keys(), 利用属性 key 的唯一性let arrObj = [1, 1, 2, 2, 3, 3];arrObj2 = {};for (i in arrObj) { arrObj2[arrObj[i]] = true;}let arrObj3 = Object.keys(arrObj2);console.log(arrObj3);// 利用 indexOf() 查询数组内是否已经包含该元素var arrIndexOf = ['a', 'c', 'b', 'd', 'a', 'b'];var arrIndexOf2 = [];for (var i = 0; i &lt; arrIndexOf.length; i++) { if (arrIndexOf2.indexOf(arrIndexOf[i]) &lt; 0) { arrIndexOf2.push(arrIndexOf[i]); }}console.log(arrIndexOf2); // ['a', 'c', 'b', 'd'] 二、HTML 和 CSSHTML 1. 从规范的角度理解 HTML，从分类和语义的角度使用标签 语义化标签：&lt;header&gt; &lt;footer&gt; &lt;nav&gt; &lt;section&gt; &lt;article&gt; &lt;aside&gt; 等 让页面呈现清晰的结构 屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页 搜索引擎的爬虫依赖标签确定上下文和权重问题 便于团队开发和维护 标签分类： 文档标签(10 个)：&lt;html&gt;、&lt;head&gt;、&lt;body&gt;、&lt;title&gt;、&lt;meta&gt;、&lt;base&gt; 、&lt;style&gt;、&lt;link&gt;、&lt;script&gt;、&lt;noscript&gt; 表格标签(10 个)：&lt;table&gt;、&lt;thead&gt;、&lt;tbody&gt;、&lt;tfoot&gt;、&lt;tr&gt;、&lt;td&gt;、&lt;th&gt; 、&lt;col&gt;、&lt;colgroup&gt;、&lt;caption&gt; 表单标签(10 个)：&lt;from&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;button&gt;、&lt;select&gt; 、&lt;optgroup&gt;、&lt;option&gt;、&lt;label&gt;、&lt;fieldset&gt;、&lt;legend&gt; 列表标签(6 个)：&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;、&lt;dl&gt;、&lt;dt&gt;、&lt;dd&gt; 多媒体标签(5 个)：&lt;img&gt;、&lt;map&gt;、&lt;area&gt;、&lt;object&gt;、&lt;param&gt; 文章标签：&lt;h1&gt; - &lt;h6&gt; 、&lt;p&gt;、&lt;br&gt;、&lt;span&gt;、&lt;bdo&gt;、&lt;pre&gt;、&lt;acronym&gt;、&lt;abbr&gt;、&lt;blockquote&gt;、&lt;q&gt;、&lt;ins&gt;、&lt;del&gt;、&lt;address&gt; 字体样式标签：&lt;tt&gt;、&lt;i&gt;、&lt;b&gt;、&lt;big&gt;、&lt;small&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;dfn&gt;、&lt;code&gt;、&lt;samp&gt;、&lt;kbd&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;sup&gt;、&lt;sub&gt; 在不同的场景使用不同的标签，更能显示清晰的结构。 2. 元信息类标签 (head、title、meta) 的使用目的和配置方法 &lt;head&gt; 标签用于定义文档的头部，它是所有头部元素的容器。&lt;head&gt; 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。可以包含的标签有： &lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, 以及 &lt;title&gt;。 &lt;title&gt; 定义文档的标题，它是 head 部分中唯一必需的元素。 &lt;meta&gt;元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。使用方法参考【meta 标签详解】 3. HTML5 离线缓存原理 待补充 4. 可以使用 Canvas API、SVG 等绘制高性能的动画 【Canvas 进阶（一）二维码的生成与扫码识别】 【Canvas 进阶（二）写一个生成带logo的二维码npm插件】 【Canvas 进阶（三）ts + canvas 重写”辨色“小游戏】 【流动的SVG线条】 CSS 1. CSS 盒模型，在不同浏览器的差异 标准 w3c 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分 ie 盒子模型的范围也包括 margin、border、padding、content，和标准 w3c 盒子模型不同的是：ie 盒子模型的 content 部分包含了 border 和 pading。 2. CSS 所有选择器及其优先级、使用场景，哪些可以继承，如何运用at规则 不同级别优先级： !important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性 相同级别优先级： 内联(行内)样式 &gt; 内部样式表 &gt; 外部样式表 &gt; 导入样式(@import)。 可继承属性： 123字体系列属性, font-family, font-weight, font-size, font-style...文本系列属性, text-indent, text-align, line-heigh, word-spacing, letter-spacing, text-transform, color元素可见性：visibility, 光标属性：cursor AT rule: 一、什么是 at-rules eg：@charset &quot;utf-8&quot;; at-rule 是 CSS 样式声明，以 @ 开头，紧跟着是标识符（charset），最后以分号（;）结尾。 二、几个 at-rules 1、@charset —定义被样式表使用的字符集 2、@import ——告诉 CSS 引擎包含外部的 CSS 样式表 3、@namespace——告诉 CSS 引擎所有的内容都必须考虑使用 XML 命名空间前缀 4、嵌套at-rules （1）@media——条件组规则。如果设备符合标准定义的条件查询则使用该媒体 （2）@font-face——描述了一个将从外部下载的字体 （3）@keyframes——描述了中间步骤在 CSS 动画的序列 （4）@page——描述了文件的布局变化，当要打印文档时。 （5）@supports——条件组规则，如果浏览器满足给出的规则，则把它应用到内容中 （6）@document——条件组规则，如果被用到文档的 CSS 样式表满足了给定的标准，那么将被应用到所有的内容中。 3. CSS 伪类和伪元素有哪些，它们的区别和实际应用 伪类：用于向某些选择器添加特殊的效果. :active, :focus, :link, :visited, :hover, :first-child 伪元素：用于将特殊的效果添加到某些选择器. :before, :after, :first-line, :first-letter 伪类和伪元素的根本区别在于：它们是否创造了新的元素(抽象)。从我们模仿其意义的角度来看，如果需要添加新元素加以标识的，就是伪元素，反之，如果只需要在既有元素上添加类别的，就是伪类。 4. HTML 文档流的排版规则，CSS 几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理 HTML 文档流的排版规则: 把元素按从上而下，从左到右的顺序默认排列。不在一行的元素从上而下，在一行的从左到右排列。 CSS 几种定位的规则: static 定位(普通流定位) float 定位(浮动定位), 有两个取值：left (左浮动)和 right (右浮动)。 浮动元素会在没有浮动元素的上方，效果上看是遮挡住了没有浮动的元素，有 float 样式规则的元素是脱离文档流的，它的父元素的高度并不能有它撑开。 relative 定位(相对定位), 相对本元素的左上角进行定位，top,left,bottom,right 都可以有值。虽然经过定位后，位置可能会移动，但是本元素并没有脱离文档流，还占有原来的页面空间。 absolute 定位(绝对定位), 相对于祖代中有 relative (相对定位)并且离本元素层级关系上是最近的元素的左上角进行定位，如果在祖代元素中没有有 relative定位的，就默认相对于body进行定位。绝对定位是脱离文档流的 fixed 定位(固定定位)，这种定位方式是相对于整个文档的，只需设置它相对于各个方向的偏移值，就可以将该元素固定在页面固定的位置，通常用来显示一些提示信息，脱离文档流； 雪碧图实现原理： CSS Sprite，是一种 CSS 图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用 css 的背景定位来显示需要显示的图片部分。 5. 水平垂直居中的方案、可以实现6种以上并对比它们的优缺点 参考文章： 【CSS 实现水平垂直居中的 1010 种方式】 6. BFC 实现原理，可以解决的问题，如何创建BFC BFC(Block formatting context) 直译为”块级格式化上下文”。它是一个独立的渲染区域，只有块级元素参与， 它规定了内部的块级元素如何布局，并且与这个区域外部毫不相干。 BCF 可以解决的问题：浮动定位，消除外边距折叠，清除浮动，自适应多栏布局 BFC 的创建：根元素或包含根元素的元素，浮动元素(float 不为none)，绝对定位元素( position 为 absolute 或者 fixed)，display 为 inline-block,table-cell,table-caption，overflow 值不为 visible，弹性元素( flex 布局)，网格元素( grid 布局) 7. CSS模块化方案、如何配置按需加载、如何防止 CSS 阻塞渲染 CSS 模块化方案: 文件细化，命名约定，CSS Modules ， css in js 如何防止 CSS 阻塞渲染: CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。 有一些 CSS 样式只在特定条件下（例如显示网页或将网页投影到大型显示器上时）使用，我们可以通过 CSS“媒体类型”和“媒体查询”来解决这类用例： 12345&lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot; /&gt;&lt;link href=&quot;other.css&quot; rel=&quot;stylesheet&quot; media=&quot;(min-width: 40em)&quot; /&gt;首屏相关的关键 `CSS` 使用阻塞渲染的方式加载，所有的非关键 `CSS`在首屏渲染完成后加载。 8. 手写图片瀑布流效果 参考文章：【瀑布流布局的实现】 9. 使用CSS绘制几何图形（圆形、三角形、扇形、菱形等） 123456789101112131415161718192021222324252627282930313233343536373839404142// 圆形.circle { width: 100px; height: 100px; border-radius: 50%; background: blue;}// 三角形.triangle { width: 0; height: 0; border: 50px solid blue; /* 通过改变边框颜色，可以改变三角形的方向 */ border-color: blue transparent transparent transparent;}// 扇形，扇形是由一个圆形和一个矩形进行组合得到的，用矩形遮住圆形的一部分就形成了扇形。.sector { width: 142px; height: 142px; background: #fff; border-radius: 50%; background-image: linear-gradient(to right, transparent 50%, #655 0);}.sector::before { content: ''; display: block; margin-left: 50%; height: 100%; width: 100%; background-color: inherit; transform-origin: left; /*调整角度，改变扇形大小*/ transform: rotate(230deg);}// 菱形.rhombus { width: 200px; height: 200px; transform: rotateZ(45deg) skew(30deg, 30deg); background: blue;} 10. 使用纯 CSS 实现曲线运动（贝塞尔曲线） CSS3 新增了 transition-timing-function 属性，它的取值就可以设置为一个三次贝塞尔曲线方程。 参考文章： 【贝塞尔曲线的 css 实现——淘宝加入购物车基础动画】 11. 实现常用布局（三栏、圣杯、双飞翼、吸顶），说出多种方式并理解其优缺点 圣杯布局, 两边顶宽，中间自适应的三栏布局。 期待评论补充 三、计算机基础关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要 编译原理 1. 理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序 代码就是程序员用开发工具所支持的语言写出来的源文件，是一组由字符、符号或信号码元以离散形式表示信息的明确的规则体系。 计算机源代码最终目的是将人类可读文本翻译成为计算机可执行的二进制指令，这种过程叫编译，它由通过编译器完成。 2. 正则表达式的匹配原理和性能优化 待补充 3. 如何将JavaScript代码解析成抽象语法树(AST) 待补充 4. base64 的编码原理 待补充 5. 几种进制的相互转换计算方法，在 JavaScript 中如何表示和转换 parseInt(str, radix) 将一个 radix 进制的 str 转化为十进制，parseInt('23',8) // 19，将八进制的‘23’转化为10进制的‘19’ number.toString(radix) 将一个数字转化为 radix 进制的数字字符串 123(0x11).toString(8); // 21(0x11).toString(10); // 17(0x11).toString(2); // 10001 网络协议 1. 理解什么是协议，了解 TCP/IP 网络协议族的构成，每层协议在应用程序中发挥的作用 协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。它的三要素是：语法、语义、时序。 TCP/IP 网络协议族的构成: TCP/IP 协议是 Internet 最基本的协议。由传输层的 TCP 协议和网络层的 IP 协议组成。 TCP 负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而 IP 是给因特网的每一台联网设备规定一个地址。 应用层 应用层决定了向用户提供应该服务时通信的活动。 TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中的两类。HTTP 协议也处于该层。 传输层 传输层对上层应用层，提供处于网络连接中两台计算机之间的数据传输。 在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。 网络层（又名网络互连层） 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的所用就是在众多的选项内选择一条传输路线。 链路层（又名数据链路层，网络接口层） 用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。 2. 三次握手和四次挥手详细原理，为什么要使用这种机制 三次握手和四次挥手详细原理: 三次握手：避免连接请求的数据包丢失，数据传输过程因为网络并发量很大在某结点被阻塞 四次挥手： TCP 连接是全双工通道，需要双向关闭。 参考文章： 【TCP/IP 协议族】 3. 有哪些协议是可靠，TCP有哪些手段保证可靠交付 TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和 SMTP 相对，用于接收邮件）、HTTP 协议等。 TCP 提供可靠的、面向连接的数据传输服务。使用 TCP 通信之前，需要进行“三次握手”建立连接，通信结束后还要使用“四次挥手”断开连接。 4. DNS的作用、DNS解析的详细过程，DNS优化原理 DNS 的作用：DNS是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。 DNS 解析过程： 1、在浏览器中输入 www.qq.com 域名，操作系统会先检查自己本地的 hosts 文件是否有这个网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。 2、如果 hosts 里没有这个域名的映射，则查找本地 DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 3、如果 hosts 与 本地DNS解析器缓存 都没有相应的网址映射关系，首先会找 TCP/ip 参数中设置的 首选DNS服务器，在此我们叫它 本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 4、如果要查询的域名，不由 本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。 5、如果 本地DNS服务器 本地区域文件与缓存解析都失效，则根据 本地DNS服务器 的设置（是否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至 13 台根 DNS，根 DNS 服务器收到请求后会判断这个域名 (.com) 是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器 收到 IP 信息后，将会联系负责 .com 域的这台服务器。这台负责 .com 域的服务器收到请求后，如果自己无法解析，它就会找一个管理 .com 域的下一级 DNS 服务器地址(http://qq.com)给 本地DNS服务器。当 本地DNS服务器 收到这个地址后，就会找 http://qq.com 域服务器，重复上面的动作，进行查询，直至找到 www.qq .com 主机。 6、如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环。不管是 本地DNS服务器 用是是转发，还是根提示，最后都是把结果返回给 本地DNS服务器，由此 DNS 服务器再返回给客户机。 DNS 优化：减少 DNS 的请求次数；进行 DNS 预获取 。 减少 DNS 的请求次数————在项目中减少不同域名的 http 请求，尽量少的域名减少 DNS 的请求数 DNS 预获取————减少用户的等待时间，提升用户体验 。 默认情况下浏览器会对页面中和当前域名（正在浏览网页的域名）不在同一个域的域名进行预获取，并且缓存结果，这就是隐式的 DNS Prefetch。如果想对页面中没有出现的域进行预获取，那么就要使用显示的 DNS Prefetch 了。 1234&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//www.itechzero.com&quot; /&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//api.share.baidu.com&quot; /&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//bdimg.share.baidu.com&quot; /&gt; 5. CDN的作用和原理 CDN的作用 CDN 的全称是 Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。 CDN 的原理1、多域名加载资源 一般情况下，浏览器都会对单个域名下的并发请求数（文件加载）进行限制，通常最多有 4 个，那么第 5 个加载项将会被阻塞，直到前面的某一个文件加载完毕。因为 CDN 文件是存放在不同区域（不同 IP）的，所以对浏览器来说是可以同时加载页面所需的所有文件（远不止 4 个），从而提高页面加载速度。 2、文件可能已经被加载过并保存有缓存 一些通用的 js 库或者是 css 样式库，如 jQuery ，在网络中的使用是非常普遍的。当一个用户在浏览你的某一个网页的时候，很有可能他已经通过你网站使用的 CDN 访问过了其他的某一个网站，恰巧这个网站同样也使用了 jQuery，那么此时用户浏览器已经缓存有该 jQuery 文件（同 IP 的同名文件如果有缓存，浏览器会直接使用缓存文件，不会再进行加载），所以就不会再加载一次了，从而间接的提高了网站的访问速度。 3、分布式的数据中心 假如你的站点布置在北京，当一个香港或者更远的用户访问你的站点的时候，他的数据请求势必会很慢很慢。而 CDN 则会让用户从离他最近的节点去加载所需的文件，所以加载速度提升就是理所当然的了。 6. HTTP 请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么 参考文章：【HTTP 请求详解】 HTTP 协议的六种请求方法： GET: 发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中 POST: 和 get 一样很常见，向服务器提交资源让服务器处理，比如提交表单、上传文件等，可能导致建立新的资源或者对原有资源的修改。提交的资源放在请求体中。不支持快取。非幂等 HEAD: 本质和 get 一样，但是响应中没有呈现数据，而是 http 的头信息，主要用来检查资源或超链接的有效性或是否可以可达、检查网页是否被串改或更新，获取头信息等，特别适用在有限的速度和带宽下。 PUT: 和 post 类似，html 表单不支持，发送资源与服务器，并存储在服务器指定位置，要求客户端事先知道该位置；比如 post 是在一个集合上（/province），而 put 是具体某一个资源上（/province/123）。所以 put 是安全的，无论请求多少次，都是在 123 上更改，而 post 可能请求几次创建了几次资源。幂等 DELETE: 请求服务器删除某资源。和 put 都具有破坏性，可能被防火墙拦截 CONNECT: HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。就是把服务器作为跳板，去访问其他网页然后把数据返回回来，连接成功后，就可以正常的 get、post 了。 7: OPTIONS: 获取 http 服务器支持的 http 请求方法，允许客户端查看服务器的性能，比如 ajax 跨域时的预检等。8: TRACE: 回显服务器收到的请求，主要用于测试或诊断。一般禁用，防止被恶意攻击或盗取信息。 7. HTTP 所有状态码的具体含义，看到异常状态码能快速定位问题 1XX：信息状态码 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 2XX：成功状态码 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 3XX：重定向 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 4XX：客户端错误 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 5XX: 服务器错误 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 8. HTTP1.1、HTTP2.0带来的改变 缓存处理，在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用，HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名 （hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。 长连接，HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。 HTTP2.0 和 HTTP1.X 相比的新特性 新的二进制格式（Binary Format），HTTP1.x 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。 多路复用（MultiPlexing），即连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。 header 压缩，如上文中所言，对前面提到过 HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。 服务端推送（server push），HTTP2.0具有 server push 功能。 9. HTTPS 的加密原理，如何开启 HTTPS，如何劫持 HTTPS 请求 参考文章：【一个故事讲完 https】 设计模式 1. 熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等 参考文章：【设计模式】 2. 发布订阅模式和观察者模式的异同以及实际应用 观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心。 12345678910111213141516171819202122232425// 观察者模式class Subject { constructor() { this.subs = []; } addSub(sub) { this.subs.push(sub); } notify() { this.subs.forEach((sub) =&gt; { sub.update(); }); }}class Observer { update() { console.log('update'); }}let subject = new Subject();let ob = new Observer();//目标添加观察者了subject.addSub(ob);//目标发布消息调用观察者的更新方法了subject.notify(); //update 123456789101112131415161718192021222324252627// 发布订阅者模式class PubSub { constructor() { this.subscribers = {}; } subscribe(type, fn) { if (!Object.prototype.hasOwnProperty.call(this.subscribers, type)) { this.subscribers[type] = []; } this.subscribers[type].push(fn); } unsubscribe(type, fn) { let listeners = this.subscribers[type]; if (!listeners || !listeners.length) return; this.subscribers[type] = listeners.filter((v) =&gt; v !== fn); } publish(type, ...args) { let listeners = this.subscribers[type]; if (!listeners || !listeners.length) return; listeners.forEach((fn) =&gt; fn(...args)); }}let ob = new PubSub();ob.subscribe('add', (val) =&gt; console.log(val));ob.publish('add', 1); 四、数据结构和算法据我了解的大部分前端对这部分知识有些欠缺，甚至抵触，但是，如果突破更高的天花板，这部分知识是必不可少的，而且我亲身经历——非常有用！ JavaScript 编码能力 1. 多种方式实现数组去重、扁平化、对比优缺点 参考文章：【JS 数组去重方法整理】 【5 种方式实现数组扁平化】 2. 多种方式实现深拷贝、对比优缺点 参考文章：【递归实现深拷贝】 3. 手写函数柯里化工具函数、并理解其应用场景和优势 待补充 4.手写防抖和节流工具函数、并理解其内部原理和应用场景 参考文章：【函数的防抖与节流】 5.实现一个 sleep 函数 1234function sleep(time) { return new Promise((resolve,reject) =&gt; setTimeout(resolve, time))}sleep(3000).then(() =&gt; {console.log('沉睡3000ms')}) 手动实现前端轮子 1. 手动实现call、apply、bind call 判断当前 this 是否为函数，防止 Function.prototype.myCall() 直接调用 context 为可选参数，如果不传的话默认上下文为 window 为 context 创建一个 Symbol（保证不会重名）属性，将当前函数赋值给这个属性 处理参数，传入第一个参数后的其余参数 调用函数后即删除该 Symbol 属性 1234567891011Function.prototype.myCall = function (context = window, ...args) { if (this === Function.prototype) { return undefined; // 用于防止 Function.prototype.myCall() 直接调用 } context = context || window; const fn = Symbol(); context[fn] = this; const result = context[fn](...args); delete context[fn]; return result;}; applyapply 实现类似 call，参数为数组 123456789101112131415Function.prototype.myApply = function (context = window, args) { if (this === Function.prototype) { return undefined; // 用于防止 Function.prototype.myCall() 直接调用 } const fn = Symbol(); context[fn] = this; let result; if (Array.isArray(args)) { result = context[fn](...args); } else { result = context[fn](); } delete context[fn]; return result;}; bind因为 bind() 返回一个方法需手动执行，因此利用闭包实现。 12345678910111213Function.prototype.myBind = function (context, ...args1) { if (this === Function.prototype) { throw new TypeError('Error'); } const _this = this; return function F(...args2) { // 判断是否用于构造函数 if (this instanceof F) { return new _this(...args1, ...args2); } return _this.apply(context, args1.concat(args2)); };}; 2.手动实现符合 Promise/A+ 规范的 Promise 参考文章：【手动实现 promise】 3. 手写一个 EventEmitter 实现事件发布、订阅 function EventEmitter() { this._events = Object.create(null); } // 向事件队列添加事件 // prepend为true表示向事件队列头部添加事件 EventEmitter.prototype.addListener = function (type, listener, prepend) { if (!this._events) { this._events = Object.create(null); } if (this._events[type]) { if (prepend) { this._events[type].unshift(listener); } else { this._events[type].push(listener); } } else { this._events[type] = [listener]; } }; // 移除某个事件 EventEmitter.prototype.removeListener = function (type, listener) { if (Array.isArray(this._events[type])) { if (!listener) { delete this._events[type] } else { this._events[type] = this._events[type].filter(e =&gt; e !== listener &amp;&amp; e.origin !== listener) } } }; // 向事件队列添加事件，只执行一次 EventEmitter.prototype.once = function (type, listener) { const only = (...args) =&gt; { listener.apply(this, args); this.removeListener(type, listener); } only.origin = listener; this.addListener(type, only); }; // 执行某类事件 EventEmitter.prototype.emit = function (type, ...args) { if (Array.isArray(this._events[type])) { this._events[type].forEach(fn =&gt; { fn.apply(this, args); }); } }; // 测试一下 var emitter = new EventEmitter(); var onceListener = function (args) { console.log('我只能被执行一次', args, this); } var listener = function (args) { console.log('我是一个listener', args, this); } emitter.once('click', onceListener); emitter.addListener('click', listener); emitter.emit('click', '参数'); emitter.emit('click'); emitter.removeListener('click', listener); emitter.emit('click'); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;/details&gt;&lt;details&gt; &lt;summary&gt;4.可以说出两种实现双向绑定的方案、可以手动实现&lt;/summary&gt; 参考文章：[【Vue 双向数据绑定原理】](https://zxpsuper.github.io/Demo/advanced_front_end/vue/vue.html#_1-documentfragment)&lt;/details&gt;&lt;details&gt; &lt;summary&gt;5.手写JSON.stringify、JSON.parse&lt;/summary&gt; ```js let Myjson = { parse: function(jsonStr) { return eval('(' + jsonStr + ')'); }, stringify: function(jsonObj) { var result = '', curVal; if (jsonObj === null) { return String(jsonObj); } switch (typeof jsonObj) { case 'number': case 'boolean': return String(jsonObj); case 'string': return '&quot;' + jsonObj + '&quot;'; case 'undefined': case 'function': return undefined; } switch (Object.prototype.toString.call(jsonObj)) { case '[object Array]': result += '['; for (var i = 0, len = jsonObj.length; i &lt; len; i++) { curVal = JSON.stringify(jsonObj[i]); result += (curVal === undefined ? null : curVal) + &quot;,&quot;; } if (result !== '[') { result = result.slice(0, -1); } result += ']'; return result; case '[object Date]': return '&quot;' + (jsonObj.toJSON ? jsonObj.toJSON() : jsonObj.toString()) + '&quot;'; case '[object RegExp]': return &quot;{}&quot;; case '[object Object]': result += '{'; for (i in jsonObj) { if (jsonObj.hasOwnProperty(i)) { curVal = JSON.stringify(jsonObj[i]); if (curVal !== undefined) { result += '&quot;' + i + '&quot;:' + curVal + ','; } } } if (result !== '{') { result = result.slice(0, -1); } result += '}'; return result; case '[object String]': return '&quot;' + jsonObj.toString() + '&quot;'; case '[object Number]': case '[object Boolean]': return jsonObj.toString(); } } }; &lt;/details&gt; &lt;details&gt; &lt;summary&gt;6. 手写懒加载效果&lt;/summary&gt; 参考文章：[【图片懒加载】](http://www.conardli.top/docs/JavaScript/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD.html) &lt;/details&gt; ## 浏览器原理 &lt;details&gt; &lt;summary&gt;1. 可详细描述浏览器从输入URL到页面展现的详细过程&lt;/summary&gt; 参考文章：[【输入URL至页面渲染】](https://zxpsuper.github.io/Demo/advanced_front_end/browser/urlrender.html) &lt;/details&gt; &lt;details&gt; &lt;summary&gt;2. 浏览器的垃圾回收机制，如何避免内存泄漏&lt;/summary&gt; 参考文章：[【浏览器内存回收机制】](https://zxpsuper.github.io/Demo/advanced_front_end/browser/garbage.html) 参考文章：[【内存泄漏与避免】](https://zxpsuper.github.io/Demo/advanced_front_end/browser/garbagerefuse.html) &lt;/details&gt; # 资源推荐 ## 语言基础 - 现代 `JavaScript` 教程：[zh.javascript.info/](http://zh.javascript.info) - 阮一峰的 `ECMAScript 6` 教程：[es6.ruanyifeng.com/](http://es6.ruanyifeng.com) - `HTML meta` 标签总结与属性使用介绍：[https://segmentfault.com/a/1190000004279791](https://segmentfault.com/a/1190000004279791) - `CSS` 编码指导：[https://github.com/chadluo/CSS-Guidelines/blob/master/README.md](https://github.com/chadluo/CSS-Guidelines/blob/master/README.md) ## 计算机基础 - 大前端开发者需要了解的基础编译原理和语言知识：[http://fullstack.blog](http://fullstack.blog/2017/06/24/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%92%8C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86/) - 正则表达式 30 分钟入门教程：[https://deerchao.net/tutorials/regex/regex.htm](https://deerchao.net/tutorials/regex/regex.htm) ## 数据结构和算法 - 用动画的形式呈现解 `LeetCode` 题目的思路：[https://github.com/MisterBooo/LeetCodeAnimation](https://github.com/MisterBooo/LeetCodeAnimation) - `JavaScript` 数据结构和算法：[https://github.com/ConardLi/awesome-coding-js](https://github.com/ConardLi/awesome-coding-js) - `30-seconds-of-code`（里面有很多 `js` 代码非常巧妙，我正在将它翻译成中文）：[https://github.com/ConardLi/30-seconds-of-code-Zh-CN](https://github.com/ConardLi/30-seconds-of-code-Zh-CN) ## 运行环境 - 《重学前端》中的浏览器原理章节：[https://time.geekbang.org/column/article/80240](https://time.geekbang.org/column/article/80240) - 图解浏览器的基本工作原理：[https://zhuanlan.zhihu.com/p/47407398](https://zhuanlan.zhihu.com/p/47407398) - 七天学会 `NodeJS`：[github.com/nqdeng/7-da…](https://github.com/nqdeng/7-days-nodejs) - `Node.js` 模块加载与运行原理：[efe.baidu.com/blog/nodejs…](https://efe.baidu.com/blog/nodejs-module-analyze/) ## 框架和类库 - `TypeScript Handbook`：[zhongsp.gitbooks.io/typescript-…](https://zhongsp.gitbooks.io/typescript-handbook/content/) - `React.js` 小书：[huziketang.mangojuice.top/books/react…](http://huziketang.mangojuice.top/books/react/) - `React` 深入系列：[juejin.im/post/5cad39…](https://juejin.im/post/5cad39b3f265da03502b1c0a) - `Webpack React` 小书：[fakefish.github.io/react-webpa…](https://fakefish.github.io/react-webpack-cookbook/index.html) - `Vue.js` 技术揭秘：[github.com/ustbhuangyi…](https://github.com/ustbhuangyi/vue-analysis) - `Vuex` 在 `Vue` 中管理状态：[sabe.io/tutorials/g…](https://sabe.io/tutorials/getting-started-with-vuex) - 你需要 `Mobx` 还是 `Redux`？：[juejin.im/post/5a7fd7…](https://juejin.im/post/5a7fd72c5188257a766324ae) - `Underscore` 源码分析：[yoyoyohamapi.gitbooks.io/undersercor…](https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/) - 微信小程序开发资源汇总：[github.com/justjavac/a…](https://github.com/justjavac/awesome-wechat-weapp) - 腾讯移动 `Web` 前端知识库：[github.com/AlloyTeam/M…](https://github.com/AlloyTeam/Mars) ## 前端工程 - 一口（很长的）气了解`babel`：[zhuanlan.zhihu.com/p/43249121](https://zhuanlan.zhihu.com/p/43249121) - `Webpack` 傻瓜式指南：[zhuanlan.zhihu.com/p/20367175](https://zhuanlan.zhihu.com/p/20367175) - `Webpack` 原理：[segmentfault.com/a/119000001…](https://segmentfault.com/a/1190000015088834?utm_source=tag-newest) - 廖雪峰的 `git` 教程：[www.liaoxuefeng.com/wiki/001373…](https://www.liaoxuefeng.com/wiki/896043488029600) - 图解 `Git`：[marklodato.github.io/visual-git-…](https://marklodato.github.io/visual-git-guide/index-zh-cn.html) - 前端开发者必备的 `Nginx` 知识：[juejin.im/post/5c85a6…](https://juejin.im/post/5c85a64d6fb9a04a0e2e038c) - 使用 `Jenkins` 进行持续集成：[www.liaoxuefeng.com/article/001…](https://www.liaoxuefeng.com/article/1083282007018592) ## 项目和业务 - 常见六大 `Web` 安全攻防解析：[github.com/ljianshu/Bl…](https://github.com/ljianshu/Blog/issues/56) - 新人如何快速融入技术实力强的前端团队：[juejin.im/post/5cb860…](https://juejin.im/post/5cb860a86fb9a06890705f14) ## 学习提升 - 印记中文（各种中文开发文档）：[www.docschina.org/](https://www.docschina.org/) - 前端学习方法：[github.com/helloqingfe…](https://github.com/helloqingfeng/Awsome-Front-End-learning-resource/tree/master/01-FE-learning-master) - 如何在工作内外获得持续的技术成长：[juejin.im/post/5cbd74…](https://juejin.im/post/5cbd7477f265da039d32834e) - 优秀的前端博客汇总：[github.com/foru17/fron…](https://github.com/foru17/front-end-collect) ## 博客推荐 - 冴羽的博客：[github.com/mqyqingfeng…](https://github.com/mqyqingfeng/Blog) - 张鑫旭的博客：[www.zhangxinxu.com/wordpress/](https://www.zhangxinxu.com/wordpress/) - 大深海的博客：[https://github.com/chenshenhai/blog](https://github.com/chenshenhai/blog) - 木易杨的博客： [https://github.com/yygmind/blog](https://github.com/yygmind/blog) - MuYunyun 的博客： [https://github.com/MuYunyun/blog](https://github.com/MuYunyun/blog) # 技术之外 - 互联网术语大全：[www.jianshu.com/p/9a7ca206c…](https://www.jianshu.com/p/9a7ca206c1ab) - 互联网沟通、问答、学习的艺术：[zhuanlan.zhihu.com/p/41431775](https://zhuanlan.zhihu.com/p/41431775) - 经常加班至深夜，怎样才能保持身体健康：[www.zhihu.com/question/21…](https://www.zhihu.com/question/21790919)","link":"/2021/05/13/js/selfTest1/"},{"title":"社会学主管精简","text":"社会学概论 第一章 社会学的产生与发展第一节 社会学的创立与早期代表人物 社会学创立的历史条件：(1)社会变革的需要(2)自然科学发展的推动(3)社会思想和社会经验研究的产物 创立时期代表人物：(1)奥古斯特.孔德《实证哲学教程》。第一个提出“社会学”概念并创立社会学的人，被称为“社会学之父”。学说：① 科学的序列。② 社会学的研究对象。分为社会静力学和社会动力学两个部分。三阶段法则（人类理性发展：神学、哲学、实证；人类社会：军事、过渡、工业）秩序和进步是孔德实证主义社会学的核心概念。③ 研究方法。必须用研究自然界的科学方法来研究人类社会。观察法、实验法、比较法，历史法。(2)赫伯特·斯宾塞：《社会静力学》《社会学研究》《社会学原理》《伦理学原理》。① 社会有机体论；② 社会进化论(3)马克思主义社会学《共产党宣言》、《资本论》。布哈林《历史唯物主义——马克思主义社会学通俗读物》，经典马克思主义社会学的第一本教科书 形成时期的代表人物：(1)涂尔干：《社会劳动分工论》《社会学方法论》《自杀论》。社会学功能分析推理方法是由涂尔干创建的。① 社会学的研究对象 ② 个人与社会 ③ 功能分析 (2)韦伯：《新教伦理与资本主义精神》《经济与社会》合理性是韦伯社会学理论的核心概念。① 理解社会学 ② 社会行动类型 ③ 理想类型 ④ 科层制（官僚制） 第二节 社会学的发展 社会学中心在 19 世纪末 20 世纪初由欧洲转移的美国，首先在美国发展为制度化学科。(1) 芝加哥学派代表人物：斯莫尔、托马斯、帕克、伯吉斯。后期的主帅布鲁斯主要学术成就：第一，现代城市社区研究。第二，开创人文区位学研究的先河。第三，创建符号互动论。(2) 现代结构功能学派 二战后欧洲社会学的发展特点:(1)社会学的研究重心转向现实社会(2)社会学研究领域的多样化(3)社会学的理论研究已趋向多元化(4)欧洲社会学的制度化建设也取得了很大进展。 中国社会学发展的历史分期：传入时期（1891-1911）：谭嗣同／严复／章太炎成长时期（1912-1927）：余天休／陈达建设时期（1928-1952）：许仕廉/张鸿钧/晏阳初/李景汉/费孝通 毛泽东恢复重建（1979- ）：费孝通/田汝康/雷洁琼/王康 第三节 社会学本土化 本土化：使移植进来的某一事物扎根于本乡本土，适应本土的特性，并萌芽、成长、壮大。社会学本土化是一种使外来社会学与本土社会的实际相结合，形成具有本土特色的社会学理论与研究方法的学术过程。 社会学在中国的本土化的主要倡导人物：许仕廉／孙本文／吴文藻。晏阳初等人的乡村建设和社区发展理论、潘光旦的“位育”理论、费孝通的“差序格局”理论等已经成为具有影响的研究中国社会的重要理论观点。 实现社会学中国化的基本做法：(1)社会学的基本理论应当体现出马克思主义的立场、观点和方法；(2)把研究经济社会协调发展和人的社会化作为社会学的基本任务；(3)立足中国社会的现实，坚持理论联系实际，宏观和微观相结合，理论经研究和经验研究相结合，使社会学的研究与教学能切实为我国的社会主义建设事业服务；(4)采取积极的态度，在借鉴国外社会学的中国过去社会学的优秀成果的基础上，进行创新，逐步建立中国社会学的理论知识体系，形成中国社会学学派；(5)造就一支愿意并有能力为奋斗的社会学专业队伍。 第二章 社会学的研究对象与方法第一节 什么是社会学 社会学：是研究个人与社会的关系的一门综合性社会科学。 社会学的特征：整体性、综合性、实证性和应用性。 研究对象/基本问题：个人与社会的关系。 第二节 社会学的功能 研究功能：① 描述性功能：指那些为了解和掌握发生了什么事、什么情况而进行的探索性研究。② 解释性功能：指对影响社会事实发生、变化的主客观因素，从其因果联系上加以说明的过程。③ 预测性功能：和描述、解释功能相联系的高一层次的目标是预测功能。是要提示将来的社会事件和状态是怎样的。④ 规范性功能：社会研究在回答‘将会怎样’的基础上进一步回答‘应该怎样’的问题。 教育功能：① 帮助人们自觉的完成社会化。② 帮助人们合理选择。 社会管理功能：① 建立规范 ② 提供模式 ③ 反馈信息。 社会批评功能：对旧的思想、旧的观念和阻碍社会进步的事物、行为进行揭露，实事求是地进行理论分析，提出克服和解决问题的意见和建议。 第三节 社会学研究方法 社会学研究方法：主要是指以实证的方式对个人与社会的关系所产生、形成、变化的人们的关系、行为、态度以及各种社会现象进行科学探索的一种研究方法。 社会学实证研究的一般程序：筹划阶段、实施阶段和总结阶段。 社会学研究的资料收集方法：(1)问卷调查：是以问题表格形式向被调查者收集相关资料的一种定量研究方法。(2)实地研究：又称田野调查（英国马林诺夫斯基），它是一种深入研究对象内部，以参与观察和非结构访问的方式收集资料，交通过对这些资料的定性分析来解释社会现象的一种研究方法。可分为参与观察和个案研究。① 参与观察是研究者在某种程度上置身于观察对象的环境和社会活动中，使自己成为被研究群体中的一员的一种观察方法。② 个案研究：对某个社会单位的生活全过程或关于它的某方面的个别事例和整体相关联的一种研究方法。(3)社会实验方法：是根据一定的研究假设，在有控制的条件下，通过观察记录分析发现或证实社会现象变量之间因果关系的一种研究方法。(4)非介入性研究方法：是通过搜集现在了的，以文字数字符号画面等信息形式出现的文献资料，分析和探讨各种个人与社会现象的一种研究方法。 社会学研究的分析方法：(1)定性分析：是对收集到的资料进行归纳、分类、比较进而对某个或某类现象的性质和特征作出概括的一种分析方法。实地研究和非介入性研究属于定性方法。(2)定量分析：是对社会现象的数量特征、数量关系与数量变化进行分析的一种分析方法。问卷调查和实验方法属于定量方法。 定性分析与定量分析的关系：定性方法与定量方法是经常配合使用的。在进行定量分析之前，研究者须借助定性方法确定研究对象的性质，压电行定性分析过程中，研究者又须借助定量研究确定现象发生质变的数量界限和引起质变的原因。两者的不同点有：① 着重点不同 ② 依据不同 ③ 手段不同 ④ 学科基础不同 ⑤ 在研究中所处的层次不同 ⑥ 结论表述形式不同。定性方法是定量方法的基础，是它的指南，但只有同时运用定量方法，才能在精确定量的根据下准确定性。这是二者的辩证关系。定性分析与定量分析的有机结合是社会学研究的正确方向。 第四节 社会学的主要理论观点 经典马克思主义社会学理论：人们在社会生产中发生一定的、必然的、不依他们的意志为转移的生产关系。 结构功能理论：美国帕森斯社会行动的三个要素：目标、情境和规范 冲突理论：功能冲突论（刘易斯.科塞）辩证冲突论：（R.达伦多夫）雷克斯：社会分配、社会整合、社会变迁 交换理论（霍曼斯和布劳创立）：人类的相互交往和社会联合是一种相互的交换过程。 符号互动论（赫伯特.布鲁诺、欧文.戈夫曼）：社会是人们运用符号互动的结果。 其他理论：法兰克福学派的社会批判理论、舒茨的现象社会学理论、加芬克尔为代表的常人方法学、吉登斯的结构化理论、哈贝马斯的沟通理论、卢曼的社会系统理论、布迪厄的结构主义的建构主义。 第三章 社 会第一节 什么是社会 社会的含义：社会是人们交互作用中产生的各种社会关系的总和 基本特征是：① 社会以人为主体② 社会以人们的物质生产活动为基础③ 社会以人与人的交往为纽带④ 社会来源于自然又不同于自然。 社会唯名论：只有个人才是真正的存在，而社会只有一个名称，用来方便地称呼构成社会的许多的个人，是个人行动的产物或互动的形式。（主要代表人物：马克斯·韦伯） 社会唯实论：社会唯实论者也称社会实在论，和社会唯名论者相反，它把社会视为超越个人的客观存在。（主要代表人物：阿奎那、法国的涂尔干） 马克思主义社会观的基本观点：(1)社会是人们交互作用的产物(2)劳动是理解全部社会发展史的钥匙(3)需要是人们社会行为的动力(4)人类社会发展是一个自然历史过程(5)马克思主义社会观是科学的社会观。马克思主义社会观是在社会实践中不断丰富和发展的科学。其科学性：① 社会实践的不断发展，决定了马克思主义社会观是不断丰富和发展的科学② 发展性和创造性是马克思主义社会观的生命之所在。③ 马克思主义社会观与具体社会生活相结合，创造性地促进社会关系良性运行，从而推进了自身的丰富和发展。④ 马克思主义社会观在同形形色色的错误社会观的不断斗争中发展，具有较强的生命力。总之，马克思主义社会观是一种发展创造的、开放的、生气勃勃的思想体系，而不是一个封闭的、僵化的思想体系。 第二节 社会结构 个人与社会：相互联系的具有层次性的四个体系① 角色人格体系 ② 价值规范体系 ③ 权力制度体系 ④ 行为交换体系 社会关系：是人们在物质生产活动和社会交往过程中形成的相互关系的总称。初级社会关系与次级社会关系结合关系和对应关系血缘关系、地缘关系和业缘关系 如何建立与发展新型的社会关系？① 逐步建立健全新型的社会主义社会关系② 努力推进社会主义精神文明建设③ 加强党风和社会风气的建设④ 加速健全社会主义法制，用法律形式保护已经建立的新型关系和促进消除陈旧落后的社会关系。 社会结构：一般是指社会诸要素之间在相互作用过程中形成的相对稳定的关系。 马克思主义的社会结构观 以劳动或物质资料的生产与再生产作为社会的基础，社会的基本结构必然是生产力与生产关系，经济基础与上层建筑之间的关系体系。 第三节 社会的基本要素 社会赖以存在和发展的基本要素：自然资源、人口资源和文化资源。 人口资源：是指在特定地域内具有一定数量、质量和关系的人的总称。具有两重属性：自然属性和社会属性。 人力资源：指表现在劳动者身上的以劳动者数量和质量表示的资源，体现了包含在人体内的生产能力。其是在各种生产要素中最积极最活跃的主动要素，是社会经济发展的最重要的经济资源。 人口数量：是对人口资源的量的规定性，指一定时间和一定地区有生命的个体总和，通常人口数量指的是人口规模。 人口质量：也称人口素质，是对人口资源的质的规定性，包括人口的身体素质、科学文化素质和思想素质等。 自然资源：是与人类活动相关联的全部自然条件的总和，是社会赖以生存和发展的外部条件。 自然资源分类：① 环境资源 ② 生物资源 ③ 矿产资源。 自然资源特点：有限性、潜力无限性、系统性和空间分布不均匀。 可持续发展的概念：既满足当代人的需要又不对后代人满足他们需要的能力和机会构成危害的发展。 可持续发展的内在矛盾：人与自然、人与人之间的矛盾的不可调和性决定了可持续发展的内在矛盾。 可持续发展的意义：强调的是环境与经济的协调发展，追求的是人与自然的和谐，意义深远的。 第四章 文 化第一节 什么是文化 文化：广义的文化是指人类创造出来的一切物质产品和非物质产品的总和。狭义的文化指精神文化。 文化的特征：创造性、习得性、共享性、连续积累性、特殊性和共性 文化的构成要素：物质形态要素、精神形态要素、语言符号要素、社会关系和社会组织要素 文化的结构: ① 文化特质 ② 文化集丛 ③ 文化模式 文化的功能：① 社会整合功能② 社会导向功能③ 反功能（文化也会对社会整合与社会进步起着阻碍甚至破坏作用，此即文化的反功能。一般发生在两种情况下：一是文化滞后现象发生时，精神文化会对物质文化的发展起着阻碍作用。另一种情况是发生在反文化群体和某些亚文化群体中。每个社会除了主流文化之外，都存在着一引起次属文化，也称亚文化。） 第二节 文化的规范体系（习俗、道德、法律和宗教） 习俗概念：也称民俗，是指历代相沿积久而成的被人们普遍遵守的行为模式。特征：① 习俗根植于一定的物质生活条件。② 习俗还和社会环境有关③ 归根结底是由生产力的发展水平决定的④ 随着社会物质生活条件的变化而变化功能：是调整人们行为的重要社会规范，它的调整范围最普遍。 道德概念：是以善恶评价的方式来评价和调节人的行为的观念和规范，是人类自我完善的一种价值标准。现阶段我国的道德标准建设具有重要现实意义。基本道德规范：爱国守法、明理诚信、团结友爱、勤俭自强、敬业奉献 法律概念：是由国家制定或认可的、并以国家强制力保证其实行的社会规范。 本质：统治阶级意志，是最具有强制力的社会行为规范。 特征：① 公正性，是指在法律面前人人平等。② 强制性与社会习俗和道德不同，法律是依靠国家权力保证其施行的。 社会功能：① 惩罚功能 ② 威慑功能 ③ 教育功能 宗教概念：从本质上说是人们对超自然力量的幻想，是对神的敬畏与信仰。 正向功能：① 促进社会团结，维持社会秩序② 振奋民众精神，促进社会发展③ 寻求生活意义，为个人提供精神安慰。 宗教和邪教的区别：① 宗教劝人热爱生活，尊重世俗维护社会秩序；邪教宣扬世界是末日，贬低世俗，劝人毁灭，破坏社会秩序。② 宗教的神是超人间的，宗教教义有经典；邪教的神就在人间，它把生活在现世的教主当作神，把教主的话视为经典。③ 宗教宣传博爱、爱教徒、爱大众；邪教害人，以残忍手段残害信徒，残害他人。 第三节 文化交流 文化交流：是指从文化传播开始的两种文化之间互相沟通、采借、冲突与融合的过程。文化交流是文化的固有属性，是社会发展的必要条件。 文化交流包括：(1)文化传播概念：指某种文化元素随同社会交往而扩散，为其他采借或吸必的过程。过程：（美国人类学家林顿把文化传播分为三个阶段）A 接触与显示阶段 B 选择阶段 C 采纳融合阶段。媒体：最原始最基本的媒体是人。书籍、大众传媒、电子网络。(2)文化采借（又译文化杂交）概念：指一种文化接受或吸收另一种文化的某些文化元素或文化丛，融入本文化的过程。文化融合：对采借过来的文化元素，要放在本土文化中进行磨合，乃至改造，使之于本土文化协调起来，融为一体的过程。(3)文化冲突概念：指异质文化在传播接触中出现的互相排斥的倾向和状态根源：除了民族性之外，更有阶级性。 第五章 社会化第一节 什么是社会化 人具有自然属性和社会属性，每一个个体都是这两种属性的统一。 社会化：是社会对个人的文化教化和个人对社会主动选择与能动调适的统一的社会过程。其内涵从三方面理解：① 时间上，个人社会化涉及到人生发展的全过程；② 内容上，个人社会化关注到个人作为社会一员所应具有的全部文化遗产；③ 社会关系上，个人社会化注重个人与社会的交互作用以及个人社会化的结果。 社会化既是个人生存和发展的需要，也是社会新陈代谢、稳定发展的需要。 社会化的主要功能：文化传承、社会稳定发展、个体自我完善。 社会化的基本内容：(1)生活技能社会化：是人们学习并获得维持生存状态和改善生活质量的本领的过程。(2)价值观念社会化：是人们认知与认同社会主导价值观念的过程。(3)政治社会化：是个人逐渐学习和接受被现有政治制度采用和确定的政治信念、思想体系、社会制度和政治态度的过程。(4)行为社会化：是人们按照通行的社会行为规范模塑自身行为的过程。(5)角色社会化：是按照社会上规定的角色的要求来支配自己的行为，使个人行为符合于一定社会期望的品质特征。 社会化对人的角色能力的培养主要体现在以下几个方面：① 是分清自己角色类型的能力② 是健全角色扮演的心理状态③ 是全面理解角色规范化的程度④ 明确角色目标。 第二节 社会化的类型与过程 社会化的类型： (1) 基本社会化概念：就是“生物人”通过社会文化教化，获得人的社会性，获得社会生活资格的过程。任务：① 生理性成熟即通过人化的生理发育过程，形成完善健全的身心基础 ② 社会性成熟即通过社会文化的教化与自我内化，成为具有独特个性物为能力的社会成员。 (2) 继续社会化是指人在成年以后的社会化，或称二级社会化。 (3) 再社会化概念：也称重新社会化，它是使个人改变以前的知识结构、价值标准和行为模式，建立起新的、符和社会要求和新的形势需要的知识结构、价值标准和行为模式的过程。意义：使人们能够适应日常社会生活的要求，实现与其他社会成员的正常交往，按照社会要求安排生活，维持人与社会的正常关系与社会秩序。 (4) 正向社会化和反向社会化正向社会化：是指上代人对下代人的文化传递和教化过程。反向社会化：是年轻一代用新知识新观念影响前辈的过程，这种社会化又称为文化反哺。 E·埃里克森《童年和社会》把个人必理成长的历程划分为八个阶段：婴儿期 幼儿期 幼儿后期 学龄期 青年期 成年早期 成年期 成熟期 R·哈维格斯特把人一生的社会化过程分为六个阶段：幼儿期 儿童期 青年期 成年早期 中年期 老年期 第三节 社会化的条件 生物因素：概念：个人所带有的一种由上代为下代提供的、有利于人类从事社会活动的特殊遗传素质。 环境因素概念：指影响个人社会化过程的全部社会环境。主要内容：包括家庭、学校、伙伴群体、工作单位、社区和大众传媒 社会实践：概念：是实现知识内化与积累，达到社会化目标的根本途径。形式：生产活动，科学实验，社会斗争和人际交往等。主要表现：观察学习、角色扮演、知识积累等环节。地位和作用：社会实践是社会化的根本环节，在社会化过程中，紧紧把握时代的脉搏，广泛拓展生活实践的空间，是尤其应该重视的一个问题。 第四节 人的全面发展 社会化的基本目标：从根本上说，是培养合格的社会成员。社会化的现实结果，就是培养人适应社会生活所需要的各种角色能力。 社会化的最高目标：是实现人的全面发展。人的全面发展是一个过程。当代人的全面发展就是实现人的现代化。 人的全面发展：是人的一切属性的全面发展 第六章 社会互动第一节 什么是社会互动 社会互动：就是个人和个人之间、个人和群体之间、群体和群体之间，基于对行动“意义”的理解，发生的相互作用的方式和过程。人们对他人采取行动或对他人的行动作出反应的过程。 社会互动的构成要素：(1)必须要有两个或两个以上的互动主体、(2)互动主体之间必须发生某种形式的接触、(3)参与互动的各方有意识地考虑到行动“符号”所代表的“意义”。 社会互动的理论：(1)符号互动论（代表人物：米德、库利、布鲁默）原理：第一，我们通常用符号来代表一些事物。这些符号都是能够有意义地代表另一些事物地，这是在社会互动中形成的；第二，我们针对我们对符号的意义来采取行动；第三，我们在对彼此的行动有所反应之前，经历了一个内有阐释的过程——-对当时情境意义的了解，然后决定如何行动。(2)拟剧论（代表人物：戈夫曼）基本观点：社会是一个舞台，全体社会成员是在这个舞台上扮演不同角色的演员。他们都在社会互动中“表演”自己，塑造自己的形象并更好地达到自己的目的。(3)常人方法学（代表人物：加芬克）基本假设：在现实生活中，社会成员依据一定的规则和程序来进行社会互动，这些日常活动中不成文的、大家公认的互动规则是一切社会活动的基础。 第二节 社会互动的形式 交换概念：在一定的规则下，行为者之间为了获得回报而行动、并获得回报的社会互动形式。构成要素：目标／付出／回报／效益。类型：① 物质的交换，最典型的是商品交换② 非物质的交换，指的是感情、文化等交流形式。社会基础：社会差异 合作概念：指在社会互动中，行为者之间为达到某些共同的利益目标彼此密切配合的一种联合行动。类型：① 自发性合作 ② 制度化的传统合作 ③ 指导性合作 ④ 契约式合作 竞争概念：是指行动者之间为了共同的目标而展开的较量、争夺。类型：社会意义：在于从个人的角度，它可以激发个人的热情，能量，人们在竞争中可以相互激发，相互促进。从社会的角度，竞争对社会发展和进步也是有利的。 冲突概念：是不同行动者之间相互反对或阻止对方意图的自觉行动，根源：也是因为某种社会资源的稀缺。类型：从规模上分，为群体之间的冲突和个人之间的冲突；从冲突的性质上分，为经济冲突、政治冲突、文化冲突、种族冲突以及阶级冲突；从冲突的方式或程度上分，为显性冲突、隐性冲突，显性冲突方式分为：① 争论 ② 拳斗和械斗 ③ 仇斗 ④ 战争 ⑤ 其他。 第三节 社会互动的符号 符号：指的是由一群人所共同认可的，有意义地代表其自身以外的别的事物的东西。 社会互动的重要符号：口头语言、书面语言，身体语言。 语言：指是人类所特有的用来表达意思，交流思想的工具，是由语音、词汇和语法构成的一定的系统。 语言的重要性：语言，作为社会互动中的最重要的符号系统，它的重要性几乎是不言自明的。通过口头和书面语言为媒介，人类文化得以更好的建构的传递，语言作为一个有力的媒介符号，在日常生活中更是帮助了人们之间复杂而微妙的互动 语言的多样性：语言的词汇反映了言语者互动的文化和环境。 身体语言：是用身体代替语言来表达意思的动作或方式。 个人空间：指环绕一个人周围的直接的物理区域。 个人空间理论（霍尔）：他认为人们相距的远近代表了不同的情感距离，因此他认为存在四种不同的个人空间，人们选择特定的空间距离进行互动，不仅可以反映互动各方的关系，而且还塑造他们之间的关系。① 亲密距离 ② 个人距离 ③ 社会距离 ④ 公众距离。 第四节 社会网络 定义：是经过各种媒介、通过社会互动所形成的个人之间的复杂联系网。 特征： ① 社会网络的形成是地缘、血缘、学缘、业缘等多方面的因素使然 ② 反映个人和社会关系的本质 ③ 是经过个人之间的社会互动所形成的 ④ 对个人来说具有效益 ⑤ 是相对稳定的 形态： ① 封闭形态和开放形态，以个人进出该社会网络的难易程度的不同来区分。 ② 稳固形态和松散形态，以个人和社会网络的连接的紧密程度不同来区分 ③ 互利形态和互补形态，以个人在社会网络中获得的利益来区分。 功能：个人在社会网络中获得各种信息、获得各种精神上的支持以及物质上的资源。社会网络影响到个人社会生活的各个方面。就社会而言，社会网络的功能体现在社会网络具有社会控制和社会整合的功能。 第七章 群体第一节 什么是群体 群体的含义：人们通过某种社会关系联结起来进行共同活动和感情交流的集体 群体的特征：① 有一定数量的社会成员② 有一定的为群体成员所接受的目标③ 有明确的成员关系，并形成归属感④ 有一定的行为准则；⑤ 时间上具有一定的持续性。 群体的类型：① 初级群体：又称为首属群体。由面对面的互动所形成的、具有亲密的人际关系的社会群体。是社会群体中最古老最基本的形式，是个人参加社会生活的基础群体，次级群体：又称为次属群体，是用来表示与初级群体相对应的各种群体，如学校，职业群体，社团。② 正式群体：也就是社会组织非正式群体：是一种自发形成的，无正式组织结构，无正式章程的群体。如朋友群③ 内群体和外群体：又称作我群和他群。凡是成员感到自己与群体关系密切，对群体有强烈归属感的，就是内群体。而那些由他人结合而成，与自己没有什么关系的群体，就属于外群体。④ 成员群体：也就是内群体，个人属于该群体的成员。参照群体：被某一群体成员用来作为某种参照对象并试图效法的群体。⑤ 大群体和小群体：是以群体的规模为标准，而进行的一种群众分类。大群体一般指规模较大，人数较多，人员之间较少互动的群体。小群体则是指那些规模较小，成员之间能够直接互动的群体。 初级群体的特征：① 规模小② 是有长期的，经常的面对面互动③ 是成员的人格特征可以得到比较全面的表现④ 成员之间的角色位置难以替代⑤ 习惯伦理道德和感情在维系群体中发挥着重要作用。 初级群体的类型：① 家庭 ② 邻里 ③ 伙伴群体。 现代社会，随着经济和社会生活的发展，初级群体出现了衰落的趋势。 第二节 家庭 概念：是个有婚姻血缘或收养关系的人们组成的长期共同生活的群体，是人类生活中最基本最重要的一种群体形式。 基本关系：婚姻关系、血缘关系、收养关系 基础：婚姻。 特征：① 至少有两个不同性别的成年人居住在一起 ② 他们之间存在着某种劳动分工 ③ 他们进行许多经济交换和社会交换 ④ 他们共享许多事物 ⑤ 成年人与其子女之间有着亲子关系 ⑥ 孩子之间存在着兄弟姐妹关系。 结构：① 核心家庭，一般由一对夫妇及其未婚子女生活在一起而组成的家庭。 ② 主干家庭是由一对夫妇与父母和未婚子女聚居生活的家庭。 ③ 联合家庭 是由父母和多对已婚子女以及孙（外孙）子女组成的家庭。 ④ 其他家庭，指一些不完全的家庭，残缺家庭、断代家庭、单身家庭等类型。 功能： ① 规范性行为功能； ② 经济生活功能； ③ 精神生活功能； ④ 教育功能； ⑤ 抚养、赡养功能。 生命周期：建立、扩展、抚育、收缩、空巢、消亡 我国家庭的现状： ① 家庭规模趋于缩小； ② 家庭功能有所变化一是家庭的消费功能在加强，二是家庭的生育与抚育功能的层次在提高，三是家庭的精神生活功能逐渐增加，四是家庭的事业功能不断扩大； ③ 家庭价值观的认识趋向现代化。 第三节 利益群体 概念：是在社会利益体系中具有相同的利益地位、有着共同的利害和需求、共同的境遇与命运的群体。 特征： ① 利益关系是利益群体的核心关系 ② 群体规模具有不确定性 ③ 群体成员之间的交往具有多样性。 类型 ① 从群体目标特点分为：经济利益群体、政治与社会权利利益群体、社会公众利益群体 ② 从群体组织形式分为：机构性利益群体、社团性利益群体、自组性利益群体 既得利益集团 概念：指对公共资源享有支配权的社会阶层，为了共有的特殊利益而结成的共同体。 最大特点：为维护少部分人的利益而不惜牺牲大多数人的利益。 加快社会主义市场经济建设和与此相适应的政治体制建设的步伐，是防止既得利益集团产生和存在的根本举措。 第八章 组织第一节 什么是组织 概念：是指人们为了达到特定目标而有计划的建立起来的具有比较严密的结构的制度化的群体。 特征：① 具有特定的组织目标② 具有一定的权威体系③ 组织成员的角色化④ 正式而比较明确的规定。 组织过程(1)组织决策：概念：是指组织成员从两个以上的行动方案中进行选择决断，以期最优化地达到组织目标的过程。四个阶段：① 情报阶段 ② 设计阶段 ③ 抉择阶段 ④ 审查阶段(2)组织沟通概念：是组织内部的信息交流，即组织成员之间通过种形式的交往以传达思想观点态度感情或情报的过程。① 纵向沟通：指组织内部的信息由上层到下层或由下层到上层的传递过程。② 横向沟通：指组织内同一层次的部门和组织成员之间的信息传递过程。(3)组织控制概念：组织用各种规章制度和奖惩手段约束组织成员的行为，以保证组织的决策和指令能够有效地贯彻执行，维护组织的各项秩序。① 预先控制：是指在组织行为发生之前所进行的一系列的控制活动。② 现场控制：又叫同步控制是对正在实际进行操作的组织成员的待业进行指导和监控，使组织成员的行为始终指向组织的目标。③ 反馈控制：是针对组织成员的活动结果来进行控制。 三种组织过程的关系：不是相互割裂的过程，而是在具体的现实组织运行过程中相互联系和交织在一起在，任何的组织行动都包含了这三种过程。 第二节 组织理论 科层制（官僚制）(1)概念：是指建立在法理型统治基础上的，以正式规则为管理主体的，具有职权分工和职位等级体系的组织形式和管理方式。(2)合法性统治类型：传统型、魅力型、法理型(3)特征：① 明确规定的固定权限；② 明确规定的职位等级；③ 执行职务建立在公文基础上；④ 职务的专业化和量才录用；⑤ 照章办事。(4)优点：相比其它组织体系和管理方式，行政管理效率高弊端：形式方义、繁文缛节、用人不当、欠缺人情味、对外界变化反应不灵敏 组织管理理论（科学管理理论、人际关系理论、组织行为理论、权变理论和系统理论等）(1)科学管理理论（美国工程师泰罗、法国管理学家法约尔）：为了使组织更有效地实现它的目标，必需使组织的结构和过程科学化和合理化。(2)人际关系理论（梅约、罗伊斯里斯伯格、“霍桑实验”）：人是组织中最重要的因素，组织中起决定作用的主要是社会因素和心理因素以及在工作中形成的人际关系。(3)组织行为理论（巴纳德“组织平衡论”观点、麦克戈的“X 理论”和“Y 理论”）：是从人际关系理论发展而来的组织管理理论。呼吁组织采取民主而非集权专制的领导方式，认为民主型领导比转制型领导的组织效果更好 第三节 现代社会的组织格局 公共部门概念：是指被国家授予公共权力，并以社会的公共利益为组织目标，管理各项社会公共事务，向全体社会成员提供法定服务的政府组织。特征：① 公共部门向社会提供的主要是公共物品② 对公共事务的管理是公共部门的主要职能③ 掌握的资源属于公共资源④ 用来从事公共管理的权力是一种公共权力⑤ 目标在于实现公共利益。 私人部门概念：是指为私人所拥有，并以利润最大化为组织目标，通过在市场上出售其产品或提供服务以求得利润的各类工商企业组织，通过在市场上出售其产品或提供服务以求得利润的各类工商企业组织。特征：① 私人部门向社会提供的主要是私人物品② 组织由私人作为投资主体，其权益归私人所有其组织资源因而变属于私人资源③ 私人部门的组织目标在于本企业的利润最大化④ 市场是私人部门实现目标的竞争性活动领域，也是私人部门主要调节机制。 第三部门概念：在政府组织和营利组织之外，还有一类组织，它们既不是政府的某个部门或下属组织，又不追求组织拥有者的私人利益。它介于国家和市场之间，一般统称为第三部门。特征：① 以公共利益为组织目标，向社会提供公共物品或准公共物品② 独立于政府组织③ 不以营利为组织目标④ 是自主管理的自治组织⑤ 依靠组织成员的志愿参与。作用：① 可以提供公共部门尚未提供的公共物品② 可以满足不同人群对公共物品的多样化需求③ 可以向弱势群体提供他们所需要的物品④ 常常是更可靠的物品和服务提供渠道⑤ 公民参与的一条重要途径⑥ 是倡导公民意识和志愿精神的实践领域。 第九章 社会制度第一节 什么是社会制度 概念：基于一定的价值标准而设立和形成的一套相对稳定的、模式化的、被人们习惯和自觉遵守的规范体系。 起源：社会制度产生的基础应当是社会生产和再生产的方式。 形成的途径：① 自发形成，从民俗升格为民德，再从民德发展为制度；② 立法产生，属于上层建筑的社会制度如政治、思想文化等，一般立法产生。 构成要素：(1)价值要素（价值标准）：指主体对客体的有用性以及用出大小的判断。(2)规范要素：标准、规则和模式，是一系列有关角色行为规范的决定。(3)组织要素：是社会制度的实体部分，是价值和规范的载体。包括组织领导、职能机构和组织成员。(4)设备要素：社会制度运行的物质基础。分为：象征性物质设备、运行性物质设备。 基本特征：① 社会制度的核心是价值标准；② 社会制度是非人格化的权威力量；③ 社会制度具有稳定性和差异性；④ 社会制度具有抑扬性。 基本功能：① 行为导向功能；② 行为调控功能；③ 文化创新功能；④ 社会化促进功能 第二节 社会的基本制度 社会制度的分类：(1)按照形成方式，分为自发产生的制度和根据客观历史需要而有计划建立的制度。(2)按照形成的历史过程及其对个性形成产生的影响，分为① 本源制度：指反映并决定其他一切关系的基础的原始的关系——生产关系以及与其紧密相连的经济活动的规范和制度，包括婚姻家庭制度和经济制度。② 派生制度：建立在本源制度基础上的其他一切制度，如政治制度、教育科学制度(3)按照社会制度的具体性质和作用，分为：婚姻家庭制度、经济制度、政治制度、教育制度、思想文化制度 从人类生存与发展对制度的需求层面看，最基本的社会制度是以下五种：(1)家庭制度（生育制度）概念：是关于家庭的性质、形式、关系、功能、权利和义务的一整套规范体系。功能：繁衍人口，禁止乱伦，提高人口素质。目前中国家庭制度的主要特征：① 家庭结构和功能的过渡性；② 家庭关系和分工的过渡性；③ 家庭问题的复杂性(2)经济制度（生存制度）概念：是社会用以限制调节或促进人们生产分配交换和消费行为的社会规范体系。功能：包括规范经济活动调整经济关系保障社会生产和再生产的持续发展，为人类社会的生存与发展提供物质基础内容：① 对财产所有权的规定② 对社会经济活动中的劳动分工的规定③ 对社会经济运行中交换活动的规定④ 对市场运行的规定⑤ 对经济活动中相互承诺的规定。(3)教育制度（发展制度）概念：是社会的启导延续和发展制度是社会制度体系中的重要组织部分，是社会传授知识与科学提高人的科学文化素质的社会规范体系及其组织机构的总和，它的目的主要是把人类长期积累的知识和科学技术代代相传并使之发扬光大，通过人的素质培养促进社会进步。功能：① 外显功能（传授知识与科学技术的功能；实现社会化的功能；文凭功能；社会选择功能）；② 内潜功能（社会控制功能；调整、协调社会职业体系和社会分层体系；缩小收入差距；吸收剩余劳动力）(4)政治制度（主导制度）概念：是国家权力如何产生如何行使和有关权力结构的规定，由国家颁布并强制执行的，用以约束社会成员和群体活动的规范体系。功能：① 规范社会秩序 ② 管理公共事务。(5)宗教制度（信仰制度）概念：是包括宗教观念、信仰、宗教仪式以及宗教组织形式在内的规范体系。 第三节 社会制度的变革与创新 社会制度的生命周期：就是指一种具体的社会制度从产生、发展、成熟、消失，最后被新的制度替代的过程。 社会制度变革与创新的规律：① 偶然性和必然性的统一；② 历史和逻辑的统一；③ 量变和质变的统一；④ 可能性和现实性的统一。 改革开放以来我国社会变革与创新的主要表现 转型期我国社会制度变革与创新的特征：① 国家和政府在制度创新中的权威作用加强。② 各种社会群体的利益在制度创新中重新定位。③ 调动人民群众的积极性、主动性、创造性，实现好维护好发展好人民群众的利益，是一切制度创新的出发点和归宿。 第十章 社区第一节 什么是社区 概念：是指以一定地域为基础的社会生活共同体。 构成要素：人口、区位、经济、文化、组织。 功能：经济生活、社会化、社会控制、社会参与、社会保障 社区横向格局概念：是指一个社区的各种单位或子系统在本社区内彼此之间的结构和功能关系。特点：社区各社会单位和子系统以地缘关系为纽带，互相联系、互相依存，在功能上互相影响互相制约由此形成一个社区组织体系。 社区纵向格局概念：是指一个社区的各种社会单位和子系统与外部社区的结构和功能关系。特点：其中的组织关系带有更多的法理性计划性和科层制的特征。 社区研究的发展(1)类型学研究（代表人物：德国的滕尼斯）(2)区位学理论(3)社区全貌研究（美国的林德夫妇）(4)中国的社区研究 第二节 社区类型 农村社区（乡村社区）概念：是指以农业生产为主要谋生手段的人们为主体构成的同质性较高的地域性生活共同体。特点：① 人囗密度低；② 经济活动相对简单；③ 社会结构相对简单；④ 传统农村社区的社会变迁比较缓慢。形态：散村和集村 城市社区（都市社区）概念：是指以从不各种非农业生产为谋生手段的具有一定规模的人口所构成的异质性较高的地域性生活共同体。城市的起源与发展：现代城市社区的生活方式的特点：① 社会分工复杂，居民从不更专门化的工作；② 家庭和初级群体作用减弱，取而代之的是各类正式组织；③ 人际互动趋向功利化、理性化、和肤浅化；④ 存在和包容了更多的文化差异。郊区化：指城市发展到一定水平后，大城市的人口和经济活动由城市的中心向城市边缘的郊区迁移和发展的过程。 集镇社区概念：是一种介于农村社区和城市社区之间的中间形态，是联接两者桥梁，是一种由农村向城市过渡的社区形式。集镇社区是农村的政治、经济、文化、信息中心，也是农村基层政权机构和各种服务设施的集中地，能够为周边农村提供各项生活服务。集镇社区是其周围若干农村社区的中心，发挥着主导作用。类型：县城镇、中心镇、一般集镇。特点：① 起着桥梁中介的作用② 人口结构比较复杂③ 集镇经济的自筹、自主性④ 地理环境优越⑤ 城乡结合的社区文化。中国小城镇发展的特点：以集镇为重点，以乡镇企业为依托，建设一批布局合理、节约土地、设施配套、交通方便、文明卫生，具有地方特色的新型乡镇。 第三节 社区发展 概念：指在城乡基层社区中社区居民领先社区自身力量，在政府和其他组织机构的支持下，推动社区有计划地社会变迁，改善社区的经济、社会和文化状况，提高社区居民的生活质量。社区发展既是一个过程，也是一种方法和策略。 基本原则：① 民主；② 需要；③ 自力；④ 自下向上与自上而下相结合的原则；⑤ 物质文明与精神文化并重原则。 社区建设试验区对居委会进行的 5 项改革：① 建立新的社区自治组织② 研究确定社区建设的内容③ 改革社区居委会干部制度④ 推进社区建设的领导机制⑤ 科学合理划分社区。 “单位制”、消解的表现：① 单位体制外人员的增加；② 传统单位的功能型转变 推动中国城市社区发展的根本原因：原来计划经济体制下的“单位制”的城市社区管理模式已经不能适应社会主义市场经济和现代化发展的新变化、新情况和新要求。 中国城市社区建设本质：是对传统城市社会管理模式的变革与创新。 社区建设：就是以人们日常居住和生活的基层社区为载体，通过社区居民自治，社区与政府、企业和其他社会组织共同合作，来建立一个和现代社会保障体系、现代城市管理制度和社会化服务网络相适应的社区支持系统。 第十一章 社会分层与社会流动第一节 社会不平等与社会分层 社会不平等广义：就是社会差别，指个人或群体间的任何差异。（法国启蒙思想家卢梭）狭义：指个人或群体之间的等级差异。（美国学者赫勒） 卢梭的思想：《论人类不平等的起源和基础》论证了不平等的产生是随着私有制而来的，是建立在私有制确立的唯一基础之上的。但从社会分工这个前提条件出发，对社会不平等进行科学探讨的，是亚当.斯密（“分工理论的最早阐发者”，《国富论》最先创立“分工”概念）和马克思主义的创始人。 马克思主义认为，社会不平等根源于社会的物质生产方式，其实质是以生产资料占有关生活费为核心的生产关系。 涂尔干：《社会劳动分工论》，提出机械团结和有机团结两个概念。 社会不平等的主要范畴(1)阶级、阶层和社会分层，阶级：依据社会资源的不同占有状况及其相互关系所组成的社会集团。阶层：① 是指阶级内部的层次划分 ② 泛指具有不同社会地位的群体。社会分层：是指依照一定的标准将人们划分为高低不同的等级序列。(2)种姓、种族和等级种姓：或种姓制度是以血统、血缘和职业为标准，将社会成员划分为不同群体或社会集团的社会等级制度。种族：亦称人种，指在体质形态上具有共同生活遗传特征的人群。等级：指按经济地位和政治法律地位不同而互相区别的群体或社会集团。(3)性别和年龄性别：是指男女两性在生理和心理上的差别。两性的突出的区别：① 在语言表达能力方面，女性优于男性② 在视觉平衡能力方面女性则不如男性③ 在逻辑思维数学能力方面男性较高于女性④ 在触觉方面女性一般比男性敏感，反应更快⑤ 在竟争性、好胜心和合群方面，男性明显优于女性⑥ 在记忆和观察方面男性则较女性逊色。 第二节 社会分层理论 经典社会分层理论(1)马克思主义的阶级理论：揭示了阶级产生的真正根源和阶级本质，建立了科学的阶级、阶层分析方法对于是韦伯社会分层理论。① 社会分工是阶级产生和演变的基础② 生产资料和劳动的占有关系是阶级划分的主要标准③ 共同的生活方式、阶级利益和教育程度是划分阶级的必要条件④ 阶级的划分并不排除社会分层的方法(2)韦伯的社会分层理论：主张用经济（财富）、政治（权力）和社会（声望）三项标准划分阶层。(3)帕累托社会分层理论：《普通社会学总论》① 社会是个异质系统；②“精英”理论。 当代社会分层理论：功能主义和冲突论的社会分层理论各自解释了部分社会现实，存在片面性。进化论者试图提出折中的社会分层理论，认为社会有必要鼓励难得的天才，同时社会也需要有相互竞争。 第三节 中国的社会分层 社会分层的历史意义：70 多年前，毛泽东通过调查发表了《中国社会各阶级的分析》等文章，对中国社会各阶级的状况，特征以及彼此关系进行了科学的分析解决了中国民主革命时期依靠谁，团结谁，打击谁的首要问题。今天我国处在中华民族伟大复兴时期，阶级阶层关系发生了深刻巨大的变化也需要加强研究。 中国在改革开放前的社会分层(1)以经济和政治相结合为标准的划分(2)身分制（以户籍、工作单位和人事管理等一套非财产所有权为标准的社会分层制度体系）为标准的划分户籍制度特点：① 以城乡划界，把人固定在自己的出生地② 户籍与劳动用工制度、人事档案制度和生活资源供应制度相配套。② 单位制度③ 人事管理制度：把社会成员划分为干部、工人和农民。 中国在改革开放后的社会分层(1)从身分到契约的转化契约：是根据一定权利义务关系订立的协议。(2)社会分层结构的变动：① 农村阶层结构的变动；② 城镇阶层结构的变动；③ 军人阶层； ④ 社会边缘阶层 第四节 社会流动 社会流动：指社会成员从一种社会地位或职业向另一种社会地位或职业的移动。 社会流动的意义：社会流动是社会变迁的一种反映。合理的社会流动是现代化社会生存和发展必需的。① 社会化大生产客观上要求实现劳动力流动和人才流动，实现劳动力的合理配置；② 在现代社会中，传统的基于个人出身的地位获得模式正逐步被基于个人业绩的现代模式所取代，社会流动成为个人取得社会地位的重要途径；③ 社会流动加强了个人才能和成就与其社会地位之间的联系，有利于造成一种积极向上的精神，增强社会的活力；④ 社会流动有利于加强各社会集团之间的联系，消除可能存在的隔阂，促进社会成员目标方面的一致认同，从而对社会发展起积极的推动作用。 社会流动的类型和模式(1)结构性流动和自由流动结构性流动：由于生产技术或社会体制方面的变革而引起的规模较大的社会流动。自由流动：是指那不是由于体制的门类化而是由于个人特殊的原因而导致的社会流动。(2)垂直流动和水平流动垂直流动：是社会成员在社会分层结构中跨越等级界限的位置移动分为上向流动和下向流动。水平流动：是社会成员在同一等级的不同位置之间的横向移动。(3)代内流动和代际流动代内流动：是指个人一生中特别是其工作生涯里社会地位的变化，它可以通过比较个人一生中某几个时期的工作反映出来。代际流动：是指子女相对于其父母来说的地位的变化。(4)竞争式流动和赞助式流动(5)个人地位获得模式：美国社会学家布劳和邓肯提出，探讨了代际流动的影响因素。 社会流动的动力机制：① 工业化和科学技术进步（根本动力）；② 城镇化；③ 农村经济体制的改革。 社会流动的制约因素：人口因素、自然因素、地区发展因素、制度因素、政策因素和个人因素。 第十二章 社会控制与偏差行为第一节 什么是偏差行为 偏差行为：指在一定的社会中，社会成员不同程度地偏离或违反了既有的社会规范的行为，也被称为越轨行为、离轨行为、差异行为等。 社会规范：每个社会都存在一套对其社会成员行为具有约束力的行为准则，以调节人们之间的社会关系，指导社会成员的社会行为。 偏差行为的类型(1)按照表现方式分为① 偏差行动：以具体的行动或动作显示出来的偏差行为。如偷抢/强奸/杀人/自杀。② 偏差习惯：个人行为嗜好因不被社会所认可而表现出来的偏差行为。如打麻将。③ 偏差心理：因为心理或精神的原因导致无法进行常规的社会交往或社会活动所表现出来的偏差行为。④ 偏差文化：以与社会主流或主导文化所不同的文化变现出来的偏差行为。(2)按行为所偏离的社会行为准则的标准分为：违法行为、违章行为、违规行为。① 违法行为：违反国家法律条文的行为，包括犯罪和未构成犯罪的违法行为。② 违章行为：违反有关维护社会治安和公共秩序的规章条例。如交通违章,考试作弊。③ 违规行为：指一切违反既定的生活方式、风俗习惯的行为。如不适应行为,不从众、不道德行为。 偏差行为的功能负功能：① 干扰正常的社会生活秩序② 损害个人和社会的利益③ 减弱他人遵从规范的意愿④ 破坏社会成员间的相互信任。正功能：① 有助于人们进一步认识社会规范② 有助于加强社会团结③ 有助于社会预警④ 有助于促进社会变迁。 第二节 偏差行为的理论解释 生物学解释（隆布罗梭和谢尔顿）：是从个人的生物性和生理性特征来解释偏差行为发生的原因，尤其强调遗传因素的作用。 根本缺陷：在于它无法区分产生偏差行为的生理因素影响和社会文化影响的界限，也无法指出生理特征和偏差行为之间的实际联系,查理斯戈林发现。 心理学解释（费洛伊德）：重视个人的精神、情绪、性格等心理因素对行为的影响，认为之所以出现偏差行为是因为个人心理方面的原因造成偏差者没有能力去学习和遵守有关的社会规范。心理学主要从个人层面出发解释偏差行为，有助于我们了解个人产生偏差行为的心理过程，特别是特定的偏差行为的个体发生机制。 社会学解释：更强调社会结构性因素对偏差行为的影响。 (1)失范理论：（涂尔干，默顿）认为是社会失范导致了个人的偏差行为。 (2)文化传递理论：亚文化理论，认为偏差行为者表现出来的偏差行为是从其所处的文化环境中习得的，他们不是偏离了社会规范，而是遵循着所在团体的社会规范，他们的行为之所以被视为偏差行为，只是因为他们所在团体的规范和主流的社会规范不一致甚至是矛盾的。 (3)标签理论：认为一种行为之所以被视为偏差行为是因社会的权力集团给这种行为贴上了偏差的标签、偏差行为只是一种社会定义为偏差的行为。 第二节 社会控制 社会控制：广义的社会控制，是指社会组织通过社会规范以及相应的方式和手段，对社会成员的社会行为进行指导和限制，对各类社会关系加以调节和制约，对社会成员的价值观进行引导和约束的过程。狭义的社会控制则主要指对偏差行为给予惩处和重新教育的过程。 社会控制的内容：包括对社会行为的控制、对社会关系的控制、对社会价值的控制。 社会控制的特点：普遍性/规范性/多重性。 社会控制的必要性： ① 社会生活中个人与个人之间、个人与社会之间的目标不一致上； ② 稳定各种社会关系上；③ 制止社会生活中各种失控现象方面。 社会控制的类型 (1)宏观控制和微观控制 宏观控制：指社会利用政权、法律、政策、条令等手段对整个社会在总体上加以控制，包括政治、经济、文化和意识形态等方面的控制。对稳定社会、促进社会进步意义重大。 微观控制：相对于宏观控制而言，在社会生活的各个具体领域所实现的控制，这些领域涉及人们最基本的社会生活需求。 (2)制度化控制和非制度化控制 制度化控制：指按照一整套条文规定，由某种组织体系加以推行的一种社会控制形式。包括法律控制、宗教控制、规章制度控制等。 非制度化控制：指社会控制的形式并不以明文规定的条文来实现，而是通过社会成员日常互动所形成的共识来实现。包括习俗控制,道德控制,社会舆论控制。 (3)外在控制和内在控制 外在控制：利用外部社会力量促使社会成员遵从社会规范。包括法律控制,规章制度,习俗,道德控制。 内在控制：行为者个人将社会规范内化为自己持有的观念，从而自觉地按照社会规范的要求约束自己的社会行为。 (4)积极性控制和消极性控制 积极性控制：利用奖赏性手段来鼓励社会成员按照社会规范行事，这些手段包括物质性奖励和精神性奖励。 消极性控制：利用惩罚性手段来限制社会成员不要做一些行为。 社会控制的方式： ① 法律控制：由国家强制力推行的，对社会成员具有最强约束力的社会控制方式 ② 道德控制：是人们在集体生活中约定俗成的一套辨别是非、辨别善恶、辨别正义与非正义的价值标准。 ③ 习俗控制：是人们在集体生活中逐渐形成并共同遵守的行为准则，是人类生活中最基本的也是最原始的一种社会控制方 ④ 宗教控制：是一种重要的社会控制方式，能够对其教徒产生很强的约束力 社会控制的度：社会控制应避免社会过控和失控，合理适度的社会控制将有助于社会稳定繁荣，也有助于人的个性全面发展以及创造性的发挥。 社会过控：过分强调了社会控制的一面，忽视了社会成员的个性表达及自由要求的一面。 社会失控：指社会控制相对削弱，社会成员的自由散漫性提高。 第十三章 社会问题第一节 什么是社会问题 社会问题：是指因个人与社会的关系的失调或社会结构与环境失调而影响相当数量社会成员的正常生活，妨碍社会协调发展的问题。 形成条件：① 某些社会现象产生了失调情况② 这种失调影响了许多人正常的社会生活③ 这种失调引起了相当多社会成员的关注。 社会问题与个人困扰的区别：① 个人困扰必须和个人的自我联系在一起，只关系到个人直接体验的有限的社会生活领域而社会问题所牵涉的事情超出个人的局部环境，超出个人一己的生活领域② 困扰只涉及个人而社会问题涉及的是公众③ 个人困扰具有个人的特点他只发生在个人与他人直接的关系区域里而社会问题具有公众的特点。 特征：普遍性、特殊性、复杂性、群体性。 社会问题研究的理论：社会病理学、社会解组理论、价值冲突理论、行为偏差理论、社会建构理论。 第二节 当代社会问题 结构性社会问题：指社会制度或社会政策失调诱发的社会问题。(1)腐败问题定义：是权力的滥用，即不正当地利用政府和公众所赋予的权力和权威来为个人或个人所效忠的某个集团谋取利益。分类：海登海姆① 以公共职位为中心的腐败② 以市场为中心的腐败③ 以公共利益为中心的腐败。危害：① 腐败会严重削弱党和政府的威信，直接危及政治稳定② 会制约社会经济发展，扰乱社会经济秩序③ 会削弱中央的权威，破坏国家统一和民族团结④ 会造成社会思想混乱，是社会整体道德水平滑坡⑤ 会破环法制，使社会处于无序状态⑥ 腐败滋生蔓延会对社会心理稳定做成冲击⑦ 腐败得不到遏制，还会影响新一代的成长。(2)恐怖主义定义：亚国家组织或秘密团体对非战斗目标发起的有预谋的，有政治目的的，通常故意影响视听的暴力行为。要素：政治性、暴力性、不可预测性、象征性主要恐怖活动：① 爆炸；② 绑架、劫持人质；③ 暗杀；④ 劫持飞机⑤ 写恐怖信或打恐怖电话；⑥ 网络恐怖活动。恐怖组织：① 民族主义恐怖组织② 极端宗教恐怖组织如：伊斯兰原教旨主义恐怖组织③ 极左翼恐怖组织如：意大利的红色旅，德国的红军派，日本的赤军④ 极右翼恐怖组织如欧洲的光头联盟⑤ 黑社会恐怖组织如：意大利的黑手党，美国的三 K 党，卡利贩毒集团 偏差性社会问题：一般指偏离或违反一定社会行为规范造成的社会问题。(1)毒品问题定义：是指鸦片、海洛因、甲基苯丙胺（冰毒）、吗啡、大麻、可卡因以及国家规定管制的其他能够使人形成瘾癖的麻醉药品和精神药品。危害：① 危害身体健康；② 破坏家庭和睦；③ 败坏社会风气；④ 腐蚀政权组织；⑤ 妨碍社会主义经济建设和国防建设。(2)家庭暴力概念：行为人以殴打、捆绑、残害强行限制人身自由或者其他手段，给家庭成员造成一定伤害后果的行为。新特点：① 家庭施暴者涉及各个阶层② 夫妻互殴现象增多③ 家庭暴力的攻击性增强，后果严重。 自然性社会问题：自然灾害问题，指一种人类无法控制的自然力量造成的问题。特征：潜在性/突发性/有限性。不能称为灾害的是：海底地震/深海暗流/无人荒岛的沉降/北极圈内的风暴等。 第三节 社会问题的防治 实质：在党和政府的领导下，调动社会上的一切积极因素，组织相关部门，分工协作，运用政治、经济、文化、教育、法律、科学技术和行政等多种手段，对潜在或显露的社会问题进行科学分析，采取相应的对策、避免、减少社会问题的发生或使社会问题得以缓解和解决的过程。又称社会问题的综合治理。 内涵 意义：① 做好社会问题的防治，可有效地维护社会秩序与社会稳定，增强社会和民众的安全感② 可避免和减少社会问题给社会造成的损失，包括直接的和间接的损失，物质和精神的损失③ 可以保障社会主义现代化大业④ 可以促进社会主义精神文明建设⑤ 可以改善、提高有关机构的应对能力和效率。 理论依据：① 社会问题作为一种社会现象如同其他事物一样是可以认识的② 人类社会积聚了大量社会问题防治的经验和理论，为制定社会问题防治的战略和策略提供了科学依据③ 世界和各国内部管理体制存在的抑制社会问题的机制，为社会问题的防治提供了物质基础④ 在全球化进程中国际合作进一步加强，为社会问题的预防提供了国际条件。 战略思想：① 全球性思想② 全局性思想③ 长期性思想 战略措施：① 解放和发展生产力② 改革上层建筑和意识形态③ 发展科学技术④ 建立社会预警系统⑤ 发挥舆论监督作用。 第十四章 社会变迁第一节 什么是社会变迁 社会变迁：是个人与社会的关系基本形态的变异。 内容：① 社会关系的基本制度，既社会行为基本规范体系。② 社会关系的基本结构，包括组织结构、阶级结构、职业结构③ 社会关系的基本面貌，即人们的生活方式与行为方式。 特点：① 必然性；② 前进性；③ 非直线性；④ 全面性 基本类型：(1)按照社会变迁的发展方向，分为：社会进化和社会倒退进化过程的特征：长期性、缓慢性、渐进性、局部性(2)按照社会变迁的性质与特点，分为：社会改革与社会革命社会改革：使人们有意识的规划并在较短时间内实现的社会局部调整或全面改良的过程。社会革命:是一种急剧的、对整个社会进行根本改造的社会变迁形式,其目的是为了根本变革社会制度,改变生产关系(3)按照社会变迁的规模，分为：整体变迁和局部变迁(4)按照变迁的人为参与和控制程度，分为：自发变迁和有计划变迁 原因：① 根本原因，是社会生产力的增长以及生产力与生产关系的矛盾运动。② 社会物质需要和利益冲突③ 科学技术在现代社会也是导致社会变迁的一个重要因素④ 文化的发展与传播⑤ 意识形态的改变⑥ 人口状况的改变⑦ 外敌侵入、环境破坏、自然灾害等因素，也可能引起社会变迁。 有计划的社会变迁：实质上就是对社会运行过程进行干预，对社会系统施加定向影响。 社会发展计划：是对社会发展总的方向、大目标、主要步骤与重大措施的设想。 第二节 社会现代化 概念：是社会变迁上的跃进，是有计划的社会变迁,是以经济发展为中心，涉及政治、法律、社会结构、心理、文化各个领域的全面性发展过程。 主要内容：① 工业化，② 城市化，③ 民主化，④ 管理科层化，⑤ 社会结构分化，⑥ 人的现代化，⑦ 生活方式的世俗化。 特征：① 现代化是一项革命进程② 是一项长期的全球化进程③ 是一项复杂的系统工程④ 不是“全盘欧化”或“全盘西化”的过程。 社会现代化理论：① 帕森斯的模式变项；② 信息社会论；③ 后工业社会论；④ 风险社会论 中国社会现代化的特点：① 四项基本原则是社会主义现代化的基本前提② 社会主义现代化是物质文明和精神文明的协调发展③ 坚持对外开放，走自力更生、艰苦奋斗的社会主义现代化道路。 第三节 全球化 含义：一方面，全球化概念具有空间性内涵，指在全球范围内展现的涉及政治、经济、文化、社会等各个领域的客观历史进程和趋势。另一方面，全球化也蕴涵着世界共同体的各个国家、社会彼此之间的交往和交换关系的进一步加强以及依存性、关联性程度的不断深化。 特征：① 全球化是一个客观的历史进程② 全球化是一个多维度的过程③ 全球化是世界各国的共同性与差异性相统一的客观要求④ 全球化过程是一个不断出现矛盾和冲突的过程。 四个发展阶段：萌芽阶段、开始阶段、起飞阶段、增强阶段。 主要表现：① 以跨国公司为主导的经济全球化② 交通与通讯的全球化③ 信息全球化④ 政治的多极化⑤ 文化全球化。 问题：人口爆炸、资源和能源枯竭、生态恶化、艾滋病泛滥、贩毒、战乱等。 发展趋势两种观点:① 以道德为基础公开反对全球化将导致乌托邦的到来② 认为技术和经济的变革可带来积极的后果。 中国改革开放以来的成就:① 经济上,我国经济同国际市场逐渐接轨,进出口贸易在整个经济中的比重不断上升,外资在投资与经济增长中的作用不断扩大② 政治上中国建立了民主政治体制,加强了与西方各国的接触融洽了曾经因冷战而冻结的关系,可以更广泛地参与国际事务,称为多极中的一极③ 文化上,思想解放运动为全球先进思想文化的引入创造了条件,促进了全球文化同中国文化交流与融合的机遇. 目前面临的挑战:① 在经济全球化过程中，西方发达资本主义国家居支配地位，而发展中国家则处于外围和边缘的地位② 政治方面，由于我国是社会主义国家，经济的高速增长动摇了西方霸权的地位，引起它们的恐慌③ 随着中国对全球化参与程度的加深，中国的文化建设受到了两方面的挑战：一是西方意识形态对马克思主义指导地位的挑战,二是西方一些腐朽文化对中国传统文化的冲击④ 国家安全方面,目前还存在着霸权主义、强权政治等影响世界和平的因素，我们所面临的国际安全环境并不乐观。 应对策略：① 必须明确中国在全球化进程中的位置，以此为制定全球战略的前提。② 要不断解放思想、深化改革、发展自己。③ 增强综合国力以确保国家安全。","link":"/2021/01/22/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/%E7%A4%BE%E4%BC%9A%E5%AD%A6/%E7%A4%BE%E4%BC%9A%E5%AD%A6%E4%B8%BB%E8%A7%82%E7%B2%BE%E7%AE%80/"},{"title":"社会学概论","text":"社会学概论 第一章 社会学的产生与发展第一节 社会学的创立与早期代表人物 社会学创立的历史条件：(1)社会变革的需要(2)自然科学发展的推动(3)社会思想和社会经验研究的产物 创立时期代表人物：(1)奥古斯特.孔德《实证哲学教程》。第一个提出“社会学”概念并创立社会学的人，被称为“社会学之父”。学说：① 科学的序列。② 社会学的研究对象。分为社会静力学和社会动力学两个部分。三阶段法则（人类理性发展：神学、哲学、实证；人类社会：军事、过渡、工业）秩序和进步是孔德实证主义社会学的核心概念。③ 研究方法。必须用研究自然界的科学方法来研究人类社会。观察法、实验法、比较法，历史法。(2)赫伯特·斯宾塞：《社会静力学》《社会学研究》《社会学原理》《伦理学原理》。① 社会有机体论；② 社会进化论(3)马克思主义社会学《共产党宣言》、《资本论》。布哈林《历史唯物主义——马克思主义社会学通俗读物》，经典马克思主义社会学的第一本教科书 形成时期的代表人物：(1)涂尔干：《社会劳动分工论》《社会学方法论》《自杀论》。创办《社会学年鉴》。社会学年鉴学派的创始人，继承和发展了孔德创立的社会学。系统的社会学功能分析推理方法是由涂尔干创建的。① 社会学的研究对象 ② 个人与社会 ③ 功能分析(2)韦伯：《新教伦理与资本主义精神》《经济与社会》合理性是韦伯社会学理论的核心概念。① 理解社会学 ② 社会行动类型 ③ 理想类型 ④ 科层制（官僚制） 第二节 社会学的发展 社会学中心在 19 世纪末 20 世纪初由欧洲转移的美国，首先在美国发展为制度化学科。(1)芝加哥学派代表人物：斯莫尔、托马斯、帕克、伯吉斯。后期的主帅布鲁斯主要学术成就：第一，开拓了现代城市社区研究，使社区研究进入了一个新阶段。第二，开创了人文区位学研究的先河。第三，创建符号互动论。(2)现代结构功能学派 二战后欧洲社会学的发展特点:(1)社会学的研究重心转向现实社会(2)社会学研究领域的多样化(3)社会学的理论研究已趋向多元化(4)欧洲社会学的制度化建设也取得了很大进展。 苏俄社会学：米海洛夫斯基创立了主观社会学，列宁和普列汉诺夫对他们的主观社会学进行了有力的批评。普列汉诺夫和布哈林是当时苏联社会学的主要人物。 中国社会学发展的历史分期：传入时期（1891-1911）：谭嗣同／严复／章太炎成长时期（1912-1927）：余天休／陈达建设时期（1928-1952）：许仕廉/张鸿钧/晏阳初/李景汉/费孝通 毛泽东恢复重建（1979- ）：费孝通/田汝康/雷洁琼/王康 第三节 社会学本土化 本土化：使移植进来的某一事物扎根于本乡本土，适应本土的特性，并萌芽、成长、壮大。社会学本土化是一种使外来社会学与本土社会的实际相结合，形成具有本土特色的社会学理论与研究方法的学术过程。 社会学在中国的本土化的主要倡导人物：许仕廉／孙本文／吴文藻。晏阳初等人的乡村建设和社区发展理论、潘光旦的“位育”理论、费孝通的“差序格局”理论等已经成为具有影响的研究中国社会的重要理论观点。 实现社会学中国化的基本做法：(1)社会学的基本理论应当体现出马克思主义的立场、观点和方法；(2)把研究经济社会协调发展和人的社会化作为社会学的基本任务；(3)立足中国社会的现实，坚持理论联系实际，宏观和微观相结合，理论经研究和经验研究相结合，使社会学的研究与教学能切实为我国的社会主义建设事业服务；(4)采取积极的态度，在借鉴国外社会学的中国过去社会学的优秀成果的基础上，进行创新，逐步建立中国社会学的理论知识体系，形成中国社会学学派；(5)造就一支愿意并有能力为奋斗的社会学专业队伍。 社会学本土化是社会学发展的必然进程，在中国，社会学本土化是与社会学中国化相一致的，起步于 20 世纪 20、30 年代，20 世纪后期得到了更自觉、更明确、更有组织的推行。在中国，社会学本土化是一项长期的系统工程。 第二章 社会学的研究对象与方法第一节 什么是社会学 社会学：是研究个人与社会的关系的一门综合性社会科学。 社会学的特征：整体性、综合性、实证性和应用性。 研究对象/基本问题：个人与社会的关系。 第二节 社会学的功能 研究功能：① 描述性功能：指那些为了解和掌握发生了什么事、什么情况而进行的探索性研究。② 解释性功能：指对影响社会事实发生、变化的主客观因素，从其因果联系上加以说明的过程。③ 预测性功能：和描述、解释功能相联系的高一层次的目标是预测功能。是要提示将来的社会事件和状态是怎样的。④ 规范性功能：社会研究在回答‘将会怎样’的基础上进一步回答‘应该怎样’的问题。 教育功能：① 帮助人们自觉的完成社会化。② 帮助人们合理选择。 社会管理功能：① 建立规范 ② 提供模式 ③ 反馈信息。 社会批评功能：对旧的思想、旧的观念和阻碍社会进步的事物、行为进行揭露，实事求是地进行理论分析，提出克服和解决问题的意见和建议。 第三节 社会学研究方法 社会学研究方法：主要是指以实证的方式对个人与社会的关系所产生、形成、变化的人们的关系、行为、态度以及各种社会现象进行科学探索的一种研究方法。 社会学实证研究的一般程序：筹划阶段、实施阶段和总结阶段。 社会学研究的资料收集方法：(1)问卷调查：是以问题表格形式向被调查者收集相关资料的一种定量研究方法。(2)实地研究：又称田野调查（英国马林诺夫斯基），它是一种深入研究对象内部，以参与观察和非结构访问的方式收集资料，交通过对这些资料的定性分析来解释社会现象的一种研究方法。可分为参与观察和个案研究。① 参与观察是研究者在某种程度上置身于观察对象的环境和社会活动中，使自己成为被研究群体中的一员的一种观察方法。② 个案研究：对某个社会单位的生活全过程或关于它的某方面的个别事例和整体相关联的一种研究方法。(3)社会实验方法：是根据一定的研究假设，在有控制的条件下，通过观察记录分析发现或证实社会现象变量之间因果关系的一种研究方法。(4)非介入性研究方法：是通过搜集现在了的，以文字数字符号画面等信息形式出现的文献资料，分析和探讨各种个人与社会现象的一种研究方法。 社会学研究的分析方法：(1)定性分析：是对收集到的资料进行归纳、分类、比较进而对某个或某类现象的性质和特征作出概括的一种分析方法。实地研究和非介入性研究属于定性方法。(2)定量分析：是对社会现象的数量特征、数量关系与数量变化进行分析的一种分析方法。问卷调查和实验方法属于定量方法。 定性分析与定量分析的关系：定性方法与定量方法是经常配合使用的。在进行定量分析之前，研究者须借助定性方法确定研究对象的性质，压电行定性分析过程中，研究者又须借助定量研究确定现象发生质变的数量界限和引起质变的原因。两者的不同点有：① 着重点不同 ② 依据不同 ③ 手段不同 ④ 学科基础不同 ⑤ 在研究中所处的层次不同 ⑥ 结论表述形式不同。定性方法是定量方法的基础，是它的指南，但只有同时运用定量方法，才能在精确定量的根据下准确定性。这是二者的辩证关系。定性分析与定量分析的有机结合是社会学研究的正确方向。 第四节 社会学的主要理论观点 经典马克思主义社会学理论：人们在社会生产中发生一定的、必然的、不依他们的意志为转移的生产关系。 结构功能理论：美国帕森斯社会行动的三个要素：目标、情境和规范 冲突理论：功能冲突论（刘易斯.科塞）辩证冲突论：（R.达伦多夫）雷克斯：社会分配、社会整合、社会变迁 交换理论（霍曼斯和布劳创立）：人类的相互交往和社会联合是一种相互的交换过程。 符号互动论（赫伯特.布鲁诺、欧文.戈夫曼）：社会是人们运用符号互动的结果。 其他理论：法兰克福学派的社会批判理论、舒茨的现象社会学理论、加芬克尔为代表的常人方法学、吉登斯的结构化理论、哈贝马斯的沟通理论、卢曼的社会系统理论、布迪厄的结构主义的建构主义。 第三章 社 会第一节 什么是社会 社会的含义：是以一定物质资料生产活动为基础的人类生活的共同体。 基本特征是：① 社会以人为主体② 社会以人们的物质生产活动为基础③ 社会以人与人的交往为纽带④ 社会来源于自然又不同于自然。 社会唯名论：只有个人才是真正的存在，而社会只有一个名称，用来方便地称呼构成社会的许多的个人，是个人行动的产物或互动的形式。（主要代表人物：马克斯·韦伯） 社会唯实论：社会唯实论者也称社会实在论，和社会唯名论者相反，它把社会视为超越个人的客观存在。（主要代表人物：阿奎那、法国的涂尔干） 马克思主义社会观的基本观点：(1)社会是人们交互作用的产物(2)劳动是理解全部社会发展史的钥匙(3)需要是人们社会行为的动力(4)人类社会发展是一个自然历史过程(5)马克思主义社会观是科学的社会观。马克思主义社会观是在社会实践中不断丰富和发展的科学。其科学性：① 社会实践的不断发展，决定了马克思主义社会观是不断丰富和发展的科学② 发展性和创造性是马克思主义社会观的生命之所在。③ 马克思主义社会观与具体社会生活相结合，创造性地促进社会关系良性运行，从而推进了自身的丰富和发展。④ 马克思主义社会观在同形形色色的错误社会观的不断斗争中发展，具有较强的生命力。总之，马克思主义社会观是一种发展创造的、开放的、生气勃勃的思想体系，而不是一个封闭的、僵化的思想体系。 第二节 社会结构 个人与社会：相互联系的具有层次性的四个体系① 角色人格体系 ② 价值规范体系 ③ 权力制度体系 ④ 行为交换体系 社会关系：是人们在物质生产活动和社会交往过程中形成的相互关系的总称。 初级社会关系与次级社会关系结合关系和对应关系血缘关系、地缘关系和业缘关系 如何建立与发展新型的社会关系？① 逐步建立健全新型的社会主义社会关系② 努力推进社会主义精神文明建设③ 加强党风和社会风气的建设④ 加速健全社会主义法制，用法律形式保护已经建立的新型关系和促进消除陈旧落后的社会关系。 社会结构：一般是指社会诸要素之间在相互作用过程中形成的相对稳定的关系。 马克思主义的社会结构观 以劳动或物质资料的生产与再生产作为社会的基础，社会的基本结构必然是生产力与生产关系，经济基础与上层建筑之间的关系体系。 第三节 社会的基本要素 社会赖以存在和发展的基本要素：自然资源、人口资源和文化资源。 人口资源：是指在特定地域内具有一定数量、质量和关系的人的总称。具有两重属性：自然属性和社会属性。 人力资源：指表现在劳动者身上的以劳动者数量和质量表示的资源，体现了包含在人体内的生产能力。其是在各种生产要素中最积极最活跃的主动要素，是社会经济发展的最重要的经济资源。 人口数量：是对人口资源的量的规定性，指一定时间和一定地区有生命的个体总和，通常人口数量指的是人口规模。 人口质量：也称人口素质，是对人口资源的质的规定性，包括人口的身体素质、科学文化素质和思想素质等。 自然资源：是与人类活动相关联的全部自然条件的总和，是社会赖以生存和发展的外部条件。 自然资源分类：① 环境资源 ② 生物资源 ③ 矿产资源。 自然资源特点：有限性、潜力无限性、系统性和空间分布不均匀。 可持续发展的概念：既满足当代人的需要又不对后代人满足他们需要的能力和机会构成危害的发展。 可持续发展的内在矛盾：人与自然、人与人之间的矛盾的不可调和性决定了可持续发展的内在矛盾。① 从人与自然的矛盾来看，人类的祖先类人猿原来是自然界的怀部分，与其他动物一样处于又斗争又互助的自然系统之中。人们必须寻求一种使人类得以持续发展的道路，即人与自然团伙调发展的道路。然而人口高速增长与资源短缺短时间内不可调和。② 从人与人的关系及其矛盾来看，人类改造自然的活动，不可能以个人为单位各自孤立地进行，人们必须在活动中结成一定的生产关系，才能取得成功。然而，发达国家与落后国家之间的不平衡不平等与利益冲突不可能在短时间内解决。 可持续发展的意义：强调的是环境与经济的协调发展，追求的是人与自然的和谐，意义深远的。① 可持有异议续发展尤其突出强调的是发展，消除贫困是实施可持续发展的一项不可缺少的条件。② 把经济发展与环境保护联系起来，并强调把环境保护作为发展进程一个重要弧形成部分，作为衡量发展质量、发展水平和发展要程度的客观标准之一。③ 强调代际之间的机会均等，指出当代人享有的正当的环境权利，后代人出同样享有这些权利。④ 强调了要改变传统的生产方式和消费方法，要求人们在生产时要少投入多产出在消费时要尽可能地多利用少排放。⑤ 要求人们必须彻底改变对自然界的传统态度，建立起新的伦理道德和价值标准，不再把自然界看作是被人类随意盘剥和利用的对象，而应看作人类的资源和价值源泉。 第四章 文 化第一节 什么是文化 文化：可从广义和狭义两个角度去解释。广义的文化是指人类创造出来的一切物质产品和非物质产品的总和。狭义的文化指精神文化，甚至是专指文学艺术、音乐、体育等。 文化的特征：创造性、习得性、共享性、连续积累性、特殊性和共性 文化的构成要素：物质形态要素、精神形态要素、语言符号要素、社会关系和社会组织要素 文化的结构① 文化特质：组成文化的最小单位，也称文化元素。② 文化集丛：功能上互相整合的一组文化特质，它们结合起来共同发挥一项功能以满足人的某种需要，这些文化特质就组成一个文化集丛。③ 文化模式：指由许多文化集丛结合而成的一个文化整体，而与其他文化模式互相区别。 文化的功能：① 社会整合功能 ② 社会导向功能 ③ 反功能（文化也会对社会整合与社会进步起着阻碍甚至破坏作用，此即文化的反功能。一般发生在两种情况下：一是文化滞后现象发生时，精神文化会对物质文化的发展起着阻碍作用。另一种情况是发生在反文化群体和某些亚文化群体中。每个社会除了主流文化之外，都存在着一引起次属文化，也称亚文化。） 第二节 文化的规范体系（习俗、道德、法律和宗教） 习俗概念：也称民俗，是指历代相沿积久而成的被人们普遍遵守的行为模式。特征：① 习俗根植于一定的物质生活条件。② 习俗还和社会环境有关③ 归根结底是由生产力的发展水平决定的④ 随着社会物质生活条件的变化而变化功能：是调整人们行为的重要社会规范，它的调整范围最普遍。 道德概念：是以善恶评价的方式来评价和调节人的行为的观念和规范，是人类自我完善的一种价值标准。现阶段我国的道德标准建设具有重要现实意义。基本道德规范：爱国守法、明理诚信、团结友爱、勤俭自强、敬业奉献 法律概念：是由国家制定或认可的、并以国家强制力保证其实行的社会规范。本质：统治阶级意志，是最具有强制力的社会行为规范。特征：① 公正性，是指在法律面前人人平等。② 强制性与社会习俗和道德不同，法律是依靠国家权力保证其施行的。社会功能：① 惩罚功能 ② 威慑功能 ③ 教育功能 宗教概念：从本质上说是人们对超自然力量的幻想，是对神的敬畏与信仰。正向功能：① 促进社会团结，维持社会秩序② 振奋民众精神，促进社会发展③ 寻求生活意义，为个人提供精神安慰。 宗教和邪教的区别：邪教是打着宗教幌子的反人类，反文化的组织。邪教与宗教有本质不同，① 宗教劝人热爱生活，尊重世俗维护社会秩序；邪教宣扬世界是末日，贬低世俗，劝人毁灭，破坏社会秩序。② 宗教的神是超人间的，宗教教义有经典；邪教的神就在人间，它把生活在现世的教主当作神，把教主的话视为经典。③ 宗教宣传博爱、爱教徒、爱大众；邪教害人，以残忍手段残害信徒，残害他人。 第三节 文化交流 文化交流：是指从文化传播开始的两种文化之间互相沟通、采借、冲突与融合的过程。文化交流是文化的固有属性，是社会发展的必要条件。 文化交流包括：(1)文化传播概念：指某种文化元素随同社会交往而扩散，为其他采借或吸必的过程。过程：（美国人类学家林顿把文化传播分为三个阶段）A 接触与显示阶段 B 选择阶段 C 采纳融合阶段。媒体：最原始最基本的媒体是人。书籍、大众传媒、电子网络。(2)文化采借（又译文化杂交）概念：指一种文化接受或吸收另一种文化的某些文化元素或文化丛，融入本文化的过程。文化融合：对采借过来的文化元素，要放在本土文化中进行磨合，乃至改造，使之于本土文化协调起来，融为一体的过程。(3)文化冲突概念：指异质文化在传播接触中出现的互相排斥的倾向和状态根源：除了民族性之外，更有阶级性。 第五章 社会化第一节 什么是社会化 人具有自然属性和社会属性，每一个个体都是这两种属性的统一。 社会化：是社会对个人的文化教化和个人对社会主动选择与能动调适的统一的社会过程。其内涵从三方面理解：① 时间上，个人社会化涉及到人生发展的全过程；② 内容上，个人社会化关注到个人作为社会一员所应具有的全部文化遗产；③ 社会关系上，个人社会化注重个人与社会的交互作用以及个人社会化的结果。 社会化既是个人生存和发展的需要，也是社会新陈代谢、稳定发展的需要。 社会化的主要功能：文化传承、社会稳定发展、个体自我完善。 社会化的基本内容：(1)生活技能社会化：是人们学习并获得维持生存状态和改善生活质量的本领的过程。① 是衣食技能 ② 职业技能(2)价值观念社会化：是人们认知与认同社会主导价值观念的过程。(3)政治社会化：是个人逐渐学习和接受被现有政治制度采用和确定的政治信念、思想体系、社会制度和政治态度的过程。(4)行为社会化：是人们按照通行的社会行为规范模塑自身行为的过程。(5)角色社会化：是按照社会上规定的角色的要求来支配自己的行为，使个人行为符合于一定社会期望的品质特征。 社会化对人的角色能力的培养主要体现在以下几个方面：① 是分清自己角色类型的能力② 是健全角色扮演的心理状态③ 是全面理解角色规范化的程度④ 明确角色目标。 第二节 社会化的类型与过程 社会化的类型：(1)基本社会化概念：就是“生物人”通过社会文化教化，获得人的社会性，获得社会生活资格的过程。任务：① 生理性成熟即通过人化的生理发育过程，形成完善健全的身心基础 ② 社会性成熟即通过社会文化的教化与自我内化，成为具有独特个性物为能力的社会成员。(2)继续社会化：是指人在成年以后的社会化，或称二级社会化。(3)再社会化概念：也称重新社会化，它是使个人改变以前的知识结构、价值标准和行为模式，建立起新的、符和社会要求和新的形势需要的知识结构、价值标准和行为模式的过程。意义：使人们能够适应日常社会生活的要求，实现与其他社会成员的正常交往，按照社会要求安排生活，维持人与社会的正常关系与社会秩序。(4) 正向社会化和反向社会化正向社会化：是指上代人对下代人的文化传递和教化过程。反向社会化：是年轻一代用新知识新观念影响前辈的过程，这种社会化又称为文化反哺。 E·埃里克森《童年和社会》把个人必理成长的历程划分为八个阶段：婴儿期 幼儿期 幼儿后期 学龄期 青年期 成年早期 成年期 成熟期 R·哈维格斯特把人一生的社会化过程分为六个阶段：幼儿期 儿童期 青年期 成年早期 中年期 老年期 第三节 社会化的条件 生物因素：概念：个人所带有的一种由上代为下代提供的、有利于人类从事社会活动的特殊遗传素质。主要表现：人有异于其他动物的身体结构，为人发展自己的社会性准备了首要的先天生理条件；人有一个组织特殊的大脑，为认识世界，学习社会文化接受社会教化提供了生理物质基础；人还具有高级神经活动系统，有第二信号系统—-语言活动，而语言又是社会化的强有力的工具和杠杆。 环境因素概念：指影响个人社会化过程的全部社会环境。主要内容：包括家庭、学校、伙伴群体、工作单位、社区和大众传媒 社会实践：概念：是实现知识内化与积累，达到社会化目标的根本途径。形式：生产活动，科学实验，社会斗争和人际交往等。主要表现：观察学习、角色扮演、知识积累等环节。地位和作用：社会实践是社会化的根本环节，在社会化过程中，紧紧把握时代的脉搏，广泛拓展生活实践的空间，是尤其应该重视的一个问题。 第四节 人的全面发展 社会化的基本目标：从根本上说，是培养合格的社会成员。社会化的现实结果，就是培养人适应社会生活所需要的各种角色能力。 社会化的最高目标：是实现人的全面发展。人的全面发展是一个过程。当代人的全面发展就是实现人的现代化。 人的全面发展：是人的一切属性的全面发展 马克思的人的全面发展的思想 实现人的全面发展的条件 人的现代化的意义 第六章 社会互动第一节 什么是社会互动 社会互动：就是个人和个人之间、个人和群体之间、群体和群体之间，基于对行动“意义”的理解，发生的相互作用的方式和过程。人们对他人采取行动或对他人的行动作出反应的过程。 社会互动的构成要素：(1)必须要有两个或两个以上的互动主体、(2)互动主体之间必须发生某种形式的接触、(3)参与互动的各方有意识地考虑到行动“符号”所代表的“意义”。 社会互动的理论：(1)符号互动论（代表人物：米德、库利、布鲁默）原理：第一，我们通常用符号来代表一些事物。这些符号都是能够有意义地代表另一些事物地，这是在社会互动中形成的；第二，我们针对我们对符号的意义来采取行动；第三，我们在对彼此的行动有所反应之前，经历了一个内有阐释的过程——-对当时情境意义的了解，然后决定如何行动。(2)拟剧论（代表人物：戈夫曼）基本观点：社会是一个舞台，全体社会成员是在这个舞台上扮演不同角色的演员。他们都在社会互动中“表演”自己，塑造自己的形象并更好地达到自己的目的。(3)常人方法学（代表人物：加芬克）基本假设：在现实生活中，社会成员依据一定的规则和程序来进行社会互动，这些日常活动中不成文的、大家公认的互动规则是一切社会活动的基础。 第二节 社会互动的形式 交换概念：在一定的规则下，行为者之间为了获得回报而行动、并获得回报的社会互动形式。构成要素：目标／付出／回报／效益。类型：① 物质的交换，最典型的是商品交换② 非物质的交换，指的是感情、文化等交流形式。社会基础：社会差异 合作概念：指在社会互动中，行为者之间为达到某些共同的利益目标彼此密切配合的一种联合行动。类型：① 自发性合作 ② 制度化的传统合作 ③ 指导性合作 ④ 契约式合作 竞争概念：是指行动者之间为了共同的目标而展开的较量、争夺。类型：社会意义：在于从个人的角度，它可以激发个人的热情，能量，人们在竞争中可以相互激发，相互促进。从社会的角度，竞争对社会发展和进步也是有利的。 冲突概念：是不同行动者之间相互反对或阻止对方意图的自觉行动，根源：也是因为某种社会资源的稀缺。类型：从规模上分，为群体之间的冲突和个人之间的冲突；从冲突的性质上分，为经济冲突、政治冲突、文化冲突、种族冲突以及阶级冲突；从冲突的方式或程度上分，为显性冲突、隐性冲突，其中显性冲突方式分为：① 争论 ② 拳斗和械斗 ③ 仇斗 ④ 战争 ⑤ 其他。 第三节 社会互动的符号 符号：指的是由一群人所共同认可的，有意义地代表其自身以外的别的事物的东西。 社会互动的重要符号：口头语言、书面语言，身体语言。 语言：指是人类所特有的用来表达意思，交流思想的工具，是由语音、词汇和语法构成的一定的系统。 语言的重要性：语言，作为社会互动中的最重要的符号系统，它的重要性几乎是不言自明的。通过口头和书面语言为媒介，人类文化得以更好的建构的传递，语言作为一个有力的媒介符号，在日常生活中更是帮助了人们之间复杂而微妙的互动 语言的多样性：语言的词汇反映了言语者互动的文化和环境。 身体语言：是用身体代替语言来表达意思的动作或方式。 个人空间：指环绕一个人周围的直接的物理区域。 个人空间理论（霍尔）：他认为人们相距的远近代表了不同的情感距离，因此他认为存在四种不同的个人空间，人们选择特定的空间距离进行互动，不仅可以反映互动各方的关系，而且还塑造他们之间的关系。① 亲密距离 ② 个人距离 ③ 社会距离 ④ 公众距离。 第四节 社会网络 定义：是经过各种媒介、通过社会互动所形成的个人之间的复杂联系网。 特征：① 社会网络的形成是地缘、血缘、学缘、业缘等多方面的因素使然 ② 反映个人和社会关系的本质 ③ 是经过个人之间的社会互动所形成的 ④ 对个人来说具有效益 ⑤ 是相对稳定的 形态：① 封闭形态和开放形态，以个人进出该社会网络的难易程度的不同来区分。 ② 稳固形态和松散形态，以个人和社会网络的连接的紧密程度不同来区分 ③ 互利形态和互补形态，以个人在社会网络中获得的利益来区分。 功能：个人在社会网络中获得各种信息、获得各种精神上的支持以及物质上的资源。社会网络影响到个人社会生活的各个方面。就社会而言，社会网络的功能体现在社会网络具有社会控制和社会整合的功能。 第七章 群体第一节 什么是群体 群体的含义：人们通过某种社会关系联结起来进行共同活动和感情交流的集体 群体的特征：① 有一定数量的社会成员② 有一定的为群体成员所接受的目标③ 有明确的成员关系，并形成归属感④ 有一定的行为准则；⑤ 时间上具有一定的持续性。 群体的类型：① 初级群体：又称为首属群体。由面对面的互动所形成的、具有亲密的人际关系的社会群体。是社会群体中最古老最基本的形式，是个人参加社会生活的基础群体，次级群体：又称为次属群体，是用来表示与初级群体相对应的各种群体，如学校，职业群体，社团。② 正式群体：也就是社会组织非正式群体：是一种自发形成的，无正式组织结构，无正式章程的群体。如朋友群③ 内群体和外群体：又称作我群和他群。凡是成员感到自己与群体关系密切，对群体有强烈归属感的，就是内群体。而那些由他人结合而成，与自己没有什么关系的群体，就属于外群体。④ 成员群体：也就是内群体，个人属于该群体的成员。参照群体：被某一群体成员用来作为某种参照对象并试图效法的群体。⑤ 大群体和小群体：是以群体的规模为标准，而进行的一种群众分类。大群体一般指规模较大，人数较多，人员之间较少互动的群体。小群体则是指那些规模较小，成员之间能够直接互动的群体。 初级群体的特征：① 规模小② 是有长期的，经常的面对面互动③ 是成员的人格特征可以得到比较全面的表现④ 成员之间的角色位置难以替代⑤ 习惯伦理道德和感情在维系群体中发挥着重要作用。 初级群体的类型：① 家庭 ② 邻里 ③ 伙伴群体。 现代社会，随着经济和社会生活的发展，初级群体出现了衰落的趋势。 第二节 家庭 概念：是个有婚姻血缘或收养关系的人们组成的长期共同生活的群体，是人类生活中最基本最重要的一种群体形式。 基本关系：婚姻关系、血缘关系、收养关系 基础：婚姻。 特征：① 至少有两个不同性别的成年人居住在一起 ② 他们之间存在着某种劳动分工 ③ 他们进行许多经济交换和社会交换 ④ 他们共享许多事物 ⑤ 成年人与其子女之间有着亲子关系 ⑥ 孩子之间存在着兄弟姐妹关系。 结构：① 核心家庭，一般由一对夫妇及其未婚子女生活在一起而组成的家庭。 ② 主干家庭是由一对夫妇与父母和未婚子女聚居生活的家庭。 ③ 联合家庭 是由父母和多对已婚子女以及孙（外孙）子女组成的家庭。 ④ 其他家庭，指一些不完全的家庭，残缺家庭、断代家庭、单身家庭等类型。 功能：① 规范性行为功能； ② 经济生活功能； ③ 精神生活功能； ④ 教育功能； ⑤ 抚养、赡养功能。 生命周期：建立、扩展、抚育、收缩、空巢、消亡 我国家庭的现状： ① 家庭规模趋于缩小； ② 家庭功能有所变化一是家庭的消费功能在加强，二是家庭的生育与抚育功能的层次在提高，三是家庭的精神生活功能逐渐增加，四是家庭的事业功能不断扩大； ③ 家庭价值观的认识趋向现代化。 第三节 利益群体 概念：是在社会利益体系中具有相同的利益地位、有着共同的利害和需求、共同的境遇与命运的群体。 特征：① 利益关系是利益群体的核心关系 ② 群体规模具有不确定性 ③ 群体成员之间的交往具有多样性。 类型 ① 从群体目标特点分为：经济利益群体、政治与社会权利利益群体、社会公众利益群体 ② 从群体组织形式分为：机构性利益群体、社团性利益群体、自组性利益群体 既得利益集团 概念：指对公共资源享有支配权的社会阶层，为了共有的特殊利益而结成的共同体。 最大特点：为维护少部分人的利益而不惜牺牲大多数人的利益。 加快社会主义市场经济建设和与此相适应的政治体制建设的步伐，是防止既得利益集团产生和存在的根本举措。 第八章 组织第一节 什么是组织 概念：是指人们为了达到特定目标而有计划的建立起来的具有比较严密的结构的制度化的群体。现代社会是一个高度组织化的社会。组织的普遍存在提高了人民的社会活动效率，延伸和扩展人类自身的能力。 特征：① 具有特定的组织目标② 具有一定的权威体系③ 组织成员的角色化④ 正式而比较明确的规定。 组织过程(1)组织决策：概念：是指组织成员从两个以上的行动方案中进行选择决断，以期最优化地达到组织目标的过程。四个阶段：① 情报阶段 ② 设计阶段 ③ 抉择阶段 ④ 审查阶段(2)组织沟通概念：是组织内部的信息交流，即组织成员之间通过种形式的交往以传达思想观点态度感情或情报的过程。① 纵向沟通：指组织内部的信息由上层到下层或由下层到上层的传递过程。② 横向沟通：指组织内同一层次的部门和组织成员之间的信息传递过程。(3)组织控制概念：组织用各种规章制度和奖惩手段约束组织成员的行为，以保证组织的决策和指令能够有效地贯彻执行，维护组织的各项秩序。① 预先控制：是指在组织行为发生之前所进行的一系列的控制活动。② 现场控制：又叫同步控制是对正在实际进行操作的组织成员的待业进行指导和监控，使组织成员的行为始终指向组织的目标。③ 反馈控制：是针对组织成员的活动结果来进行控制。 三种组织过程的关系：不是相互割裂的过程，而是在具体的现实组织运行过程中相互联系和交织在一起在，任何的组织行动都包含了这三种过程。 第二节 组织理论 科层制（官僚制）(1)概念：是指建立在法理型统治基础上的，以正式规则为管理主体的，具有职权分工和职位等级体系的组织形式和管理方式。科层制是马克斯·韦伯提出的一个重要的社会学概念，它对以后的组织研究产生了深远的影响。(2)合法性统治类型：传统型、魅力型、法理型(3)特征：① 明确规定的固定权限；② 明确规定的职位等级；③ 执行职务建立在公文基础上；④ 职务的专业化和量才录用；⑤ 照章办事。(4)优点：相比其它组织体系和管理方式，行政管理效率高弊端：形式方义、繁文缛节、用人不当、欠缺人情味、对外界变化反应不灵敏 组织管理理论（科学管理理论、人际关系理论、组织行为理论、权变理论和系统理论等）(1)科学管理理论（美国工程师泰罗、法国管理学家法约尔）：为了使组织更有效地实现它的目标，必需使组织的结构和过程科学化和合理化。(2)人际关系理论（梅约、罗伊斯里斯伯格、“霍桑实验”）：人是组织中最重要的因素，组织中起决定作用的主要是社会因素和心理因素以及在工作中形成的人际关系。(3)组织行为理论（巴纳德“组织平衡论”观点、麦克戈的“X 理论”和“Y 理论”）：是从人际关系理论发展而来的组织管理理论。呼吁组织采取民主而非集权专制的领导方式，认为民主型领导比转制型领导的组织效果更好 第三节 现代社会的组织格局 公共部门概念：是指被国家授予公共权力，并以社会的公共利益为组织目标，管理各项社会公共事务，向全体社会成员提供法定服务的政府组织。特征：① 公共部门向社会提供的主要是公共物品② 对公共事务的管理是公共部门的主要职能③ 掌握的资源属于公共资源④ 用来从事公共管理的权力是一种公共权力⑤ 目标在于实现公共利益。 私人部门概念：是指为私人所拥有，并以利润最大化为组织目标，通过在市场上出售其产品或提供服务以求得利润的各类工商企业组织，通过在市场上出售其产品或提供服务以求得利润的各类工商企业组织。特征：① 私人部门向社会提供的主要是私人物品② 组织由私人作为投资主体，其权益归私人所有其组织资源因而变属于私人资源③ 私人部门的组织目标在于本企业的利润最大化④ 市场是私人部门实现目标的竞争性活动领域，也是私人部门主要调节机制。 第三部门概念：在政府组织和营利组织之外，还有一类组织，它们既不是政府的某个部门或下属组织，又不追求组织拥有者的私人利益。它介于国家和市场之间，一般统称为第三部门。特征：① 以公共利益为组织目标，向社会提供公共物品或准公共物品② 独立于政府组织③ 不以营利为组织目标④ 是自主管理的自治组织⑤ 依靠组织成员的志愿参与。在现代社会的作用：① 可以提供公共部门尚未提供的公共物品② 可以满足不同人群对公共物品的多样化需求③ 可以向弱势群体提供他们所需要的物品④ 常常是更可靠的物品和服务提供渠道⑤ 公民参与的一条重要途径⑥ 是倡导公民意识和志愿精神的实践领域。 第九章 社会制度第一节 什么是社会制度 概念：基于一定的价值标准而设立和形成的一套相对稳定的、模式化的、被人们习惯和自觉遵守的规范体系。 起源：社会制度产生的基础应当是社会生产和再生产的方式。从人类需要的角度去探究社会制度的起源是比较合适的，因为任何社会制度都是为适应一定条件下的人类需要而产生的。但是如果仅仅把目光停留在人类需要上，忽略满足需要的手段和途径，就无法从根本上解释社会制度的变异性。 形成的途径：① 自发形成，从民俗升格为民德，再从民德发展为制度；② 立法产生，属于上层建筑的社会制度如政治、思想文化等，一般立法产生。 构成要素：(1)价值要素（价值标准）：指主体对客体的有用性以及用出大小的判断。(2)规范要素：标准、规则和模式，是一系列有关角色行为规范的决定。(3)组织要素：是社会制度的实体部分，是价值和规范的载体。包括组织领导、职能机构和组织成员。(4)设备要素：社会制度运行的物质基础。分为：象征性物质设备、运行性物质设备。 基本特征：① 社会制度的核心是价值标准；② 社会制度是非人格化的权威力量；③ 社会制度具有稳定性和差异性；④ 社会制度具有抑扬性。 基本功能：① 行为导向功能；② 行为调控功能；③ 文化创新功能；④ 社会化促进功能 第二节 社会的基本制度 社会制度的分类：(1)按照形成方式，分为自发产生的制度和根据客观历史需要而有计划建立的制度。(2)按照形成的历史过程及其对个性形成产生的影响，分为① 本源制度：指反映并决定其他一切关系的基础的原始的关系——生产关系以及与其紧密相连的经济活动的规范和制度，包括婚姻家庭制度和经济制度。② 派生制度：建立在本源制度基础上的其他一切制度，如政治制度、教育科学制度(3)按照社会制度的具体性质和作用，分为：婚姻家庭制度、经济制度、政治制度、教育制度、思想文化制度 从人类生存与发展对制度的需求层面看，最基本的社会制度是以下五种：(1)家庭制度（生育制度）概念：是关于家庭的性质、形式、关系、功能、权利和义务的一整套规范体系。功能：繁衍人口，禁止乱伦，提高人口素质。目前中国家庭制度的主要特征：① 家庭结构和功能的过渡性；② 家庭关系和分工的过渡性；③ 家庭问题的复杂性(2)经济制度（生存制度）概念：是社会用以限制调节或促进人们生产分配交换和消费行为的社会规范体系。功能：包括规范经济活动调整经济关系保障社会生产和再生产的持续发展，为人类社会的生存与发展提供物质基础内容：① 对财产所有权的规定② 对社会经济活动中的劳动分工的规定③ 对社会经济运行中交换活动的规定④ 对市场运行的规定⑤ 对经济活动中相互承诺的规定。(3)教育制度（发展制度）概念：是社会的启导延续和发展制度是社会制度体系中的重要组织部分，是社会传授知识与科学提高人的科学文化素质的社会规范体系及其组织机构的总和，它的目的主要是把人类长期积累的知识和科学技术代代相传并使之发扬光大，通过人的素质培养促进社会进步。功能：① 外显功能（传授知识与科学技术的功能；实现社会化的功能；文凭功能；社会选择功能）；② 内潜功能（社会控制功能；调整、协调社会职业体系和社会分层体系；缩小收入差距；吸收剩余劳动力）(4)政治制度（主导制度）概念：是国家权力如何产生如何行使和有关权力结构的规定，由国家颁布并强制执行的，用以约束社会成员和群体活动的规范体系。功能：① 规范社会秩序 ② 管理公共事务。(5)宗教制度（信仰制度）概念：是包括宗教观念、信仰、宗教仪式以及宗教组织形式在内的规范体系。 第三节 社会制度的变革与创新 社会制度的生命周期：就是指一种具体的社会制度从产生、发展、成熟、消失，最后被新的制度替代的过程。 社会制度变革与创新的规律：① 偶然性和必然性的统一；② 历史和逻辑的统一；③ 量变和质变的统一；④ 可能性和现实性的统一。 改革开放以来我国社会变革与创新的主要表现 转型期我国社会制度变革与创新的特征：① 国家和政府在制度创新中的权威作用加强。② 各种社会群体的利益在制度创新中重新定位。③ 调动人民群众的积极性、主动性、创造性，实现好维护好发展好人民群众的利益，是一切制度创新的出发点和归宿。 第十章 社区第一节 什么是社区 概念：是指以一定地域为基础的社会生活共同体。 构成要素：人口、区位、经济、文化、组织。 功能：经济生活、社会化、社会控制、社会参与、社会保障 社区横向格局概念：是指一个社区的各种单位或子系统在本社区内彼此之间的结构和功能关系。特点：社区各社会单位和子系统以地缘关系为纽带，互相联系、互相依存，在功能上互相影响互相制约由此形成一个社区组织体系。 社区纵向格局概念：是指一个社区的各种社会单位和子系统与外部社区的结构和功能关系。特点：其中的组织关系带有更多的法理性计划性和科层制的特征。 社区研究的发展(1)类型学研究（代表人物：德国的滕尼斯）(2)区位学理论(3)社区全貌研究（美国的林德夫妇）(4)中国的社区研究 第二节 社区类型 农村社区（乡村社区）概念：是指以农业生产为主要谋生手段的人们为主体构成的同质性较高的地域性生活共同体。特点：① 人囗密度低；② 经济活动相对简单；③ 社会结构相对简单；④ 传统农村社区的社会变迁比较缓慢。形态：散村和集村 城市社区（都市社区）概念：是指以从不各种非农业生产为谋生手段的具有一定规模的人口所构成的异质性较高的地域性生活共同体。城市的起源与发展：现代城市社区的生活方式的特点：① 社会分工复杂，居民从不更专门化的工作；② 家庭和初级群体作用减弱，取而代之的是各类正式组织；③ 人际互动趋向功利化、理性化、和肤浅化；④ 存在和包容了更多的文化差异。郊区化：指城市发展到一定水平后，大城市的人口和经济活动由城市的中心向城市边缘的郊区迁移和发展的过程。 集镇社区概念：是一种介于农村社区和城市社区之间的中间形态，是联接两者桥梁，是一种由农村向城市过渡的社区形式。集镇社区是农村的政治、经济、文化、信息中心，也是农村基层政权机构和各种服务设施的集中地，能够为周边农村提供各项生活服务。集镇社区是其周围若干农村社区的中心，发挥着主导作用。类型：县城镇、中心镇、一般集镇。特点：① 起着桥梁中介的作用② 人口结构比较复杂③ 集镇经济的自筹、自主性④ 地理环境优越⑤ 城乡结合的社区文化。中国小城镇发展的特点：以集镇为重点，以乡镇企业为依托，建设一批布局合理、节约土地、设施配套、交通方便、文明卫生，具有地方特色的新型乡镇。 第三节 社区发展 概念：指在城乡基层社区中社区居民领先社区自身力量，在政府和其他组织机构的支持下，推动社区有计划地社会变迁，改善社区的经济、社会和文化状况，提高社区居民的生活质量。社区发展既是一个过程，也是一种方法和策略。 基本原则：① 民主；② 需要；③ 自力；④ 自下向上与自上而下相结合的原则；⑤ 物质文明与精神文化并重原则。 社区建设试验区对居委会进行的 5 项改革：① 建立新的社区自治组织② 研究确定社区建设的内容③ 改革社区居委会干部制度④ 推进社区建设的领导机制⑤ 科学合理划分社区。 “单位制”、消解的表现：① 单位体制外人员的增加；② 传统单位的功能型转变 推动中国城市社区发展的根本原因：原来计划经济体制下的“单位制”的城市社区管理模式已经不能适应社会主义市场经济和现代化发展的新变化、新情况和新要求。 中国城市社区建设本质：是对传统城市社会管理模式的变革与创新。 社区建设：就是以人们日常居住和生活的基层社区为载体，通过社区居民自治，社区与政府、企业和其他社会组织共同合作，来建立一个和现代社会保障体系、现代城市管理制度和社会化服务网络相适应的社区支持系统。 第十一章 社会分层与社会流动第一节 社会不平等与社会分层 社会不平等广义：就是社会差别，指个人或群体间的任何差异。（法国启蒙思想家卢梭）狭义：指个人或群体之间的等级差异。（美国学者赫勒） 卢梭的思想：《论人类不平等的起源和基础》论证了不平等的产生是随着私有制而来的，是建立在私有制确立的唯一基础之上的。但从社会分工这个前提条件出发，对社会不平等进行科学探讨的，是亚当.斯密（“分工理论的最早阐发者”，《国富论》最先创立“分工”概念）和马克思主义的创始人。 马克思主义认为，社会不平等根源于社会的物质生产方式，其实质是以生产资料占有关生活费为核心的生产关系。 涂尔干：《社会劳动分工论》，提出机械团结和有机团结两个概念。 社会不平等的主要范畴(1)阶级、阶层和社会分层，阶级：依据社会资源的不同占有状况及其相互关系所组成的社会集团。阶层：① 是指阶级内部的层次划分 ② 泛指具有不同社会地位的群体。社会分层：是指依照一定的标准将人们划分为高低不同的等级序列。(2)种姓、种族和等级种姓：或种姓制度是以血统、血缘和职业为标准，将社会成员划分为不同群体或社会集团的社会等级制度。种族：亦称人种，指在体质形态上具有共同生活遗传特征的人群。等级：指按经济地位和政治法律地位不同而互相区别的群体或社会集团。(3)性别和年龄性别：是指男女两性在生理和心理上的差别。两性的突出的区别：① 在语言表达能力方面，女性优于男性② 在视觉平衡能力方面女性则不如男性③ 在逻辑思维数学能力方面男性较高于女性④ 在触觉方面女性一般比男性敏感，反应更快⑤ 在竟争性、好胜心和合群方面，男性明显优于女性⑥ 在记忆和观察方面男性则较女性逊色。 第二节 社会分层理论 经典社会分层理论(1)马克思主义的阶级理论：揭示了阶级产生的真正根源和阶级本质，建立了科学的阶级、阶层分析方法对于是韦伯社会分层理论。① 社会分工是阶级产生和演变的基础② 生产资料和劳动的占有关系是阶级划分的主要标准③ 共同的生活方式、阶级利益和教育程度是划分阶级的必要条件④ 阶级的划分并不排除社会分层的方法(2)韦伯的社会分层理论：主张用经济（财富）、政治（权力）和社会（声望）三项标准划分阶层。(3)帕累托社会分层理论：《普通社会学总论》① 社会是个异质系统；②“精英”理论。 当代社会分层理论：功能主义和冲突论的社会分层理论各自解释了部分社会现实，存在片面性。进化论者试图提出折中的社会分层理论，认为社会有必要鼓励难得的天才，同时社会也需要有相互竞争。 第三节 中国的社会分层 社会分层的历史意义：70 多年前，毛泽东通过调查发表了《中国社会各阶级的分析》等文章，对中国社会各阶级的状况，特征以及彼此关系进行了科学的分析解决了中国民主革命时期依靠谁，团结谁，打击谁的首要问题。今天我国处在中华民族伟大复兴时期，阶级阶层关系发生了深刻巨大的变化也需要加强研究。 中国在改革开放前的社会分层(1)以经济和政治相结合为标准的划分(2)身分制（以户籍、工作单位和人事管理等一套非财产所有权为标准的社会分层制度体系）为标准的划分① 户籍制度特点：① 以城乡划界，把人固定在自己的出生地② 户籍与劳动用工制度、人事档案制度和生活资源供应制度相配套。② 单位制度③ 人事管理制度：把社会成员划分为干部、工人和农民。 中国在改革开放后的社会分层(1)从身分到契约的转化契约：是根据一定权利义务关系订立的协议。(2)社会分层结构的变动：① 农村阶层结构的变动；② 城镇阶层结构的变动；③ 军人阶层； ④ 社会边缘阶层 第四节 社会流动 社会流动：指社会成员从一种社会地位或职业向另一种社会地位或职业的移动。 社会流动的意义：社会流动是社会变迁的一种反映。合理的社会流动是现代化社会生存和发展必需的。① 社会化大生产客观上要求实现劳动力流动和人才流动，实现劳动力的合理配置；② 在现代社会中，传统的基于个人出身的地位获得模式正逐步被基于个人业绩的现代模式所取代，社会流动成为个人取得社会地位的重要途径；③ 社会流动加强了个人才能和成就与其社会地位之间的联系，有利于造成一种积极向上的精神，增强社会的活力；④ 社会流动有利于加强各社会集团之间的联系，消除可能存在的隔阂，促进社会成员目标方面的一致认同，从而对社会发展起积极的推动作用。 社会流动的类型和模式(1)结构性流动和自由流动结构性流动：由于生产技术或社会体制方面的变革而引起的规模较大的社会流动。自由流动：是指那不是由于体制的门类化而是由于个人特殊的原因而导致的社会流动。(2)垂直流动和水平流动垂直流动：是社会成员在社会分层结构中跨越等级界限的位置移动分为上向流动和下向流动。水平流动：是社会成员在同一等级的不同位置之间的横向移动。(3)代内流动和代际流动代内流动：是指个人一生中特别是其工作生涯里社会地位的变化，它可以通过比较个人一生中某几个时期的工作反映出来。代际流动：是指子女相对于其父母来说的地位的变化。(4)竞争式流动和赞助式流动(5)个人地位获得模式：美国社会学家布劳和邓肯提出，探讨了代际流动的影响因素。 社会流动的动力机制：① 工业化和科学技术进步（根本动力）；② 城镇化；③ 农村经济体制的改革。 社会流动的制约因素：人口因素、自然因素、地区发展因素、制度因素、政策因素和个人因素。 第十二章 社会控制与偏差行为第一节 什么是偏差行为 偏差行为：指在一定的社会中，社会成员不同程度地偏离或违反了既有的社会规范的行为，也被称为越轨行为、离轨行为、差异行为等。 社会规范：每个社会都存在一套对其社会成员行为具有约束力的行为准则，以调节人们之间的社会关系，指导社会成员的社会行为。 偏差行为的类型(1)按照表现方式分为① 偏差行动：以具体的行动或动作显示出来的偏差行为。如偷抢/强奸/杀人/自杀。② 偏差习惯：个人行为嗜好因不被社会所认可而表现出来的偏差行为。如打麻将。③ 偏差心理：因为心理或精神的原因导致无法进行常规的社会交往或社会活动所表现出来的偏差行为。④ 偏差文化：以与社会主流或主导文化所不同的文化变现出来的偏差行为。(2)按行为所偏离的社会行为准则的标准分为：违法行为、违章行为、违规行为。① 违法行为：违反国家法律条文的行为，包括犯罪和未构成犯罪的违法行为。② 违章行为：违反有关维护社会治安和公共秩序的规章条例。如交通违章,考试作弊。③ 违规行为：指一切违反既定的生活方式、风俗习惯的行为。如不适应行为,不从众、不道德行为。 偏差行为的功能负功能：① 干扰正常的社会生活秩序② 损害个人和社会的利益③ 减弱他人遵从规范的意愿④ 破坏社会成员间的相互信任。正功能：① 有助于人们进一步认识社会规范② 有助于加强社会团结③ 有助于社会预警④ 有助于促进社会变迁。 第二节 偏差行为的理论解释 生物学解释（隆布罗梭和谢尔顿）：是从个人的生物性和生理性特征来解释偏差行为发生的原因，尤其强调遗传因素的作用。 根本缺陷：在于它无法区分产生偏差行为的生理因素影响和社会文化影响的界限，也无法指出生理特征和偏差行为之间的实际联系,查理斯戈林发现。 心理学解释（费洛伊德）：重视个人的精神、情绪、性格等心理因素对行为的影响，认为之所以出现偏差行为是因为个人心理方面的原因造成偏差者没有能力去学习和遵守有关的社会规范。心理学主要从个人层面出发解释偏差行为，有助于我们了解个人产生偏差行为的心理过程，特别是特定的偏差行为的个体发生机制。 社会学解释：更强调社会结构性因素对偏差行为的影响。 (1)失范理论：（涂尔干，默顿）认为是社会失范导致了个人的偏差行为。 (2)文化传递理论：也称为亚文化理论，认为偏差行为者表现出来的偏差行为是从其所处的文化环境中习得的，他们不是偏离了社会规范，而是遵循着所在团体的社会规范，他们的行为之所以被视为偏差行为，只是因为他们所在团体的规范和主流的社会规范不一致甚至是矛盾的。 (3)标签理论：认为一种行为之所以被视为偏差行为是因社会的权力集团给这种行为贴上了偏差的标签、偏差行为只是一种社会定义为偏差的行为。 第二节 社会控制 社会控制：广义的社会控制，是指社会组织通过社会规范以及相应的方式和手段，对社会成员的社会行为进行指导和限制，对各类社会关系加以调节和制约，对社会成员的价值观进行引导和约束的过程。狭义的社会控制则主要指对偏差行为给予惩处和重新教育的过程。 社会控制的内容：包括对社会行为的控制、对社会关系的控制、对社会价值的控制。 社会控制的特点：普遍性/规范性/多重性。 社会控制的必要性： ① 社会生活中个人与个人之间、个人与社会之间的目标不一致上； ② 稳定各种社会关系上；③ 制止社会生活中各种失控现象方面。 社会控制的类型 (1)宏观控制和微观控制 宏观控制：指社会利用政权、法律、政策、条令等手段对整个社会在总体上加以控制，包括政治、经济、文化和意识形态等方面的控制。对稳定社会、促进社会进步意义重大。 微观控制：相对于宏观控制而言，在社会生活的各个具体领域所实现的控制，这些领域涉及人们最基本的社会生活需求。 (2)制度化控制和非制度化控制 制度化控制：指按照一整套条文规定，由某种组织体系加以推行的一种社会控制形式。包括法律控制、宗教控制、规章制度控制等。 非制度化控制：指社会控制的形式并不以明文规定的条文来实现，而是通过社会成员日常互动所形成的共识来实现。包括习俗控制,道德控制,社会舆论控制。 (3)外在控制和内在控制 外在控制：利用外部社会力量促使社会成员遵从社会规范。包括法律控制,规章制度,习俗,道德控制。 内在控制：行为者个人将社会规范内化为自己持有的观念，从而自觉地按照社会规范的要求约束自己的社会行为。 (4)积极性控制和消极性控制 积极性控制：利用奖赏性手段来鼓励社会成员按照社会规范行事，这些手段包括物质性奖励和精神性奖励。 消极性控制：利用惩罚性手段来限制社会成员不要做一些行为。 社会控制的方式： ① 法律控制：由国家强制力推行的，对社会成员具有最强约束力的社会控制方式，是由国家制定或认可的一种社会规范，是所有社会规范中最有权威的一种，是统治阶级意志的体现，是以国家权力为依托，给予强制执行的一种社会控制方式。 ② 道德控制：是人们在集体生活中约定俗成的一套辨别是非、辨别善恶、辨别正义与非正义的价值标准。 ③ 习俗控制：是人们在集体生活中逐渐形成并共同遵守的行为准则，是人类生活中最基本的也是最原始的一种社会控制方式。 ④ 宗教控制：是一种重要的社会控制方式，能够对其教徒产生很强的约束力。 社会控制的度：社会控制应避免社会过控和失控，合理适度的社会控制将有助于社会稳定繁荣，也有助于人的个性全面发展以及创造性的发挥。 社会过控：过分强调了社会控制的一面，忽视了社会成员的个性表达及自由要求的一面。 社会失控：指社会控制相对削弱，社会成员的自由散漫性提高。 第十三章 社会问题第一节 什么是社会问题 社会问题：是指因个人与社会的关系的失调或社会结构与环境失调而影响相当数量社会成员的正常生活，妨碍社会协调发展的问题。 形成条件：① 某些社会现象产生了失调情况② 这种失调影响了许多人正常的社会生活③ 这种失调引起了相当多社会成员的关注。 社会问题与个人困扰的区别：① 个人困扰必须和个人的自我联系在一起，只关系到个人直接体验的有限的社会生活领域而社会问题所牵涉的事情超出个人的局部环境，超出个人一己的生活领域② 困扰只涉及个人而社会问题涉及的是公众③ 个人困扰具有个人的特点他只发生在个人与他人直接的关系区域里而社会问题具有公众的特点。 特征：普遍性、特殊性、复杂性、群体性。 社会问题研究的理论：社会病理学、社会解组理论、价值冲突理论、行为偏差理论、社会建构理论。 第二节 当代社会问题 结构性社会问题：指社会制度或社会政策失调诱发的社会问题。(1)腐败问题定义：是权力的滥用，即不正当地利用政府和公众所赋予的权力和权威来为个人或个人所效忠的某个集团谋取利益。分类：海登海姆① 以公共职位为中心的腐败② 以市场为中心的腐败③ 以公共利益为中心的腐败。危害：① 腐败会严重削弱党和政府的威信，直接危及政治稳定② 会制约社会经济发展，扰乱社会经济秩序③ 会削弱中央的权威，破坏国家统一和民族团结④ 会造成社会思想混乱，是社会整体道德水平滑坡⑤ 会破环法制，使社会处于无序状态⑥ 腐败滋生蔓延会对社会心理稳定做成冲击⑦ 腐败得不到遏制，还会影响新一代的成长。(2)恐怖主义定义：亚国家组织或秘密团体对非战斗目标发起的有预谋的，有政治目的的，通常故意影响视听的暴力行为。要素：政治性、暴力性、不可预测性、象征性主要恐怖活动：① 爆炸；② 绑架、劫持人质；③ 暗杀；④ 劫持飞机⑤ 写恐怖信或打恐怖电话；⑥ 网络恐怖活动。恐怖组织：① 民族主义恐怖组织② 极端宗教恐怖组织如：伊斯兰原教旨主义恐怖组织③ 极左翼恐怖组织如：意大利的红色旅，德国的红军派，日本的赤军④ 极右翼恐怖组织如欧洲的光头联盟⑤ 黑社会恐怖组织如：意大利的黑手党，美国的三 K 党，卡利贩毒集团 偏差性社会问题：一般指偏离或违反一定社会行为规范造成的社会问题。(1)毒品问题定义：是指鸦片、海洛因、甲基苯丙胺（冰毒）、吗啡、大麻、可卡因以及国家规定管制的其他能够使人形成瘾癖的麻醉药品和精神药品。危害：① 危害身体健康；② 破坏家庭和睦；③ 败坏社会风气；④ 腐蚀政权组织；⑤ 妨碍社会主义经济建设和国防建设。(2)家庭暴力概念：（联合国在《清除对妇女暴力宣言》）指在家庭内发生的身心方面和性方面的暴力行为，包括殴打、家庭中对女童的性虐待、强奸配偶和其他有害于妇女的传统习俗、非配偶的暴力行为和与剥削有关的暴力行为。（婚姻法）行为人以殴打、捆绑、残害强行限制人身自由或者其他手段，给家庭成员造成一定伤害后果的行为。新特点：① 家庭施暴者涉及各个阶层② 夫妻互殴现象增多③ 家庭暴力的攻击性增强，后果严重。 自然性社会问题：自然灾害问题，指一种人类无法控制的自然力量造成的问题。特征：潜在性/突发性/有限性。不能称为灾害的是：海底地震/深海暗流/无人荒岛的沉降/北极圈内的风暴等。 第三节 社会问题的防治 实质：在党和政府的领导下，调动社会上的一切积极因素，组织相关部门，分工协作，运用政治、经济、文化、教育、法律、科学技术和行政等多种手段，对潜在或显露的社会问题进行科学分析，采取相应的对策、避免、减少社会问题的发生或使社会问题得以缓解和解决的过程。又称社会问题的综合治理。 内涵 意义：① 做好社会问题的防治，可有效地维护社会秩序与社会稳定，增强社会和民众的安全感② 可避免和减少社会问题给社会造成的损失，包括直接的和间接的损失，物质和精神的损失③ 可以保障社会主义现代化大业④ 可以促进社会主义精神文明建设⑤ 可以改善、提高有关机构的应对能力和效率。 理论依据：① 社会问题作为一种社会现象如同其他事物一样是可以认识的② 人类社会积聚了大量社会问题防治的经验和理论，为制定社会问题防治的战略和策略提供了科学依据③ 世界和各国内部管理体制存在的抑制社会问题的机制，为社会问题的防治提供了物质基础④ 在全球化进程中国际合作进一步加强，为社会问题的预防提供了国际条件。 战略思想：① 全球性思想② 全局性思想③ 长期性思想 战略措施：① 解放和发展生产力② 改革上层建筑和意识形态③ 发展科学技术④ 建立社会预警系统⑤ 发挥舆论监督作用。 第十四章 社会变迁第一节 什么是社会变迁 社会变迁：是个人与社会的关系基本形态的变异。 内容：① 社会关系的基本制度，既社会行为基本规范体系。② 社会关系的基本结构，包括组织结构、阶级结构、职业结构③ 社会关系的基本面貌，即人们的生活方式与行为方式。 特点：① 必然性；② 前进性；③ 非直线性；④ 全面性 基本类型：(1)按照社会变迁的发展方向，分为：社会进化和社会倒退进化过程的特征：长期性、缓慢性、渐进性、局部性(2)按照社会变迁的性质与特点，分为：社会改革与社会革命社会改革：使人们有意识的规划并在较短时间内实现的社会局部调整或全面改良的过程。社会革命:是一种急剧的、对整个社会进行根本改造的社会变迁形式,其目的是为了根本变革社会制度,改变生产关系(3)按照社会变迁的规模，分为：整体变迁和局部变迁(4)按照变迁的人为参与和控制程度，分为：自发变迁和有计划变迁 原因：① 根本原因，是社会生产力的增长以及生产力与生产关系的矛盾运动。② 社会物质需要和利益冲突③ 科学技术在现代社会也是导致社会变迁的一个重要因素④ 文化的发展与传播⑤ 意识形态的改变⑥ 人口状况的改变⑦ 外敌侵入、环境破坏、自然灾害等因素，也可能引起社会变迁。 有计划的社会变迁：实质上就是对社会运行过程进行干预，对社会系统施加定向影响。 社会发展计划：是对社会发展总的方向、大目标、主要步骤与重大措施的设想。 第二节 社会现代化 概念：是社会变迁上的跃进，是有计划的社会变迁,是以经济发展为中心，涉及政治、法律、社会结构、心理、文化各个领域的全面性发展过程。 主要内容：① 工业化，② 城市化，③ 民主化，④ 管理科层化，⑤ 社会结构分化，⑥ 人的现代化，⑦ 生活方式的世俗化。 特征：① 现代化是一项革命进程② 是一项长期的全球化进程③ 是一项复杂的系统工程④ 不是“全盘欧化”或“全盘西化”的过程。 社会现代化理论：① 帕森斯的模式变项；② 信息社会论；③ 后工业社会论；④ 风险社会论 中国社会现代化的特点：① 四项基本原则是社会主义现代化的基本前提② 社会主义现代化是物质文明和精神文明的协调发展③ 坚持对外开放，走自力更生、艰苦奋斗的社会主义现代化道路。 第三节 全球化 含义：一方面，全球化概念具有空间性内涵，指在全球范围内展现的涉及政治、经济、文化、社会等各个领域的客观历史进程和趋势。另一方面，全球化也蕴涵着世界共同体的各个国家、社会彼此之间的交往和交换关系的进一步加强以及依存性、关联性程度的不断深化。 特征：① 全球化是一个客观的历史进程② 全球化是一个多维度的过程③ 全球化是世界各国的共同性与差异性相统一的客观要求④ 全球化过程是一个不断出现矛盾和冲突的过程。 四个发展阶段：萌芽阶段、开始阶段、起飞阶段、增强阶段。 主要表现：① 以跨国公司为主导的经济全球化② 交通与通讯的全球化③ 信息全球化④ 政治的多极化⑤ 文化全球化。 问题：人口爆炸、资源和能源枯竭、生态恶化、艾滋病泛滥、贩毒、战乱等。 发展趋势两种观点:① 以道德为基础公开反对全球化将导致乌托邦的到来② 认为技术和经济的变革可带来积极的后果。全球化已经是不可逆转的事实全球未来的方向掌握在我们这些普通的世界居民手中，取决于我们选择的道德立场和奋斗目标。 中国改革开放以来的成就:① 经济上,我国经济同国际市场逐渐接轨,进出口贸易在整个经济中的比重不断上升,外资在投资与经济增长中的作用不断扩大② 政治上中国建立了民主政治体制,加强了与西方各国的接触融洽了曾经因冷战而冻结的关系,可以更广泛地参与国际事务,称为多极中的一极③ 文化上,思想解放运动为全球先进思想文化的引入创造了条件,促进了全球文化同中国文化交流与融合的机遇. 目前面临的挑战:① 在经济全球化过程中，西方发达资本主义国家居支配地位，而发展中国家则处于外围和边缘的地位② 政治方面，由于我国是社会主义国家，经济的高速增长动摇了西方霸权的地位，引起它们的恐慌③ 随着中国对全球化参与程度的加深，中国的文化建设受到了两方面的挑战：一是西方意识形态对马克思主义指导地位的挑战,二是西方一些腐朽文化对中国传统文化的冲击④ 国家安全方面,目前还存在着霸权主义、强权政治等影响世界和平的因素，我们所面临的国际安全环境并不乐观。 应对策略：① 必须明确中国在全球化进程中的位置，以此为制定全球战略的前提。② 要不断解放思想、深化改革、发展自己。③ 增强综合国力以确保国家安全。","link":"/2021/01/11/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/%E7%A4%BE%E4%BC%9A%E5%AD%A6/%E7%A4%BE%E4%BC%9A%E5%AD%A6%E6%A6%82%E8%AE%BA/"},{"title":"00316西方政治制度","text":"[这里是文章说明] 导言 【记忆】简述政治制度的含义及其主要形式？一、政治制度的含义：政治制度指的是一个国家的整体政治统治形式。政治制度实际上包括了政体、国家结构、政府制度和政治体制的所有内容。 二、政治制度的形式有很多方面，主要有政体、政府制度、国家结构、政治体制等。(1) 政体指的是一个国家的统治阶段如何组织自己的政权，即政权组织形式。(2) 政府制度主要是指一个国家行政机关的制度，主要内容包括国家行政机关的组织形式以及它在整个国家机关中的地位和与其他机关的关系。(3) 国家结构指的是国家的各个部分是如何整合而成其为一个国家的，即国家的整合形式，是一个国家的纵向权力机构和权力分配关系。(4) 政治体制指的是国家机构的具体设置和具体形式、运作的具体方式、具体程序和具体环节。 【记忆】简述研究西方政治制度的意义及历史唯物主义对于研究西方政治制度的指导意义？一、研究西方政治制度的意义包括：(1) 了解和认识西方国家的政治制度，有助于我们分清中国政治制度与西方政治制度的根本区别，理解这种区别之所以产生的历史背景、社会环境和国情条件。(2) 了解和认识西方国家的政治制度，是我们面向世界、学习外国的需要。(3) 了解和认识西方国家的政治制度，有助于我们更准确地把握西方各国的内政外交及其走向，分析其内外政策的形成根源和制定过程，分析国际关系的发展趋向，从而更透彻地理解中国的外交战略和政策、政略。(4)了解和认识西方国家的政治制度，有助于完善我们的知识结构。 二、历史唯物主义对于研究西方政治制度的指导意义包括：(1) 历史唯物主义的方法是指导比较政治研究的根本方法。(2) 历史唯物主义认为上层建筑必须适合社会经济基础，一定的上层建筑是一产生于一定的经济基础并与之相适应的。(3) 历史唯物主义告诉人们不应停留在孤立地、静止地描述某一种政治制度，而是要说明它为什么是那样的原因。(4) 我们在历史唯物主义的知道下研究政治制度，就应该看到，影响各国政治制度的因素是多方面的，所有这些因素综合起来就是一个国家的国情。 如何理解一国政治制度与该国国情的关系 一个国家的政治制度与该国国情的关系应这样理解：(1) 把政治制度放在一个国家的国情中来认识，就应避免简单地用好与坏来对某个国家的政治制度做出评判，脱离一个国家的社会制度和国情简单地评判该国的政治制度，者显然是不科学的。(2) 任何一种政治制度，都职能存在于一定的时间和空间，都不是永恒的，不可能超越时空而存在，都不会是抽象的、绝对的好或坏，而只能是相对地适合或者不遁合某个国家在某一历史阶段上的经济关系和基本国情。(3) 适合或者基本适合，就是有利于这个国家的稳定和发展，如果不适合就要改革，拒绝改革就可能崩溃。(4) 既然任何政治制度都是一个国家所特有的，都要适合这个国家的国情，那么适合这个国家的政治制度，却不可能适合其他国家。任何一个国家都需要建立本国特有的、适合本国国情的政治制度。 【记忆】简述系统分析的含义 (1) 系统分析是把系统论、信息论等现代科学的方法引进政治学研究而产生的一种分析方法。(2) 运用系统分析方法研究政治制度，首先把政府看作是一个有机整体，这个有机内部的各个部分相互联系、相互影响、相互制约，构成了一个系统。(3) 政治系统又与其他系统如社会系统、经济系统、心理系统、文化系统、生物系统等相互作用，构成了更大的系统。(4) 系统分析对政治制度研究的重要意义在于把政治制度放在一定的环境中来认识，有助于揭示政治制度与其他系统的关系。拥有梦想只是一种智力，实现梦想才是一种能力。(5) 倡导将系统分析方法引进政治学的美国政治学家戴维·伊斯顿认为，政治系统是“由环境包围着的”，这个系统在环境的影响下产生并反转过来影响环境 第一章 西方政治制度的历史变迁 【识记】简述城邦、城邦的社会结构及城邦政治制度的多样性 一、城邦：西方政治制度的摇篮。城邦是人类进入文明社会后建立的一种小型的城市国家，即以一个单独的城市为中心和周围乡村组成的城市国家。 二、城邦的社会结构。城邦的整个人口划分为具有不同政治地位和法律地位的三个主要阶段：奴隶、外邦人和公民。 三、城邦政治制度的多样性：(1) 政体形式的含义：政体形式是指“全城邦居民由以分配政治权利的体系”，“为城邦一切政治组织的依据”，政体“确定最高统治机构和政权的安排”。 (2) 古代希腊出现过的多样性政体：① 君主政体是指城邦最高统治权掌握在君主一个人手中，即所谓伊人统治。② 贵族政体是指一种由少数贤人掌握城邦最高统治权的政体形式。③ 民主政体是指城邦国家中全体公民享有平等的权利，共同行使决定城邦公共事务和城邦管理的一种政体形式。 【记忆】简述雅典民主制的形成和发展答：雅典民主制指在古希腊城邦雅典实行的民主政治制度。雅典民主制的形成经历了一个漫长的过程。雅典民主制的形成与发展的内容包括：一、梭伦改革，奠定了雅典民主制的基础，其目标是建立一种能使双方共容共存的制度，其宗旨是对平民来说，“自由不可太多，强迫也不应过分”。梭伦改革的具体内容包括三个方面：(1)经济改革(2)社会结构改革(3)政治改革 二、克里斯梯尼改革，使贵族寡头势力一阕不振，宣告了氏族社会的终结和国家的成熟，标志着雅典民主制的最终胜利。 (1) 在社会结构上，他以地域组织取代血缘组织作为城邦的行政单位，取消了原来的四个氏族部落，把全雅典划分成10个地域性部落，打乱了旧的部落，消弱了贵族后裔的势力。 (2) 建立“陶片放逐法”制度。该制度规定公民大会有权通过投票决定放逐被认为是危害国家的分子 (3) 在政治制度上进行了一系列改革，将梭伦时的议事会的规模扩大为500人，负责为公民大会准备决议，并执行公民大会的决议。 简述雅典民主制的主要内容及特征 一、雅典民主制的主要内容有：(1) 公民大会雅典城邦的最高权力机关，每个年满20岁的雅典公民都有资格参加。 (2) 议事会梭伦和克里斯梯尼建立的议事会是雅典最重要的统治机构。 (3) 陪审法庭雅典的陪审法庭是整个城邦民主制度的拱顶石，它以全体公民的名义行使权力，不仅是雅典城邦的最高审判机关，而且可以对各级官吏行使检察权。 (4) 十将军委员会。雅典城邦的最高军事机构，但在经常会发生战争的情况下，十将军的作用和权力会进一步加强。 二、雅典民主制的特征有：(1) 直接民主雅典城邦民主制是一种直接民主，它通过各种制度安排让所有的公民有机会直接但与城邦事务的管理，其基本形式就是创立了所有成年公民都能自由参加的公民大会作为城邦最高权力机关。 (2) 抽签选官在雅典的民主制度中，抽签的办法呗广泛地用于选择公职人员，为了抽签方便还发明了抽签机。 (3) 轮番为治“轮番为治” 是在一定范围内轮流担任某种官职，无论对任职者来说从政是好事还是坏事，必须按年或按其他规定的时期，其他轮流的程序交替执政。 简述雅典城邦民主制的意义与困境？ 一、雅典的城邦民主制，不仅增大大地促进了雅典经济的发展，对雅典国家的发展起着重要的作用，而且对于后世拥有梦想只是一种智力，实现梦想才是一种能力。特别是西方政治发展和政治制度的型塑产生了深远的影响。 (1) 主权在民原则雅典的城邦民主制体现了自由平等的公民的主权，为后世民主政治理论提供了一个主权在民的原型。 (2) 法治原则在古希腊的政治思想中，已经有了区分宪法与法律的观念，宪法是城邦的最高法律准则，宪法是城邦政治组织的依据。 二、雅典城邦民主制作为历史上存在的一种制度，不可避免地有其历史的局限和制度的局限，主要表现在以下几个方面：(1) 雅典城邦民主制是建立在奴隶制基础上的，是雅典城邦自由公民的民主制度，就其城邦人口总数而言，仍是少数人的民主。(2) 在雅典居民的生活中，存在私人生活与公共生活的尖锐冲突。(3) 在雅典城邦民主政治制度下，在强调多数人裁定的时候没有相应地保护少数人的权利，这很容易导致多数暴政。(4) 雅典城邦民主制的制度设计中大量采用了直接民主、抽签选举等形式，其目的是为了实现人民的统治。 简述古罗马国家的形成和发展？ (1)王政时代古罗马的王政时代类似与古希腊的英雄时代（荷马时代），是罗马从氏族社会向国家过渡的时期。 (2) 共和时代公元前509年，王政时代结束，罗马国家的发展进入了共和国时代。罗马共和国主要是指古罗马在公元前509年到公元前27年之间的政体。土地问题成为平民与贵族斗争的中心内容。与土地相关的是债务问题。(3) 帝国时代罗马帝国一般被分为前期帝国（前27-192）和后期帝国（193-476）两个阶段。 简述古罗马国家政治制度的内容 一、王政时代的政治制度的内容有：(1) 库里亚大会罗马的人民大会，由全体氏族成年男子参加，按库里亚分组议事，在通过决议时30个库里亚各有一票表决权。(2)长老会议由300个氏族族长组成，相当于库里亚大会的预决机构，有权预先讨论向库里亚大会提出的重大问题。(3) 王（勒克斯）王主要是军事首长，身兼最高祭司和审理某些案件的审判长。 二、共和国的政治制度的内容有：(1) 人民大会罗马共和国时代的最高国家权力机关，包括森杜里亚大会和特里布大会两种形式。(2)元老院罗马共和国时期最为重要的机构，由王政时代的长老会议发展而成，控制着罗马共和国的最高权力。(3) 行政官员包括执政官、独裁官、行政官、监察官和保民官等。 三、帝国时代的政治制度的内容有：1、罗马帝国的三种统治体制：(1) 元首体制(2) 四帝共治体制(3) 君士坦丁体制 2、行省制度行省制度是古罗马国家为统治征服地区而建立的一种管理制度。 简述古罗马共和时代各种高级官吏的特点 共和时代的高级官吏都具有这样几个共同的特点：(1) 除独裁官等特殊职位外，所有的官吏都是经人民选举出来的。 (2) 这些官吏都是没有报酬的。 (3) 他们的任职都有一定的期限。 (4) 他们之间所作的决定必须一致通过，即使有一人成员反对也会使事情停顿下来。 (5) 除独裁官、监察官和保民官外，所有的官吏都要对任职期间的行为负责。 【重点】简述中世纪封建制度的形成？ 一、进入中世纪：(1) 在西欧的历史分期上，中世纪是指公元476年西罗马帝国灭亡到16世纪近代国家产生这整整1000年的历史时期。 (2) 罗马帝国崩溃的根本原因时罗马帝国以生存的古代奴隶制度陷入严重危机而不能自拔，而直接原因则是日耳曼蛮族的大规模入侵。 二、封建制度的形成：拥有梦想只是一种智力，实现梦想才是一种能力。中世纪盛行的主要经济制度和政治制度是封建制度。 (1) 作为一种经济制度的封建制度主要是指封建土地占有制度，中世纪的西欧广泛存在的是封建采邑制。 (2) 封建采邑制主要有三个基本要素，即采邑、领主与封臣。 【记忆】简述中世纪封建制度对于近代西方政治制度的影响 中世纪封建制度对于近代西方政治制度的影响包括： 一、中世纪孕育了现代宪政主义：(1) 封建契约精神促进了现代西方契约政治的形成和发展。 (2) 封建制度的多元权力并存促进了现代有限政府的规念和制度。 (3) 封建等级会议孕育了现代会议。 二、自治城市的政治实践对西方立宪制度的影响。 城市市民自主的政治活动创造了一整套新的政治、行政与司法制度体系，尤其是城市市民选举产生的代表制机构时常通过颁布法规这样重大的发明来进行“管理”，几乎可以称得上最早的宪法试验。 简述资产阶级的三次思想解放运动 (1) 文艺复兴是指 13 世纪末在意大利各城市兴起，以后扩展到西欧国家，于 16 世纪在欧洲盛行的一场思想文化运动。文艺复兴的核心思想是人文主义。人文主义的基本精神是强调人的价值；人的尊严和人的价值，张扬人的个性，鼓励人的创造能力和肯定人的世俗幸福。 (2) 宗教改革是由马丁-路德及其后的加尔文发动的一场反对罗马教廷、提倡个人直接与上帝交流、不需教会作为中介的改革运功。 (3) 启蒙运动通常是指发生在 17-18 世纪的西欧的一场反封建专制、反教会的思想解放运动。11. 1787 年宪法确立的美国政治制度的基本框架和主要原则有哪些？1787年宪法奠定了美国政治制度的法律基础，确立了美国政治制度的基本框架和主要原则：一、分权和制约与平衡原则。二、联邦制原则。三、权力有限的政府。四、司法审查原则。 【记忆】简述《独立宣言》与《人权宣言》的意义 一、《独立宣言》的意义包括：(1) 谴责了英国队殖民地人民实行的殖民政策，宣告脱离英国而独立。 (2) 它在人类历史上第一次以政治纲领的形式提出了人人生而平等、人具有不可剥夺的生命、自由和追求幸福的权利。 (3) 政府必须经人民的同意而组成，应为人民幸福和保障人民权利而存在，人民有权起来革命以推翻不履行职责的政府政治原则。 二、《人权宣言》是指导法国大革命和政治制度创建的纲领性文件，也是世界近代史上最有影响的政治文件之一。 1、《人权宣言》采用 18 世纪的启蒙学说和自然权利理论，宣布自由、财产、安全和反抗压迫是天赋不可剥夺的人权。 2、肯定了言论、信仰、著作和出版自由。 3、阐明了司法、行政、立法三权分立，法律面前人人平等，私有财产神圣不可侵犯等原则。 【重点】简述治理型政治与统治型政治的区别 一、治理型政治：(1) 治理是一个多个主体间的管理活动。 (2) 治理还是一个互动的过程。 (3) 多元共治还意味着社会自主管理。 二、统治型政治：(1) 国家是处理公共事务的唯一的权力主体。 (2) 统治型政治意味着政府作为社会的公共权力机关，运用合法的政治权威，通过发号施令，制定政策和实施政策，拥有梦想只是一种智力，实现梦想才是一种能力。对社会公共事务实行单一向度的管理。 (3) 统治型政治意味着国家以维护社会公共秩序和公共利益为名合法地垄断公共权力，并垄断对社会公共事务的管理。 第二章 西方政治制度的基本原则 简述主权在民原则的含义及其在西方各国的确立 一、主权在民的含义：主权在民原则，又称人民主权原则，它源于资产阶级启蒙思想家率先倡导的“主权在民”学说。根据这一学说，国家被看做是由人民根据自由意志缔结契约的产物，国家的最高权力应属于人民，而不属于君主。无论是国王还是政府，其权力都是人民授予的。 二、主权在民原则在西方各国的确立：(1) 最早把主权在民原则写进宪法而确定下来的是法国。 (2) 1689 年通过的《权利法案》和 1701 年通过的《王位继承法》是两个重要的宪法性文件，由此确立了英国的基本宪政。 【记忆】简述政治合法性的含义、意义及其与人民主权的关系 一、政治合法性又叫政府合法性、政权合法性，是指某个政权或政府的统治获得社会成员的服从和忠诚的问题。 二、政治合法性的意义具体表现在以下两个方面： (1) 政治合法性关系到公共权力的顺利行使。 (2) 政治合法性有助于减少统治和管理成本。 三、人民主权与政治合法性的关系是： (1) 从理论上讲，卢梭的人民主权理论主要是为了解决政治生活中的服从问题，其本身就是一种论证政治合法性的理论。 (2) 从实践上看，建立在人民主权原则基础上的民主政治制度是一种最具有政治合法性的政治制度。 【记忆】简述代议制的含义及被西方各国采用的原因 一、代议制指人民并不直接行使管理国家的权力，而是通过选举代表组成代议机关来行使国家权力。 二、代议制在英国产生后，很快就传到了西方各国并被普通接受和采用的原因有： (1) 资本主义的商品经济要求实行民主制。 (2) 现代国家无论是领土还是人口都达到了相当大的规模。 【记忆】西方国家代议制度通行的具体原则有哪些代议制在西方国家政治制度的实行中遵循的具体原则主要有以下几条： (1) 人民通过代议机关行使国家主权。 (2) 人民通过选举代表组成代议机关。 (3) 代议机关必须遵循严肃的议事规则。 (4) 少数服从多数与保护少数原则。 (5) 代议民主并不排斥直接民主。 【记忆】简述法治的内涵法治是相对于“人治”的一种治理国家的理论、原则与方法。 其基本含义是：以法律为国家和公民的活动的基本准则，任何国家机关、社会团体和公民个人包括国家的最高领导人在内，都必须毫无例外地遵守法律，依照法律的规定活动，法律面前人人平等，无论谁违法犯罪都要受到法律的同样制裁。 法治具有以下几个方面的内涵： 一、法治与自由19 世纪英国著名法学家戴雪在其《宪法精义》中指出了法治的三个特征：(1) 法治意味着正常的法律具有绝对的至高无上的地位，它与专制权力的影响相对立，并且排斥专制的存在、特权的存在仍至政府自由裁量权的存在。拥有梦想只是一种智力，实现梦想才是一种能力。 (2) 法治意味着法律面前的平等，或者说意味着所有阶层平等地服从由普通法院实施的国家通法 (3) 法治可以被当做表达一个事实的公式，即宪法的法律，属于宪法法典组成部分的法规，在由法院加以界定并实施时，它们不是个人权利的来源而是个人权利的结果。 二、法治与自然法 (1) 法治概念的第二个涵义在于是否承认高于制定法的自然法的存在。 (2) 所谓自然法，中世纪后期荷兰政治思想家格劳秀斯认为是“正确理性所下的命令，它按照其是否符合理性，指出一种行为本身具有道德根据或道义上的必然性”。 (3) 自然法的主要内容就是人是生而具有生命、自由和财产的权利，这些权利被称为自然权利，即依据自然法所享有的权利。 【记忆】简述法治与宪法、宪法与宪政的主要内容 一、法治与宪法：1、在现代国家的法律体系中，宪法居于最高的统领地位。宪法是国家的最高的法律，被称为根本大法或基本法。西方各国宪法一般分为成文宪法和不成文宪法两种类型。 (1) 成文宪法是指将国家基本组织、人民权利义务以一套法律文书形式表达的宪法。美国 1787 年宪法是世界上第一部成文宪法。 (2) 不成文宪法是指没有专门的统一的宪法典，而是由带有宪法性质的各种历史文件即各种宪章，含有宪法内容的议会制定法、法院判例以及各种宪法惯例组成的。不成文宪法典型国家是英国。 2、宪法作为国家的最高法律，与国家立法机关制定的一般法律既有所不同，具有其特殊属性，又具有与一般法律本质上的一致性。 (1) 宪法除了规定国家的根本制度、国家生活的基本原则外，还规定国家政权机关组织和确认公民基本权利和义务。 (2) 宪法仍然是法，在本质上同普通法律一致。“宪法首先是法，其次才能是更高的法或基本法或根本大法”。 二、宪政可以理解为宪法政治：(1) 在实践层面，宪政就是依宪法建立政治制度，开展政治活动。 (2) 在制度层面，宪政主要是指称一种近代以来形成的政治制度，这种政治制度以宪法为标志、以人民主权为合法性基础、以代议制民主为行使权力的方式，实现了权力的分立与制衡、确立了司法审查制度等一套制度结构。 (3) 在西方宪政制度的运行中，法治是一个重要因素，可以说，宪政制度中洋溢着法治主义的精神。在宪政制度中，宪法处于至高无上的地位，谁也不能违反宪法。 【记忆】简述法治原则的主要内容 法治原则的主要内容包括： 一、法律必须是普遍的和公开的。 法律的普通性含有两个内容： (1)法律的适用不是针对某些特定的人群，而是所有的人和一系列相同的事物，这意味着不能选择性地立法和执法。 (2)法律的规范是具有普遍意义的规范，它们都是不因时间、地点而变化的永恒法则。 法律的公开性就是一切法律都必须公布于众，因为法律旨在为所有人提供一般性的行为准则，国家有义务公布法律，公民有权了解国家所制定的法律。 二、法治的最终目的是维护人的公民权利和政治权利。维护人的公民权利和政治权利，不仅是法治的目的也是法治的价值所在。近代宪政制度的根本问题就是如何调节政治权力与公民权利之间的冲突问题。 三、法律面前人人平等。 (1) 公民不分性别、职业、种族、信仰、文化程度等均享有选举权与被选举权，享有公民投票权。 (2) 随着奴隶制度和种族歧视政策的废除，少数民族和有色人种开始享有同白种人同等的政治权利，同等的劳动权、教育权、休息权、社会保障权，也可以平等地参与竞争性政府的公职，担任公共机构的职位和职务。 (3) 包括总统在内的任何政府官员，反触犯法律皆绳之以法，任何人都没有法外特权。 (4) 最重要的是司法平等，即普遍公民与政府官员的利益受到同样的法律保护，并同等地依法治罪。 四、司法必须独立。 司法独立是指司法权由司法机关依法独立行使，任何机关、团体和个人不得加以干涉。 1、法官独立审判案件，不受任何干预；他们在生理、判决刑事、民事、行政案件时，只依据法律，不受其他因素影响。 拥有梦想只是一种智力，实现梦想才是一种能力。 2、司法机关组织系统独立。司法独立必然要求司法部门与立法部门、行政部门在权限上分立，在机制上制衡。 3、为保证法官独立审判，制定相应法律条款以保护法官地位和权力不受侵犯。 简述分权与制衡的基本含义与波里比阿的分权理论？一、分权与制衡的基本含义：分权与制衡的基本含义就是把国家权力分为立法、行政与司法三种权力，由三个不同的机构来掌握和行使，行使这三种权力的机构既相互牵制，相互协调。分权制衡原则来源于近代西方政治思想家提出并加以系统阐释的分权学说。 二、古希腊历史学家波里比阿曾在其所著的《罗马史》一书中考察了古罗马国家的政治制度： (1) 论述了古罗马帝国兴盛的原因。他认为罗马实行了执政官、元老院和公民大会三者并存的混合政体。 (2) 这种政治体制的优点在于国家的三种权力可以相互帮助、相互牵制。 (3) 波里比阿进一步得出了权力过于易于导致政府腐败的结论。 简述分权制衡原则的概念与包容？一、分权与制衡的概念：分权与制衡是指国家的立法、行政和司法权力各自分立而又相互牵制和协调。 二、这一原则包括两个方面的内容： (1) 权力的分立是指政府的权力主要是立法权、行政权和司法权应该分开来交给不同的政府机构。 (2) 制约与平衡是指使三种权力混合起来，让政府的三个部门相互限制。 简述法治原则的主要内容 法治原则的主要内容有：(1) 法律必须是普遍的和公开的。 (2) 法治的最终目的是维护人的公民权利和政治权利。 (3) 法律面前人人平等。 (4) 司法必须独立。 简述人权理论的发展与人权的主要内容 人权作为西方政治制度的基本原则，在不同时期有不同的内容。有些西方人权学者提出了“三代人权”的发展说。 第一代人权形成于美、法两国革命时期，其目的在于保护公民自由免遭国家专横行为之害。这些权利相当于人权公约之呢过的公民和政治权利，并被说成是消极的权利，因为它们要求国家权力受到限制。 第二代人权形成于俄国革命时期并受到西方“福利国家”概念的影响，它们基本上属于人权公约中所称的经济、社会和文化权利。由于它们要求国家积极采取行动，因而被称为积极的权利。 第三代人权设计人类生存条件面临的各种大问题，它们需要通过国际合作来加以解决，因而可称为“连带关系”的权利。 第三章 西方国家的选举制度 【记忆】简述选举制度的含义及其产生？ 一、选举制度的含义：选举制度是选举产生国家代表机关的组成人员及其他国家机关公职人员的制度，是由一系列关于选举的法律、法规和规则构成的整体，其具体内容包括选举的原则、程序和方法等。 二、选举制度的产生：(1) 在现代西方国家，选举是指享有政治权利的本国公民按照事先规定的程序和方法，选择和推举国家公职人员的活动，是公民政治参与的主要形式。 (2) 中世纪选举市民代表的方法为后来西方选举制度的创建积累了一定的经验，但这一时期的选举活动与近现代选举制度仍存在着本质差异。 (3) 法国大革命之后制定的 1791 年宪法中规定了选举国民会议和选举市乡政府官吏的制度。但与此同时，该宪法规定只有“积极公民”才享有选举权和被选举权。不满足条件的人是“消极公民”，不能享有选举权和被选举权。拥有梦想只是一种智力，实现梦想才是一种能力。 【记忆】简述普选权、普选制的含义及选举制度的意义 一、普选权、普选制的含义： 1、所谓普选权，是指一国的公民不论其性别、种族、出身背景、财产状况、宗教信仰、教育程度等，一律平等的选举权。 2、建立在普选权基础上的选举制度就是普选制，也就是公民普遍、平等地参加选举国家代表机关和其他公职人员的制度，是现代选举制度成熟的重要标志。 二、选举制度的意义主要表现为： (1) 选举是实现人民主权和代议制民主的主要途径。代议制民主是现代民主实现的基本形式，而选举制度则是代议制得以体现人民主权的前提。 (2) 选举是政治合法性的基本来源。在当代社会，凡是经过选民按照普遍、平等、自由、公平原则选举产生的政府，就是具有合法性的政府。 (3) 选举是民众政治参与和政治社会的重要方式。尽管民众只能通过自己所选出的代表治理国家而无法直接行使权力，但他们在选举中可以充分地表达自己的意愿，并且可以撤换他们所不满意的代表而重新组成新的政权；可以影响参与选举的政党的未来公共政策取向，从而联结了选民的行为和政府的行动。另外，选举也起着政治社会化的作用。 简述西方选举制度的原则 选举原则是指选举制度和选举过程中必须遵循的基本原理和精神，决定着一个国家选举制度的基本特征，是人们在长期的选举实践中共同认可和普遍接受的一系列价值理念。当代西方各国选举制度遵循的基本原则具有高度的同一性和相似性，包括：(1) 普遍原则(2) 平等原则(3) 自由投票原则(4) 选举公开原则 简述选民资格的要件 选民是指依照一国宪法或选举法的规定，享有选举权的公民。“选民”和“公民”是不同的概念，所有的选民都必须是公民，但并非所有的公民都能成为选民。一个国家的公民，在符合法定标准的情况下才拥有选举权，这种法定标准就是选民资格。 选民资格要件包括： 一、实质要件：1、积极要件，是指取得选举权时必备的条件，一般指具有本国国籍、一定年龄及相当的居住时间。 (1) 国籍条件 (2) 年龄限制 (3) 居住期限 2、消极要件，是指取得选举权时不容许存在的状态。 (1) 不能患有精神病或其他无法正确表达意识的疾病。(2) 不能被剥夺政治权利 二、形式要件：上述积极要件和消极要件只是作为选民必须具备的实质要件，在现实生活中，公民要实际行使选举权还需具备一种形式要件——选民登记。 简述候选人的资格要求 按照西方各国选举法规定。通常选举进入国家代议机关或行政机关的公职人员必须具备一定的条件，这种条件就是候选人资格。候选人的资格包括：(1)国籍资格(2)年龄资格(3)居住资格(4)职业资格(5)文化教育资格(6)选举保证金 简述选区划分的形式、基本原则与类型 一、根据划分选举单位的方式不同，人们可以区分出职业代表制和地域代表制两种形式。1、职业代表制是按照职业划分选举单位，如按工会、农会、商会、银行等行业或职业团体来选举代表的制度。 2、地域代表制是按地域把全国划分为若干个选区。选民们以选举单位进行投票的制度。 二、选区作为一种地理区域，在其边界内包括众多利益各异的选民，为了实现选举的公正和平等，保证选举产生的代表或议员具有广泛的代表性，西方国家一般依据人口数量划分选区，并遵循以下基本原则：(1) “一人一票”的原则(2) 根据人口的变更不断改划选区的原则(3) 按照行政区划划分选区 三、选区划分的类型：根据所选出的议员数目的不等，西方国家的选区可分为小选区和大选区。 (1) 大选区又称为多名制选区，即每个选区可选出两名以上的议员或代表。拥有梦想只是一种智力，实现梦想才是一种能力。 (2) 小选区又称为单名制选区，即每个选区只能选出一名议员或代表。 简述西方国家选区划分方式对政党的影响根据所选出的议员数目的不等，西方国家的选区可分为小选区和大选区。是采用大选区还是采用小选区，对不同政党的候选人能否当选具有重要影响：一、小选区：(1) 小选区有利于大党控制议会，减少政党的数量。(2) 小选区由于比较容易产生胜利者，因此选举过程比较简单，话费也较少。(3) 小选区也存在明显不足，这种制度下，如果参选的候选人较多，选民投票比较分散时，由得票相对最多的候选人当选就会使得大多数选民的选票被忽略，选举结果无法代表该选区大多数选民的意愿。二、大选区：1、与小选区相比，大选区有利于小党的生存和发展。2、大选区使得选民的选票能够得到最大限度的利用，能够比较准确地反映选民的意见。3、大选区也有自己固有的陷阱：(1) 选举过程比较复杂，选举费用高。(2) 由于参选政党都是提出一个候选人名单，选举结束后按名单次序分配议席，因此容易导致党内的冲突。(3) 如果在采用大选区和比例代表制，可能造成政党数目过多甚至政党林立的局面，导致政府的不稳定。 简述选举地理学的概念及表现形式 一、选举地理学的概念：由于选区划分与各个政党能否竞选获胜联系密切，因为西方各党经常利用政治权力人为地违背人口比例或自然界限，使选区划分对本党有利，这种方法被称为“选举地理学”。 二、选举地理学在现实生活中的表现形式主要有如下几种：(1) 将本党占有较大势力的小片区域连在一起，形成一个选区，使本党有可能在该选区获胜。(2) 将不支持本党的选民分散到各个选区，使他们在各个选区都不可能形成多数，从而有助于本党在各选区获得相对多数的选票。(3) 将不支持本党的选民统统划入一个或少数几个选区，本党候选人虽然可能在这些选区落败，却保了重点，得以在其他选区获得较大的胜利。 【记忆】选举制度的基本方式有哪些 直接选举和间接选举是选举制度在其发展的历史过程中出现的两种不同的基本方式。(1) 直接选举是指代表机关的代表或其他公职人员由选民按选区直接投票选举产生。(2) 间接选举即代表机关的代表或其他公职人员不是由选民直接选举产生，而是由选民选出的一个选举团体选举产生，通常是先由选民选出一个由一定人数的选举人或代表组成的团体，然后再由这个团体选举某些代表或某个公职人员。 【记忆】简述竞争选机构的成员、竞选资金与竞选方式 一、竞选机构主要包括以下成员：(1) 由选举咨询专家组成的竞选班子。 (2) 由候选人的亲信、学者和实业家组成的政策顾问班子。 (3) 由志愿人员组成的秘书班子。 (4) 由党的各级骨干分子和志愿人员组成的竞选组织网。 二、竞选资金是指竞选者个人或通过向支持他的政党和利益集团筹措而筹集的用于竞选开支的经费。竞选资金主要来自于以下几个方面：(1) 个人捐款 (2) 社会团体的捐助 (3) 政党募集 (4) 候选人本人及其家族资产 (5) 政府资助 三、竞选方式包括：(1) 竞选旅行与演说(2) 充分利用传统谋体进行宣传(3) 网络竞选(4) 民意测验 简述多对投票轮次的限制及多数代表制对政党格局的影响拥有梦想只是一种智力，实现梦想才是一种能力。 一、在多轮次的投票中，为了加快投票进程、减少投票成本，各国通常会采取一些方法加以限制，概括起来有以下几种：1、淘汰制。这是比较常见的方法，淘汰的具体方法又有两种：(1) 在第一轮投票中所获选票未能达到规定比例的竞选人或政党不再参加第二轮投票。 (2) 末位淘汰制，如英国保守党的领袖选举即采取这种办法，按照选举规则，如有多名候选人竞选，先要经过保守党下院议员多轮投票，每轮投票后淘汰得票最低的候选人，直接最后剩下两名候选人再由保守党在全国的党员投票选出。 2、集中制。即兑许各个竞选政党在第二轮投票中结盟，使它们所获选票集中起来，从而减少竞争者的数目，这样就会出现为选举获胜而组织起来的政党联盟。 3、转让选择投票：(1) 一般是在第二轮或第三轮投票中，要求选民在其投出的选票上表明自己的第二选择。 (2) 还有一种由候选人选择转让。 二、多数代表制对政党格局的影响包括：(1) 多数代表制的最大特色在于它将选民的多样性偏好简化成了多数和少数两种相互竞争的偏好，从而使得选民能够比较容易做出自己的选择。(2) 与比例代表制相比，多数代表制下的候选人直接与选民见面和对话，从而增加了候选人个人与选民接触、便于认识和了解的机会。(3) 在实行多数代表制的国家，由于小党难以获得多数票而上台执政，因此通常形成比较稳定的两党或多党两翼联盟竞争的模式。 【记忆】简述选举监督的主体与内容 选举监督是相关主体依法对选举参与者的行为是否公正合法而进行的审查活动， 其目的在于防止违法与舞弊行为对选举活动的破坏。 一、选举监督的主体选举监督的主体包括选举组织机构、专门的选举监督机构、选民和社会组织、大众传媒等。设置专门机构对选举进行监督的典型是法国。根据 1958 年宪法规定，宪法委员会对总统选举进行监督，裁决选举诉讼，公布投票结果。其具体的监督工作是：(1) 在事前，接受所有与选举有关的咨询。 (2) 成立监督选举的特别委员会。 (3) 负责登记各政党推荐的总统人选，并对候选人的资格和品行进行审查，对候选人资格的合法性进行审查。 二、选举监督的内容包括：1、对竞争资金监督。 2、对竞争行为的监督。 3、对选民行为和选举工作人员行为的监督。 【记忆】简述对竞选资金的控制方式 对竞选资金的控制方式包括：一、规范竞选资金来源和确定捐款限额：(1) 西方各国一般鼓励竞选经费的多元化，鼓励小额捐款，明确立法禁止接受一些对民主选举制度不利的捐款，以避免候选人被财大气粗的公司或利益集团捐款人控制。 (2) 在美国的选举活动中，竞选资金有“硬钱”和“软钱”之分。 二、公布竞选费用。通常在选举前，参加竞选的个人或政党应向相关机构提交一份财务报告，内容包括收入总数，捐款者姓名、地址和捐款数额，支出总额、时间、用途及对象。 三、规定竞选资金的最高额度。当今西方国家大多规定了竞选资金的最后限额，符合限额者一般会给予相应的政府资助，超过限额则会受到一定方式的处罚。 四、实行政府资助制度。目前西方大部分国家都实行竞选资金的政府资助制度，其目的仍是减少和消弱大垄断财团对竞选活动的影响。 简述选举诉讼的含义、分类及其与选举监督的联系与区别？ 拥有梦想只是一种智力，实现梦想才是一种能力。 一、选举诉讼的含义：选举诉讼是指解决因选举而发生的各种纠纷的法律方式的总称，它伴随着选举纠纷而存在，选举纠纷是选举诉讼存在的意义和前提。 二、选举诉讼的分类：在各个阶段涉及引起争议的选举诉讼大致可分为以下三种情况(1) 选举人资格诉讼(2) 选举效力诉讼(3) 当选诉讼 三、选举诉讼与选举监督密切联系而又有所不同：1、选举监督与选举诉讼前后连贯。就同一纠纷而言，一般闲经选举监督加以解决，解决无效时则可以提起选举诉讼； 两者相辅相成，共同推进选举的制度化与合法性。 2、选举诉讼与选举监督之间又有着明显的区别：(1) 就效力而言，选举诉讼所具有的强制力高于选举监督。 (2) 从形式而言，选举监督侧重事前及事中的制止及纠正，以期收到阻止的作用，是一种主动的审查；而选举诉讼则坚持“不告不理”的司法准则，非以法律规定的有关人员或机关提起诉讼，主管机关不得受理，因此，其对选举中违法行为的纠正及制裁是被动与事后的。 (3) 从时序上看，通常各国的选举法上都规定了先监督后审理原则，在时间上即有先后之别。 简述选举诉讼的管辖机关与管辖模式 一、西方国家选举诉讼的管辖机关包括：(1) 代议机关 (2) 普通法院 (3) 宪法委员会或宪法法院 (4) 选举委员会或选举法院等专设机关 二、选举诉讼以解决选举全过程中的纠纷为主要目的，根据选举纠纷发生的阶段不同和层面不同，确定管辖机关时也会有所不同，由此西方各国都形成了一种复合型管辖模式，即由多个机关对选举诉讼进行管辖。 1、从选举纠纷发生的阶段来看：(1) 发生在选举进行过程中的诉讼，世界各国一般都由普通法院管辖，少数设有行政法院的国家由行政法院管辖。 (2) 而发生在选举结果宣布后的诉讼，涉及当选者的合法性，管辖权较为复杂，一般由代议机关、普通法院、宪法法院或宪法员会、选举法院或委员会管辖。 2、从选举纠纷发生的层面来看，地方选举与全国选举中发生的纠纷由不同机关管辖。 (1) 在地方选举中，选举人资格诉讼基本上由地方选举管理机构处理，或向司法机关提起诉讼；选举效力诉讼和当选效力诉讼，大都由司法机关管辖，或由国家特定机关处理。 (2) 而在全国选举中出现的争议与诉讼，则由代议机关、普通法院、宪法法院或委员会等管辖。 第四章 西方国家的政党与利益集团 简述政党的概念及其基本特征一、政党的概念：马克思主义认为：现代政党是阶级和阶级斗争发展到一定历史阶段的产物，是一定阶级、阶层或集团的活动分子，基于共同的意志，为了共同的利益，采取共同的行动，以期取得或维持政权，或影响国家机器的运作而建立起来的政治组织。 二、政党的基本特征有：(1) 政党具有鲜明的阶级性。政党一般是由该阶级、阶层和社会集团中最积极、最活跃的分子组成的，是阶级的核心、精华。 (2) 政党拥有明确的政治纲领。政党的政治纲领是根据其所代表阶级、阶层的利益而制定的奋斗目标和行动路线，这是由政党所代表的阶级、阶层、集团的特点和历史使命所决定的，它集中体现了该阶级或阶层的利益和需要。 (3) 政党都有明确的政治目标。这是政党区别与社会政治组织和其他政治团体的最重要的特征。政党的政治目标是为了夺取或维持政权。以实现自己的纲领，为本阶级或阶层的利益服务。 (4) 政党有相应的组织系统和领导机构。要发挥政党的作用，就必须要建立自己的组织系统和领导机构，以此将全党的力量集中起来共同行动，实现政党的奋斗目标。 (5) 政党有一定的纪律约束。现代政党都有一套成文的或不成文的党内纪律，以约束和控制党内成员的行动。 简述现代政党的起源及其产生的形式与历史条件拥有梦想只是一种智力，实现梦想才是一种能力。 一、现代政党的产生：现代意义上的政党最早是在欧美资本主义国家里产生的，是近代资本主义社会的产物，它经历了一个长期的演讲过程，伴随着议会制度和选举制度的发展而逐步完善，并称为西方国家的整个政治制度和国家机器正常运转的重要保证。 二、现代政党产生的两种形式包括：(1) 议会内起源的政党，政党是由议会中的不同派别发展成的。 (2) 议会外起源的政党，一些资本主义国家议会制度建立后，资产阶级的不同派别集团为了争夺议会席位和对政府控制而建立了政党，然后通过精选进入议会，掌握政权。 三、政党是近代西方国家的经济、政治和思想发展到一定阶段的结果：(1) 就经济因素而言，政党是西方国家从自给自足的农业经济发展到工业经济的产物。 (2) 就政治因素而言，政党是西方国家代议民主制发展的结果。 (3) 就思想因素而言，政党是西方国家民主政治思想发展的现实体现。 【记忆】简述西方政党的发展阶段西方政党的发展大致经过了三个阶段：(1) 公开排斥时期。这时期，无论是当权者还是社会思想大家都把政党看成是政治生活中的“有害之物”。 (2) ，默认时期。这时的西方国家和社会，虽然还有人对政党厌恶和打击，但是在实践中，政党随着民主政治的发展不断发展壮大。 (3) 法律承认时期。19 世纪末，随着政党在国家政治生活中作用急剧增长，西方国家开始在法律上承认政党的存在和活动，在选举法中规定了政党参选的提名程序。 西方国家主要政党的分类有哪些根据不同的分类标准对西方各国的政党做如下分析：(1) 以政党的阶级属性和阶级基础为标准，政党可分为资产阶级政党和无产阶级政党。 (2) 根据政党与现行国家体制的关系及其在体制中作用，可以将政党划分体制内政党和体制外政党。 (3) 以政党的政治主张和政治倾向为划分标准，可以将政党划分为左翼、右翼和中间政党。 (4) 从政党的意识形态的角度划分，还可以将政党划分为资本主义政党、社会民主主义政党、共产主义政党和民族主义政党四种类型。 (5) 以政党与政权的关系为标准，可以分为执政党、反对党（或在野党）两类。 (6) 以政党的活动范围为标准，政党为地方党、民族党、国家党三种类型。 (7) 以政党的组织体制为标准，政党分为组织严密型政党和组织松散型政党。 简述西方国家的政党政治含义及特点一、政党政治的含义：政党政治指的是西方国家的政党围绕国家政权所进行的活动。 1、狭义的政党政治就是政党执掌政权的活动。 2、广义的政党政治是指政党为取得、运用和维护国家政权所进行的活动。 二、西方国家的政党政治表现出以下几个方面的特点：(1) 表达和聚合本阶级的利益要求和政治意识。 (2) 政党政治是发生在不同政党之间的政治，表现为不同政党在争夺对国家权力控制的过程中形成的关系。 (3) 以夺取和执掌政权为目标。 (4) 政党政治反映了社会政治，反映了社会各阶级、各阶层及其他各种社会力量之间的斗争、联合和博弈。 (5) 政党政治主导国家政治。 简述西方国家政党政治运行的主要环节及意义一、政党政治运行的主要环节包括：(1) 组建政党组织、宣传政党纲领和主张。 (2) 拉拢选民，角逐竞选。 (3) 政党竞争，轮流执政。拥有梦想只是一种智力，实现梦想才是一种能力。 (4) 通过政党分肥，掌握国家机关重要职位，并以此为基础，进而控制国家行政机关的运作工程。 二、政党政治运行的意义包括：(1) 现代政党政治促进了政治与社会的双向交流。 (2) 现代政府执政保证了西方国家政府机构之间的有机联系。 (3) 现代政府执政有利于加强西方国家政治制度自我调整。 西方国家政党政治的组织机构有哪些政党政治的组织机构包括： (1) 领袖。政党领袖是政党的领导人或领导集团，但西方国家政党大部分是个人领袖。 (2) 党的中央机构。西方政党的中央机构时全国性的组织领导机关，名称各异。 (3) 党的地方分支和基层组织。为了进行广泛的社会动员，参加选举，联系公众，了解民情民意，西方政党都建立地方分支机构和基础党组织。 (4) 党的辅助机构和外围组织。为了研究社会问题，扩大社会影响，联系和吸引公众，也建立和发展一些辅助机构和外围组织，这些机构和组织不是党的正式组成部分，但却为政党服务和工作。 (5) 党组织之间的关系。西方国家的政党的组织关系比较复杂，有的政党组织比较严密，有的政党比较松散。 (6) 党内派别。西方国家的政党都允许党内派别的存在和派别之间的公开竞争，这些党内派别在政党的政策制定和候选人的提名等重大政治活动中发挥重要作用。 【记忆】简述政党制度的概念及类型 一、政党制度的概念：政党制度是指国家法律规定的，或者在实际政治生活中形成的有关政党的地位和作用、政党的相互关系以及政党掌握、参与和影响国家政权的体制和运行机制。 二、政党制度的类型：1、两党制是指资产阶级国家中两个政党轮流执政的一种政党制度。两党制的主要有以下特征：(1) 在一个资产阶级国家有两个或两个以上的政党，但具有实力赢得执政地位的政党只有两个。 (2) 两大政党在涉及国家的基本制度的问题上意见一致，都忠于国家，承认并维护国家的基本制度。 (3) 两大政党势均力敌，长期轮流执掌政权。 (4) 两党通过选举，取得会议多数或总统选举胜利。 (5) 其他政党基本上没有执政的可能，但对政治有一定的影响，在某种特定条件下可能对两大政党形成一定的压力。 2、多党制是指在资产阶级国家中存在三个或者更多的政党争夺执政地位的政党制度。 3、西方国家的一党制，是资本主义国家中只有一个政党存在并执掌政权、并且禁止其他政党存在的政党制度，这就是法西斯的政党制度。 【记忆】简述英、美、法、日、意五国政党制度的特点 一、英国的两党制：(1) 两党活动主要是围绕议会下院展开。 (2) 两大党都实行集中制，以纪律约束本党议员在议会中的行动。 二、美国的两党制： (1) 由于美国实行总统制，美国两大政党之间的竞争也主要表现在总统选举上，掌握了总统职位的党就是执政党。 (2) 美国的两党组织纪律松散，都没有严格的纪律约束本党的党员，只是在总统选举时体现出一定程度的统一。 三、法国的多党制：法西兰第五共和国以来，法国政党经过多次分化、改组，逐渐形成了有法国特色的多党制：多个政党、两大联盟对峙的政治格局，即多党两极竞争。 四、意大利的多党制：意大利政坛上比较活跃的有意大利力量党和由它改组而成的自由人民党，由左翼民主党等政党改组成立的民主党，以及北方联盟、基督教民主联盟、意大利价值党等，形成了由某个大党轮流联合一个或几个中小政党组阁的局面。 五、日本的多党制：“五五体制”其特点是“一党独大”，即存在多个政党，但只有一个政党处于绝对优势地位，长期单独执政，同时该党内部派争激烈，轮流坐庄。拥有梦想只是一种智力，实现梦想才是一种能力。 简述利益集团的概念及其产生背景和社会条件 一、利益集团的概念：利益集团是具有共同的政治、经济、社会目标的社会成员，基于共同利益要求而组成的社会团体，其目的是维护自身的利益。 二、利益集团的产生背景和社会条件有：(1) 从经济方面看，西方工业革命以后，社会化的大生产促成了社会巨大变革。 (2) 从政治方面看，20 世纪，特别是二战以后，西方各国政府的权力和职能范围扩大了。 简述利益集团影响政治的方式及其对西方政治与政治制度带来的影响和变化 一、利益集团影响政治的方式主要有三种：(1) 直接向政府表达政治诉求，提出利益要求，直接影响政策，如寻找代理人、议会游说、通过法院来对政策进行挑战等。 (2) 通过政党影响政策。 (3) 通过大众传媒影响政策。 二、利益集团对西方资本主义国家的内政外交都有着重大影响，无论是在福利政策、经济政策还是在军事工业方面，利益集团的活动余地都非常大。 (1) 利益集团政治改变和丰富了西方传统政治决策的机制。 (2) 利益集团政治扩展与深化了西方公民的政治参与。 (3) 利益集团政治成为一种新的权力制约机制。 第五章 西方国家的议会制度 简述法国和英国的等级代表会议的区别？法国和英国的等级代表会议的区别有： 1、历史上英国的等级代表会议：大会议。 (1) 御前会议主要包括三部分人：世俗贵族、教会贵族和王室官员集团。 (2) 13 世纪中叶，大会议机构发生了一个重要变化，即大会议里先后增加了乡村骑士和城市市民代表。 2、历史上法国的等级代表会议： 三级会议。 (1) 和英国相似，法国几乎在同时出现了封建等级会议，这就是法国历史上的“三级会议”。 (2) 法国的等级划分比英国更为严格，高级僧侣称第一等级，世俗贵族称第二等级，城市市民称第三等级。 简述西方会议在发展中的阶段性特点西方国家的议会产生以后，它的发展过程大致经过了三个时期： 一、西方议会的建立时期，这个时期的议会政治具有以下基本特征： (1) 以夺取政治权力、巩固资产阶级革命成果为主要政治任务。 (2) 重申启蒙时代所确立的资产阶级国家基本政治原则，包括人民民主权、自由、平等、法治和人权等。 (3) 会议不断加强权力，完善其内部的各项制度和规则。 二、西方会议的功能调整时期，这个时期的调整主要有以下特征： (1) 议会的最高权力机关的地方受到挑战，其传统的立法功能有所消弱。 (2) 随着西方各国行政权力的膨胀，议会的政治生活和政治决策的中心地位不复存在。 (3) 与立法功能的退化相对照，议会的其他功能却日显突出。 【记忆】简述议员的任职资格、产生方式及任期一、议员的任职资格主要包括以下几个方面： (1) 国籍资格 (2) 居住资格 (3) 职业资格 (4) 保证金制度 (5) 提名限制 (6) 其他资格要求 二、西方国家议员的产生方式有三种：拥有梦想只是一种智力，实现梦想才是一种能力。 (1) 选举产生议员。 (2) 国家元首或国家官员任命产生议员。 (3) 因特殊身份成为议员。 三、西方各国议员的任期长短不一致，一般来说： (1) 一院制的议员大都任期 4-6 年 (2) 两院制国家上院议员的任期长于下院议员，而且实行定期部分改选。 简述议员的职权、特权与义务 一、议员的职权指议员作为议会成员所享有的与其职务活动有关的权利，包括：(1) 提案权。议员最基本的职权，是指议员向议会提出议案或建议，由议会进行审议的权利。 (2) 质询权。即议员有权对内阁提出质问的权利，是内阁制国家议会议员代表选民监督政府的重要手段。 (3) 讨论和表决权。议员最日常的一项职务，指议员对议题和议案加以讨论，并对其结果表示赞成、反对或弃权的态度。 二、为保证议员的身份和执行职务，各国宪法都明文规定了议员的各项特权。包括：(1) 人身保护权 (2) 言论免责权 (3) 生活保障权 三、议员的义务包括：(1) 为实现选民委托，对选民负责，议员在议会中必须勤奋工作，忠于职守。 (2) 为了维持议会的正常秩序，保证议会的权威性和效率，议员必须出席议会会议，参加投票表决，同时必须遵守会议纪律，遵守议事规则，否则要受到纪律的惩处。 (3) 议员兼职时要求保证立法、行政、司法部门之间的分权，以保证分权与制衡宪法原则的贯彻，最常见的是议员当选后不得兼任司法、行政以及其他法律规定的职务。 西方国家议员的主要政治活动有哪些西方国家议员的主要政治活动包括：(1) 西方国家议员的最重要的政治活动，就是参加和应付定期举行的选举，这既是他们生存的手段，也是他们实现个人政治抱负的机会。 (2) 议员的另一个重要政治活动就是履职，即形式法律赋予他们的各项权利和权力。 (3) 议员作为选民的代表，要反映和表达民意。 (4) 西方国家的议员们也经常参加其他社会活动，包括一些礼仪上的公务活动。 【记忆】简述西方议会体制及其主张学者的观点 一、西方国家的议会，在体制上一般采用两种形式：即一院制和两院制，有时也采用多院制。 1、一院制是指议会只拥有一个议院，并由它行使议会全部职权的制度。 2、两院制是指议会设有两个议院，并由两个议院共同形式议会职权的制度。 3、议会发展史上也曾出现过多院制，但都时间不长，也只限于个别国家。 二、长期以来，西方政治学家和法学家对议会实行两院制还是一院制争论不休。 1、主张一院制的学者认为：(1) 一院制机构单一，程序简便，利于行使权力。 (2) 一院制能提高立法效率，有利于适应社会的发展和变革。 (3) 一院制便于对行政的监督。 2、主张两院制的学者认为：(1) 两院制可以使议会代表不同的利益，有利于调整资产阶级内部各利益集团的关系。 (2) 两院制便于相互制衡，防止立法草率。 (3) 两院制有利于平衡、缓和议会和行政机关的关系，健全国家权力体制。 【记忆】简述议会领导机构的类型议会的领导机构有个人和集体两种类型。 一、个人类型的领导机构就是议长领导制。 二、集体型的议会领导机构可分为：拥有梦想只是一种智力，实现梦想才是一种能力。 1、议会主席团。一般由议长、副议长和议会秘书组成，其职能主要是主持日常立法工作、议决会议活动的重要事项以及领导议院办公厅的行政工作，制定议院预算等。 2、议长会议。一般由议长、副议长或会议工作委员会的主席、议会党团领袖组成，主要负责审查议会的工作，安排议会的议事日程，或协助议长领导议会工作。 【记忆】简述议会的委员会的作用及类型 一、议会中委员会的作用包括：(1) 对立法建议的详细审议。 (2) 对财政预算和决算的讨论和修订。 (3) 在许多国家，委员会还具有监督政府，调查公共事端的作用。 二、议会委员会的类型有：(1) 常设委员会 (2) 临时委员会 (3) 联合委员会 【记忆】简述会议党团的概念、类型及职责 一、议会党团的概念：议会党团是指为协调政党或政治倾向相同的议员在议会中行动的一种组织，一般由同一政党或者虽然不是同一政党，但政治倾向相同或相近的议员组成，并以该党名称命名或以几个政党的名字联合命名。 二、按照组成的政党数量不同，议会党团大致可分为三种类型：(1) 由一个政党单独组成本党的议会党团。 (2) 由两个以上的政党的议员组成一个议会党团。 (3) 跨国议会党团。 三、议会党团的职责主要包括：(1) 协调本党议员或联盟党团议员在议会的行动和确定对其他党派提出的议案的态度。 (2) 组织指挥本议会党团在议会及各种委员会中的活动。 (3) 选择会议中的盟友和对手。 (4) 观察、研究议会内政治的发展形势，并提出相应的对策。 (5) 参与、争夺对议会事务的领导，提名议会中需要选举产生的职位的本党候选人。 【记忆】简述立法权、预算权的含义及其内容 一、立法权即制定、修改和废除法律的权力，是西方国家议会的基本权力。也是会议最重要的权力，是会议发挥立法功能的主要原因。立法权包括立法创议权、通过法案权和修正权。具体有如下：(1) 立法创议权主要是指提出立法议案的权力。 (2) 通过法案权主要是指经过讨论或者辩论，然后通过法定程序表决，赞成议案或否决议案的权力。 (3) 修正权即对已生效实施的法律提出修改的权力。 二、预算权即同意预算权，是西方国家议会的传统权力，直接从等级会议的同意国王征税权发展而来，也是议会制约政府的重要手段。 西方国家议会的预算权包括： 1、预算监督。议会通过预算监督权不仅能在财政上直接约束政府，而且能间接制约政府其他方面的施政措施。 2、财税监督权。是议会最原始的权力，是议会控制、监督政府最有效的手段，常常被称为“钱袋子权力”。 【记忆】简述监督权的概念及议会对政府监督的方式 一、监督权的概念：监督权是议会监督政府的职权，即议会对政府的行政行为进行监督的权力。 二、议会对政府的监督有以下几种方式：(1) 质询。依据质询权，议员可以向政府官员就其施政方针、行政措施及其他事项进行质询，并要求政府予以答复，政府对议员的质询必须作出答复，从而起到对政府的督促和纠正作用。 (2) 听证。听证具有一定的询问和调查性质，在美英日等国家，听证具有一定的强制性，被要求作证的组织或人员如拒绝出席，司法部可以“藐视议会”的罪名对其提出刑事诉讼。 (3) 调查。为了加强立法和监督政府的工作，各国宪法和法律都予以议会组织专门机构政府的行为和政策涉及问题进拥有梦想只是一种智力，实现梦想才是一种能力。行调查的权力。 (4) 倒阁。倒阁权被认为是议会监督政府最重要、最有效、最具威胁性的一种手段。 (5) 弹劾。弹劾权是议会最后的杀手锏，弹劾权的形式是资产阶级控制官吏，笼络人心的一种手段，也是统治阶级内部争权夺利、派系倾扎的一种反映。 【记忆】简述立法程序的阶段 立法程序主要包括：1、提出法案：一部分法案的草图是某些人根据社会的需要或为自己的利益构想出来的，这种思路要整理成文，通过法定的形式提交给议会。有权提出法案的主体主要有：(1) 议员 (2) 政府 (3) 议会中的委员会 (4) 国家元首 (5) 一定数量的公民 2、审议法案。 3、通过法案。 4、公布法律。 简述英美两国的三读程序一、英国下议院审议法案的三读程序通常为：(1) 一读宣布法案的名称或者要点，如通过法案便列入议事日程，并规定议院大会讨论和辩论的日期。 (2) 二读宣读法案全文，并就法案的一般内容和原则展开讨论，这个阶段最为重要，要进行针锋相对的辩论。 (3) 三读法案经二读分别送达有关的委员会审议，委员会只能根据议院的辩论意见进行修正，但无权搁置议案，然后即提交全院大会进行三读并付诸表决。 二、美国的三读程序与英国有所不同，法案审议的程序是： (1) 一读。在全院宣读法案的名称和法案的要点，表决若通过则列入该院议程，法案即由议长提交相关的常设委员会审议。 (2) 委员会的审议。这是议案成败的关键阶段，委员会对送来的法案拥有近乎绝对的处置权，可以决定是使其快速通过，或是搁置拖延，或是大幅度修改，或是干脆否决。 (3) 二读。议长接到委员会的审议报告后，要向全院大会宣读经委员会修订的法案全文，这就是二读。二读如获通过，即将该议案编入相应的议程。 (4) 全院辩论。议院按照议事规则，在议长或议长指定的议员主持下展开发言辩论。 (5) 修正案表决。辩论结束后，先对法案的各种修正案进行表决。 (6) 三读。在对法案进行最盾的文字修改后向全院大会宣读，并进行最后表决。 【记忆】简述法案表决通过中公民复决的主要方式公民复决是特殊的立法程序，是在立法机关之外进行的表决通过，主要有以下几种方式：(1) 强制性或必要的公民复决。某些特定的法案经议会通过后，必须交公民复决。 (2) 有条件的强制性公民复决。某些由议会通过的法案，是否要交公民复决，由国家元首、政府或一定数目的议员来决定。 (3) 请求性的公民复决。对于议员通过的议案，可根据一定数量的议员或公民的请求而提交全民公决。 第六章 西方国家的中央政府制度 【记忆】简述国家元首的概念、特征及其与政府首脑的区别 一、国家元首的概念：在现代民主国家，国家元首是国家的象征，是主权国家对内和对外的最高代表。 二、国家元首的特征包括：(1) 对外代表国家。在国际活动中，由国家元首充当国家的最高代表，他是国家主权和独立的化身，并在对外交中代表整个国家。拥有梦想只是一种智力，实现梦想才是一种能力。 (2) 对内象征最高国家权力。国家元首不仅意指某个个人，而且是国家机构的重要构成，是一定政权组织的“头脑” (3) 依照宪法行使元首职权。在西方国家，对元首可以行使什么职权、应该怎样行使职权以及与其他国家机关的关系如何等，都有明确的宪法规定。 三、国家元首和政府首脑是两个不同的概念，区别如下：(1) 国家元首是专门行使代表和象征国家的职能的机构。 (2) 政府首脑则是领导和指挥中央政府工作的行政首长。 (3) 两者在国家机关体系中的地位是不同的。在有的国家，这两个职务是由一个对象来担任，在其他一些国家，是有两个不同的对象来担任的。 【记忆】简述国家元首的职权及特殊礼遇 一、西方国家的国家元首拥有的职权概括有： (1) 公布法律权 (2) 发布命令权 (3) 外交权 (4) 统帅军队权 (5) 任免权 (6) 赦免权 (7) 荣典权 二、国家元首的特殊礼遇主要包括以下三方面： (1) 外交特权和尊荣。在对外交往中，元首的崇高地位会受到国际社会的普遍尊重，而其体现的是对元首所代表的国家及其人民和政府的尊重。 (2) 不受司法管辖的特权。国家元首不仅出访时免受他国刑事、民事司法管辖，在国内也不受普通法院的管辖。 (3) 享有物质生活的特殊待遇。西方国家的元首都享有非常优厚的、远高于普通人生活水平的物质待遇，这既是出于维护其尊贵形象的考虑，也是为了确保其能全身心地投入工作而不必为生活烦扰。 【记忆】政府、内阁的含义分别是什么一、通常来说，政府是包括纵向不同政府层级和横向不同政府部门在内的一个庞大而精密的组织体系。 １、从纵向来看，政府可以根据其管辖范围的不同而划分为不同的层级。 ２、从横向来看，政府又根据职能领域的不同而设置了不同的机构。 二、内阁的含义：内阁是以政府首脑为中心，由他（她）和周围重要政府官员所组成的、讨论和决定国家重大政策的机构，它是中央政府的核心部分。 ４．【记忆】简述内阁制、总统制的含义及特点一、内阁制又称责任内阁制或者议会内阁制，指由内阁来总揽国家行政权力并对议会负责、举行责任政府原则的政府体制。 内阁制的特点主要表现以下方面：(1) 多党或多数党联盟执政(2) 国家元首为虚位元首与政府首脑掌握行政实权(3) 内阁向议会负连带的政治责任 二、总统制指由总统兼任国家元首和政治首脑并直接领导、组织国家政务管理的政府体制。总统制主要特点:(1) 总统既是国家元首又是政府首脑(2) 总统和国会权力分立且地位平等(3) 内阁成员均接受总统的领导和监督(4) 总统所属政党不一定是国会多数党 【记忆】简述半总统制、委员会制的含义及其特点 一、半总统制：又称半总统半会议制，是一种兼有内阁制特点和总统制特点的混合型政府体制。它的特点主要包括：(1) 总统是国家元首和国家权力的中心(2) 总统与总理分享行政权(3) 总理及内阁要对议会负责，也要向总统负责 二、委员会制是指政府最高权力由一个合议机构来掌握的政府体制，当今世界只有瑞士联邦共和国采用这种特殊的政府体制。主要特点包括：(1) 联邦委员会为最高行政机关 (2) 联邦委员会实行合议制 (3) 联邦委员会为集体元首 (4) 联邦委员会是议会的执行机构 【记忆】简述政府的产生极其组成原则 一、政府如何产生，主要取决于政府体制。 1、在实行总统的国家，兼任国家元首和政府首脑的总统一般由选民直接或间接选出。 2、在实行内阁制的国家，由议会（一般是议会下议院）选出作为政府首脑，随即首脑组阁，提出政府成员名单经国家拥有梦想只是一种智力，实现梦想才是一种能力。元首任命后政府即宣告成立。 3、在实行半总统制的法国，由于总统和总理分享行政，由总统任命总理，然后根据总理提名任命政府成员，组成政府。 二、西方国家在组成政府时，通常都规定了一些必出遵守的原则，主要包括：(1) 相容原则或不相容原则。 (2) 禁止兼职和从事营业性活动的原则。 (3) 现役军人不得入阁原则。 【记忆】简述政府机构的设置 政府机构是行使国家行政权力和履行政府职能的机关，负责执行立法机关制定的法律和决定，管理国家内政、外交、军事等方面的行政事务。 一、政府各职能部门：职能部门是政府内设的最基本的部门，代表政府行使某一方面的职权并具体执行议会和政府所制定的政策。 二、政府首脑的办事机构：政府首脑的办事机构原是为协助政府首脑处理日常事务、加强与各职能部门及社会组织间的联系和磋商而成立的。 三、政府直属机构西方国家的中央政府除设有政府各职能部门外，还没有管理特定公共事务的若干政府直属司、局、委员会等机构，这些就是政府直属机构。与其他国家相比，美国联邦政府直属的独立机构数量既多职能又广。美国的独立机构大致可以分为两类：(1) 政府公司是较新形式的官僚组织，它是政府机构，管理的却是准商业性质的公共事业。 (2) 独立管理机构则是在某个经济领域负责制定和执行有关规则，以维护公共利益的政府机构。 【记忆】政府决策的主体和机构有哪些政府决策的和主体和机构包括： (1) 政府首脑。政府首脑是政府的最高决策者，有权决定本国内政外交的一切重大政策。 (2) 内阁会议。内阁会议的决策作用因为政府体制的不同而有大有小，但从形式上看西方各国政府的大部分政策都是经内阁开会和商讨才予以确定的，而不只是政府首脑单方决定的结果。 (3) 内阁委员会。在议会内阁制国家，随着政府需要处理的事务及其紧迫性增加，内阁委员会开始出现并发展迅速，成为内阁决策的一种重要的辅助性机构。 (4) 咨询机构。现代政府决策离不开咨询，正是众多思想库的帮助，才使政府得以获取各类有价值的专业信息和分析报告，从而为科学而理性的决策打下良好的基础。 简述政府决策过程阶段政府决策过程的阶段包括：(1) 决策创议。将某个问题提上政府议事日程，它是决策过程的首要环节，没有创议就不会有决策。 (2) 决策制定。政府围绕某个公共问题而确定决策标准并选择能有效解决问题的方案的过程，包括对问题的细致分析，及备选方案的拟定、审议和综合比较。 (3) 决策执行。将政府出台的政策付诸实施的过程，它直接决定着政策的意图能否以及在多大程度上能实现。 (4) 决策评估。要评估这一政策的成功之外以及存在的不足。决策评估要求评估者搜集有效的、可靠的信息资料，运用各种科学的评估方法，按照特定的评估标准，对决策过程进行系统地研究和分析，以作为未来实施政策调整及制定新政策的依据。 (5) 决策调整。决策制定者依据决策评估反馈的信息，结合问题和环境的变化，对政策内容和形式予以部分改变或全部改变的行为。 第七章 西方国家的地方政府制度 简述国家结构形式的概念和类型 一、国家结构形式的概念：国家机构形式是国家的整合形式，指的是国家的各个组成部分如何整合成为一个成其为国家的政治共同体。国家结构形拥有梦想只是一种智力，实现梦想才是一种能力。式具体表现为国家的整体与部分之间以及中央政权机关与地方政权机关之间相互关系的构成形式。 二、按比较公认的看法，国家结构形式分为：(1) 单一制 (2) 联邦制 【记忆】简述地方政府制度的概念及其改革的特点 一、地方政府制度的概念：地方政府制度是与中央政府制度相对而言的，它指的是有关地方政府的层级划分、组织形式、职能、机构设置等的原则、政策、法律和惯例的总和。 二、西方国家的地方政府改革呈现出这样两个特点： (1) 原来具有中央集权传统的西方国家逐步实行权力下放和地方分权，增强了地方政府的自治权力。 (2) 大多数国家都在根据本国情况对地方政府体制不间断地进行改革，使之能适应不断变化的政治、经济环境。 【记忆】简述比较中央集权单一制和地方分权单一制的区别中央集权单一制和地方分权单一制的区别有： (1) 在中央集权型单一制国家，地方政府在中央政府的严格控制下行使职权，由中央委派官员或由地方选出的官员代表中央管理地方行政事务，地方居民没有自治权，或者即使设有自治机关亦受中央政权的严格控制。 (2) 在地方分权型单一制国家，地方政府由当地居民选举产生，并在中央政府监督下依法自主处理本地区事务，中央不得不干涉地方具体事务，典型国家有英国、日本和意大利等，它们大多有久远的大方自治传统。虽然在地方分权型单一制国家中，地方政府享有较大的行政自主权，但是涉及军事、外交等全国统一性的政务仍归中央政府掌管，而且从法理上讲地方政府的一切活动也应当受制于中央。 【记忆】简述地方政府的类型地方政府类型的划分有多种方法，其中最常使用的是按地方政府的设置目的来分类和按地方政府与中央政府的关系来分类。 一、按地方政府设置目的的所作的分类：(1) 一般地域型地方政府：国家基于按地域进行管理的一般需要而设置的政府。 (2) 市镇型地方政府：国家基于市镇地区专门管理的需要而设置的政府。 (3) 民族区域地方政府：多民族国家基于解决民族的需要，而在少数民族聚居区域设置的政府。 (4) 特殊型地方政府：国家基于政治的、行政的或其他特殊需要而设置的政府。 二、按地方政府与中央政府的关系所作的分类： (1) 行政体地方政府：指地方政府的长官由中央任命产生，完全隶属于中央政府，服从其指挥并对其负责；它的权力来自中央政府的授权，本身无独立的人格，而仅以代表中央政府的资格来在当地行使这种权力；它不设有代表当地居民利益和意愿的代议机关，或者虽设立看地方咨询机关，但不拥有实际的权力。 (2) 自治体地方政府：是一定地域居民，为在其居住区域管理本地方公共事务，而依据国家法律组成的拥有一定自治权的政府。 自治体地方政府的基本特征是：国家对纯属地方的事务，不由自己人做行政长官来管理，而由当地公民选举产生的政府来管理。 简述行政体地方政府与自治体地方的优势和劣势一、行政体地方政府的优势和劣势如下：(1) 优势：确保政令统一、避免地方主义。 (2) 劣势：这种集政治统治权与行政管理权于一身的政府形式无法充分发挥地方的积极性，也不能很好地吸纳当地居民参与管理。 二、自治体地方政府的优势和劣势如下：(1) 优势：有利于推动参与式民主的发展，能更好发挥地方的创造性。 (2) 劣势：过于强调地方利益有时会导致中央政令无法顺利贯彻实施，且可能造成地方政府之间的矛盾。 【记忆】简述行政区域划分应遵循下列原则(1) 推动经济发展的原则。拥有梦想只是一种智力，实现梦想才是一种能力。 (2) 加强控制和提高管理效率的原则。 (3) 促进民族团结和发展的原则。 (4) 照顾自然条件和历史传统的原则。 (5) 保护稳定又适时调整的原则。 【记忆】简述地方政府的层级的概念及地方政府单位从层级上的分类一、地方政府的层级的概念：地方政府的层级即指地方政府单位在纵向上分为哪些层级，它是由地方政府单位的隶属关系而形成的。 二、地方政府单位从层级上通常分为三类：(1) 直接与地方居民发生关系的地方政府，称为基层政府。 (2) 直接与中央政府发生关系的地方政府，称为最高层地方政府。 (3) 介于两者之间的其他所有地方政府，称为中间层地方政府。 简述地方政府职能的概念及特点一、地方政府职能的概念：地方政府的职能是指地方政府在国家和地方事务中所起的作用或承担的责任。 二、地方政府职能的特点有：(1) 执行性。地方政府需要协助中央政府或上级政府来完成它们在本地方的事务，因此其职能中有很多内容是中央政府或上级政府基于法律和彼此协议而委托其代为完成的行政管理职能，自治体地方政府还需要严格遵守和贯彻本地方民意代表机构的决议。 (2) 服务性。地方政府的职能在一定程度上取决于本地方居民的实际需要，因此其范围虽广泛但也很明确，就是要提供本地方居民日常生存所必需的一些基础设施和公共服务。 (3) 有限性。地方政府的管辖范围不能超越其行政区域，而其职能也以纯属本地的社会事务为主要内容。 【记忆】简述西方国家地方政府职能的演变西方国家地方政府职能的演变主要体现在以下四个方面：(1) 地方政府职能总量的不断膨胀。 (2) 地方政府的管理性、服务性职能日趋重要。 (3) 地方政府职能出现“职能合并”的倾向。 (4) 地方政府服务职能的民营化潮流。 简述地方政府职能的具体内容地方政府职能的具体内容有：一、单一制国家地方政府的职能：(1) 地方政府的职能会因为中央政府是支持集权化还是倡导分权化而有变化。 (2) 中央集权型单一制国家与地方自治型单一制国家的地方政府职能会有所不同。 二、联邦制国家地方政府的职能：(1) 州政府的职能除联邦委托其代为完成的外，要么是由国家的宪法民确规定的，要么是依宪法而归其予以保留的相对稳定。 (2) 州以下地方政府的职能则取决于州法律的规定及本地方的需要，相对易变。 简述地方政府机构的发展趋势及其改革运动措施一、地方政府机构的发展趋势有：(1) 规模不断膨胀，结构日趋复杂，数量不断增多，雇员人数也日益增长。 (2) 职能分工与专业化程度不断提高，地方政府雇员的专业化、技术化程度在不断提高。 (3) 地方自治日益扩大，而且取得自治权的已不再限于城市地区，越来越多的基层乡村地域。 (4) 地方政府组织的结构和形式日益多样化，不仅表现在不同国家、不同时期地方政府机构不同，而且在同一国家的不同地区、不同层级甚至同一层级上也可能存在着多种形式的地方政府机构。拥有梦想只是一种智力，实现梦想才是一种能力。 二、地方政府的改革运动措施主要为： (1) 将职能相近或职能交叉的地方政府部门合并，以精简地方政府机构和人员。 (2) 根据一些新出现的社会问题所提出的新要求，增设新的政府机构来加以解决和处理。 (3) 注意发挥咨询、信息服务和顾问机构的作用，以提高决策的准确性。 (4) 扩大地方政府及职能部门的自主权，以更好地履行其在供给公共服务和有效管理方面的责任。 (5) 用企业管理的精神来重塑政府，强调要引入竞争机制及实现公共机构的创新。 (6) 将地方政府的公共服务职能直接提供为主转为以外包为主，以裁撤不必要的机构和提高服务品质。 【记忆】简述城市政府的概念、分类及其产生和发展一、城市政府的概念：城市政府是国家设置在城市地区以履行市政管理职能的地方政府。 二、城市政府分类：(1) 按城市规模即城市的入口规模或人口数量，可以划分为大城市的城市政府、中等城市的城市政府和小城市的城市政府。 (2) 按城市功能即城市在国家或地区中所发挥的作用，可以划分为政治中心的城市政府、文化中心的城市政府、经济中心的城市政府等。 三、城市政府的产生和发展：(1) 城市政府的产生是与城市的形成相伴的。城市化进程的加快带来了交通堵塞、垃圾污染、住宅不足等一系列特殊的城市问题或称“城市病”，从而也使城市政府的重要性日益显现。 (2) 虽然各国的城市数量不等，大小不同、行政等级也有高低，但它们在国家政治、经济、社会生活中的作用和地位却在日益上升。 【记忆】简述城市政府职能的含义及其特点一、城市政府职能的含义：城市政府职能指城市政府为实现国家意志、维护城市安全、稳定和推动城市各项事业的发展而担负的责任和职能。 二、城市政府职能具有如下特点：(1) 城市政府职能的履行所面向的人群大而密集、结构复杂且参与意识强烈。 (2) 城市政府职能的范围广泛且对专业性和技术性的要求很高。 (3) 城市政府职能更多地以直接和法制的方式履行。 简述基层政府的地位与作用 一、基层政府的地位基层政府在一国的政治行政体制中处于何种地位，很大程度上取决于国家结构形式，也与历史传统、文化观念、民族习性等有关。西方国家的基层地方自治大体可分为英美模式和法日模式两种类型。 二、基层政府的作用主要表现在： (1) 为居民直接提供各类公共服务并满足其需求。 (2) 巩固政权的基础并保障国家政治、社会秩序的稳定。 (3) 推动公民参与治理过程并促进民主政治的发展。 简述基层政府管辖规模与其职能的关系基层政府管辖规模关系到基层的活动能否充分发挥效益与效率，就基层政府管辖规模同其应承担的职能来看，可以发现三种类型：一、规模适度的基层政府能独立完成自身应承担的基本职能，政府效益得以较好发挥。 二、规模过大的基层政府难以靠一个政府来全面完成其管理任务，于是常需增设代表机构或工作机构。 三、规模过小是西方国家大多数基层政府共同的特点。 规模过小会给基层政府的行政管理工作带来困难： (1) 人口太少意味着税收也少，从而会导致政府财力不足，于是一些不要的基础设施建设和公共服务供应都可能面临资金短缺。 (2) 人口太少意味着服务的供应难以形成规模效应，服务成本将增大，从而导致基层政府的服务效率降低。拥有梦想只是一种智力，实现梦想才是一种能力。 第八章 西方国家的司法制度 简述西方国家的司法原则 一、司法独立原则：司法独立原则是西方国家司法制度的一条重要的原则。西方国家的所谓司法独立，包括三层涵义：(1) 法院、法官只能服从法律，根据法律规定的程序独立行使司法审判权，司法机关应当独立于其他权力机关。 (2) 在司法系统内部相互独立，即一个法院的审判活动不受另一个法院的干涉，即使上级法院也不能干涉下级法院的审判，只能在下级法院做出审判以后，通过上诉程序依照法律进行审理，做出更改或维持原判的判决。 (3) 法官独立，即法官只根据法律独立审判，不仅不受任何外界的包括监察官控诉的影响，而且同一法院内部也不存在上下级服从关系。 二、法律面前人人平等：法律面前人人平等意味着权利的平等，具有两个方面的涵义：(1) 对任何特权的防范。法律确认和保护公民在享有权利和承担义务上处于平等的地位，不允许任何人有超越于法律之上的特权。 (2) 在法律上宣布公民有获得“平等保护”的权利，任何公民都可以通过控诉制度请求法院排除侵害，提供保障，换句话说，就是对任何歧视的防范。 三、公平审判原则：在西方国家，公平审判历来被认为不仅是司法独立、民主、平等原则的体现，而且是这些原则的最终目的。在制度实践上，公平审判表现在以下三个方面：(1) 公正的法院。 (2) 没有程序性保障，就根本谈不上实质性公正，程序性的公正是实现实质性公正的前提。 (3) 公正的处罚。 【记忆】简述法院的特性、分类与法院体系的分类 一、法院的特性包括：(1) 被动性(2) 普遍性(3) 依法性(4) 等级性 二、法院的分类：(1) 法院按照管辖权范围和审理案件的性质可以分为民事法院和刑事法院。 (2) 普通法院和专门法院。 三、法院组织体系的分类包括：(1) 单一制法院和联邦制法院(2) 大陆法系法院和英美法系法院 简述法国与德国的法院组织一、法国普通法院系统中的民事法院和刑事法院各有适合审级：(1) 初审法院(2) 大审法院(3) 上诉法院和巡回法院(4) 最高法院 二、德国的法院组织包括：(1) 地方法院(2) 地区法院(3) 州高等法院(4) 联邦高等法院 简述英国（主要是英格兰和威尔士）的法院组织一、郡法院和治安法院：(1) 专门处理一定金额以下的民事案件(2) 速决裁判法庭，主要审理判处 6 个月以下监禁的轻微刑事案。 (3) 治安法院的法官不多数是兼任的。 二、高等法院和皇家刑事法院： (1) 高等法院审理较大的民事案件和来自郡法院民事上诉案(2) 高等法院有数十名法官，其中一人为院长。(3) 皇家刑事法院又称刑事法院或皇家法院，既受理不服治安法院判决的上诉案件，也审理有管辖权的初审刑事案件。 三、上诉法院拥有梦想只是一种智力，实现梦想才是一种能力。 四、从上诉法院到高等法院 五、苏格兰法院系统。苏格兰居民大多信仰天主教，在历史上采用罗马法，合并为英国一部分后，在法律和宗教上保持独立性，法院也自成系统。 简述美国的法院组织美国法院组织包括： 一、联邦法院组织体系：(1) 联邦地区法院(2) 联邦上诉法院(3) 最高法院(4) 专门法院 二、州法院组织体系：(1) 基层法庭(2) 地方法院(3) 州上诉法院(4) 州最高法院 简述西方各国的检察机关的组织体系的权力和职责(1) 参加刑事案件的侦查、提起公诉、出庭支持公诉(2) 监督法院的刑事审判(3) 监督判决的执行(4) 充当政府的法律顾问，为政府提供法律咨询 【记忆】司法行政机关的含义及其主要职责是什么一、司法行政机关的含义：进行司法行政管理的机关，是国家行政机关的组成部分，一般设在政府系统内，作为政府一个部门。 二、司法行政机关的主要职责是管理司法行政事务。(1) 决定法院的组织设置、编制以及调整，提供和管理法院的组织装备，管理监狱和感化设施。负责挑选和推荐司法官员的人选以及其他人事任免、考绩、晋升、奖惩等工作。 (2) 有的国家还参加司法机关的监察工作。 简述法官的产生以及法官保障制度的内容一、法官的产生：西方国家的法官，多是任命产生，少数是选举产生。二、法官保障制度的内容：(1) 法官不可更换制(2) 法官专职制(3) 法官高薪制(4) 法官退休制 简述对陪审员的资格规定及挑选陪审团成员的方法 一、陪审员的资格规定： (1) 一般都要求必须是当地有选举权的公民(2) 年龄一般在 18—65 或 21—70 岁之间(3) 身体健康，心智健全(4) 诚实公正，能阅读和书写本国法定的通用文字，没有重罪前科(5) 适合担任陪审员工作 二、挑选陪审团成员的方法主要有：(1) 抽签(2) 评选 【记忆】简述司法审查的含义及司法审查的机关和方式 一、司法审查的含义：西方国家普遍实行违宪审查制度，既由司法机关通过司法程序来审查立法和行政机关的行为否违反宪法，又称司法审查。二、西方国家行使违宪审查权的机关有另种不同的情况：(1) 普通法院审查(2) 宪法法院审查 三、西方国家进行违宪审查的方式主要有：(1) 事后审查(2) 事前审查 简述司法审查的对象和内容一、从司法审查的对象来分：(1) 审查议会通过的一切法律、法令和行政部门的一切行政法规、行政命令和规章，体现了宪法保障和权力制衡的功能，即保障立法机关和行政机关的行为与宪法相结合。(2) 就宪法性争议进行裁决，体现了宪法仲裁的功能，即依照宪法来裁决争议和分歧。 二、西方国家司法审查的主要内容包括：拥有梦想只是一种智力，实现梦想才是一种能力。(1) 国家机关之间的权限争执(2) 国家整体与部分之间、中央与地方之间以及地方与地方之间的权限争执(3) 有关宪法所保障的公民权利的案件 简述行政诉讼与行政裁判的含义和性质一、行政诉讼与行政裁判的含义：(1) 行政诉讼是指当事人对国家行政机关或其他工作人员的行政行为不服而引起的诉讼。 (2) 行政裁判是指对行政诉讼进行审理和裁决 二、由于行政裁判的“准行政”、“准司法”性质，行使行政裁判权的机构既不同于法庭，也不同于行政机关。(1) 行政裁判机构要受理行政诉讼，通过审理作出裁决，其运用权力的基本样式具有司法的基本特征。(2) 各国行政裁判的体制各不相同，但行政裁判机构都不属于法院的一部分，它们或附属于行政机关，或从属于立法机关。 简述法国行政诉讼案件的类型及法庭处理的争议一、法国政府在制定法律草案和行政管理条例时都要征询行政法院的意见，行政法院又是受理行政诉讼的终审级审判机关，兼具立法功能和司法功能。主要有以下类型：(1) 关于行政行为合法性的诉讼(2) 关于侵权行为的诉讼 二、权限争议法庭用来解决普通法院与行政法院的权限争议。法国的权限争议法庭处理的争议主要涉及以下方面：(1) 如果两个法院体系无论双方都认为自己有权审理还是都认为自己无权审理，均须由权限争议法庭做出裁决(2) 如果两大法院体系就同于一个案件作出了相互冲突的判决，可以由权限争议法庭重新审理。 简述英国的行政裁判所及 20 世纪 90 年代以来英国行政裁判制度变革的特点 一、英国的行政裁判所的特点：英国的行政裁判所都是根据议会制定的部门法律设立，由精通法律和具有行政经验的人士组成，在组织上与行政机关联系，在活动上则保持独立性。 二、20 世纪 90 年代以来英国的行政裁判制度发生了一系列重大的变革，主要有一下几点：(1) 明确地肯定了行政裁判的司法性质； (2) 在新成立的负责司法行政管理事务的司法部下设立裁判所服务局，管理所有中央裁判所行政事务； (3) 确定了两级裁判所结构； (4) 行政裁判所由法律人士和专家组成，分别授予“裁判法官”和“裁判所成员”身份，都是享有完全独立的司法权； (5) 为确保裁判所公正、独立地处理案件，成立了裁判所程序委员会，负责制定行政裁判所的基本程序规则； (6) 建立了行政司法和裁判所委员，从整体上监督整个行政司法体系，协调法院、裁判所之间的关系。 简述瑞典的议会监督专员的概念及其主要职能一、议会监督专员的概念：议会监督专员是由议会设置的专司监督法律执行和公职人员行为的监察官员，又称议会司法监督专员或议会专员。 二、根据《政府组织法》的上述规定，议会督察专员监督的范围是非常广泛的，其主要职能包括以下两个方面：(1) 检查、监督法律、法规的执行情况。监督的对象包括中央和地方政府、法院、检察官、军队、警察、监狱以及其他国家和地方机关及其公职务员。 (2) 受理公民对政府公务员的不良行政行为或因某项政府命令、决定而受到不公正待遇提起的申诉或控告。","link":"/2021/05/10/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/WesternPoliticalSystem/%E6%80%BB%E7%BB%93/"},{"title":"公共政策学","text":"《公共政策学》资料 第一章 公共政策学的学科要素 公共政策学：公共政策学是这样一门学科，它尽可能的运用科学方法研究公共政策的内容、过程与产出，探索其固有规律，形成系统性知识，并运用这种知识进行政策分析，进而通过公共权力机关将研究结果转化为政策实践。 公共政策学的学科要素有：① 研究对象 ② 概念体系 ③ 研究方法 政府组织即公共权力组织的决策行为，是公共政策学研究对象的核心和重点。 公共政策学的研究对象：(一)公共政策：作为公共政策学的研究对象的公共政策，指的是公共权力机关建立起来的包括立法、行政、司法三权在内的所有国家机构，以及一定类型的政治体制内的执政党制定和实施的政策。可以区分为三个层次：1、具体的个别政策； 2、政策群和政策链： (1)政策群：是指国家、政府和一定类型的政治体制中的执政党某一较长时间内制定和实施的内容各异但理念同源、导向相近的政策的聚合体。 (2)政策链：是指国家、政府和一定类型的政治体制中的执政党为解决同一政策问题而先后制定的在内容上具有一致性、在形态和功能上具有差别性的一系列政策。 3、政策一般：从无数项具体的个别的政策和众多的政策群、政策链中，抽象出所有的政策的共同的本质和属性。 (二) 政策系统。对政策系统的研究应予重视的四个突出问题：1、直接的政策制定系统中决策者的类别差异；2、公共政策的直接主体系统对对象系统的地位的相对性；3、公共政策的直接主体与政策支持系统的地位的相对性；4、公共政策制定系统内部的结构。有四种类型：① 线性结构 ② 职能结构 ③ 线性—参谋结构 ④ 矩阵结构 (三)政策过程：决策行为是选定目标和选取最优化方案并付诸实施的行为。决策行为是一个有一连串相互衔接的阶段、环节或程序组成的完整的政策过程；即决定做什么，做什么；政策过程是一个自始至终不断地进行选择的过程，即分析如何认定，解决问题，哪些因素对方案的实施造成影响，结果是否一致及其造成的主要原因等。 公共政策学的研究方法：(一)研究程序的设计：1、提出拟研究的政策问题2、确定假设3、收集系统资料4、资料分析5、做操作性研究6、撰写研究报告(二)政策研究的资料收集方法：1、一手资料的收集：(1)定量的一手资料常采用抽样调查的方式(2)定性的一手资料收集方法：① 无结构访谈法 ② 实地观察法 ③ 非参与观察法 ④ 参与观察法2、二手资料的收集与分析方法有：① 内容分析法 ② 二次分析法 ③ 现存统计资料分析法(三)公共政策的研究视角和路径：1、公共政策的系统分析方法——政策系统的环境分析、目标分析和结构分析；2、公共政策的矛盾分析方法3、公共政策的历史分析方法；4、公共政策的比较分析方法；5、公共政策的个案分析方法；6、公共政策的经济分析方法；7、公共政策的制度分析方法；8、公共政策的价值分析方法 公共政策学的概念体系在内部构成上区分为三个层次：核心概念；次级概念；边际概念 公共政策学的核心概念，次级概念和边际概念及其相互关系；1、核心概念：是政策分析中不可或缺的概念。反映公共政策这一动态过程的本质和运动规律的概念集；出现错误将最终导致决策失误或得出错误的研究结果；2、次级概念：是核心概念的子概念和从属性概念；它是公共政策学的研究不断深化的表现；3、边际概念：是从其他学科引进或移植过来的概念；为公共政策学提供了理论和方法论基础； 古代中国政策研究：(1)史官制度 (2)策士制度 (3)谏议制度 (4)科举制度 欧洲中世纪的中期和晚期随着城市的发展，才培养出在财政，战争，法律三大领域中拥有专门知识并向统治者提供政策建议的政策分析人才。 古代没有发展成“公共政策学”的原因：1、人们有关政府政策的知识、思想和观点大多是对政策结果所作的观察和分析，而不是对政策过程所作的观察和分析，只有当研究者能够对政策过程进行直接地或比较直接地观察和分析的情况下，才有可能产生公共政策学。2、古代有关政府政策的情况、思想和观点，通常是个人直观体验的产物，而且对政策解释往往是从权威、伦理、哲学的原则 中国古代政策思想的内容：(1)、世异则事异，事异则备变(韩非子)；管仲，商鞅(2)、以民为本，政在得民的政策原则；孟子，荀况，李世民，王夫之，唐甑(3)、惠民、养民、富民的政策传统；管仲，孔子，李俚，孟子，唐甑(4)、重农抑商的政策主张；李世民，朱熹(5)、不患寡而患不均的政策倾向；孔子，唐甑(6)、无为而治的政策构想；王弼； 我国古代两本著作：1、&lt;&lt;战国策&gt;&gt;第一部较为系统的政策研究与政策咨询的著作；2、冯梦龙&lt;&lt;智囊补&gt;&gt;，是世界最早的一本政策案例著作； 18-19 世纪，从产业革命前后到第一次世界大战前，许多学者和思想家在经济学、军事学、社会学和一般社会科学等领域做了大量的理论研究和方法论探索，奠定了理论和方法论的基础。 公共政策学诞生于 20 世纪 50 年代。 学科形成的历史条件：1、系统论、信息论、控制论的产生：奠定了公共政策学的理论和方法论基础(三论提供的思维方法的特点是系统性、动态性和最优化；它提供的基本方法是：系统的方法；信息的方法；反馈的方法；功能模拟的方法)；2、决策科学的形成：其取得的成果直接成为公共政策学的内容；西蒙的有限理性决策模型和决策过程理论、诺伊曼的博弈论(决策科学与公共政策学之间是一般与个别的关系)3、行为科学的形成和行为主义政治学的进展：是公共政策学产生的催化剂。泰勒首创科学管理理论，梅奥的霍桑实验。4、凯恩斯主义的出台和政府政策领域的扩大：使得公共政策学研究的必要性迅速增加。 公共政策学在西方国家产生的标志：勒纳和拉斯韦尔的《政策科学：视野和方法的近期发展》，公共政策学的开山之作，首次提出并界定了政策科学这一概念，被人们认做公共政策学诞生的标志。 公共政策学的创立者：拉斯韦尔 拉斯韦尔，代表性著作：&lt;&lt;政治学—谁得到什么？何时和如何得到？&gt;&gt;论文《政策方向》中六点界定：(1)它是关于民主主义的学问；以民主政治体制为前提；(2)哲学基础是逻辑实证主义；(3)对于时间和空间都极其敏感；(4)具有跨学科的特点；(5)须和政府官员共同研究；(6)以社会变迁和发展为对象，以动态模型为核心。 公共政策的两个分支：一是由拉斯韦尔倡导的行为主义，一是由西蒙创立的，自管理科学(公共管理学)领域里成长的决策科学，行为主义。公共政策是属于政治科学还是属于管理科学的争论一直没停过； 公共政策学发展的初期阶段(50 年代到 60 年代初期)：1、在政策分析的定量方法和技术方面，尤其是在系统分析，运筹学，线性规划以及成本-收益分析等方法和技术的应用上，取得了显著的成就；2、学多政治家日益重视政策科学的公共政策取向，投身公共政策学研究 20 世纪 60 年代后期，公共政策学的发展进入第二个阶段：以德洛尔为代表，对拉斯韦尔等学者倡导的行为主义方法论做了全面的批评；1、公共政策学进入第二个发展阶段的标志是德洛尔的《重新审查公共政策的制定过程》、《政策科学：概念与使用》、《政策科学构想》的出版；2、德洛尔的主要学术成就：第二代公共政策学家，其学术背景是公共管理学而不是政治学；主要学术成就：(1)分析了行为科学和管理科学在学科建设上存在的误区；(2)指出了美国政策科学进入新阶段的发展方向(3)强调公共政策学的跨学科性和实践性；3、公共政策学发展的第二阶段取得的成就(60 年代后期开始)：(1)方法论的多样化——行为主义一统天下的局面结束；其一，众多学者仍尽可能地赋予公共政策学类似自然科学那样的科学性；其二，公共选择方法论(布坎南)崭露头角；其三，博弈论(尤金.巴达克)成为公共政策分析中的一种重要方法论；其四，个案研究受到重视。(2)对政策过程研究的重点转变——重点由原来的政策制定转向政策执行、评估和终结，政策周期。(3)对政策过程中的价值因素和伦理因素的作用给予了重视。(4)公共政策比较研究开始起步 公共政策学发展的近期阶段取得的成就(20 世纪 90 年代以来)(1)课题选择的新取向——伦理取向；管理取向；政府改革取向。(2)方法论的非科学化——以主观的研究方法(研究决策者主观的思维方式或倾向的)取代客观的研究方法(寻求客观真理)。(3)公共政策学的建制化——学会、专业研究机构以及专业和课程的建立 公共政策学的引进：把公共政策学引入中国，台湾早于大陆，最早引入这门学科的是中兴大学法商学院(今台北大学)、台湾大学和政治大学。从 20 世纪 80 年代起，公共政策学还被规定为考录公务员的专业考试科目。中国台湾的公共政策学这门学科的主要贡献是对美国同行的教学和研究成果给予了及时、系统和全面的引进、吸收与综合，却显示缺乏学术上的独立思考。台湾学者的工作，对中国大陆改革开放后公共政策学的引进和发展起来相当大的作用。中国大陆是随着改革开放的深入而开始引进公共政策学的，而引进和发展这一学科的根本动机是推动党和国家领导部门的决策科学化和民主化进程。改革开放后，决策科学、管理决策学和行政决策学著作的出版和传播，为公共政策学的发展创造了良好的社会条件和教育环境。较为完整地吸纳和介绍西方国家特别是美国的公共政策学知识体系的教科书的编著和出版迟至 20 世纪 90 年代。 公共政策学中国化的进程：现实需要是推动公共政策学中国化的强大动力，第一是党政领带机关决策的需要，这一需要推动着专门的公共政策研究机构的设立；第二是高等院校教学的需要，这一需要推动着教师撰写教材和学术论著。关于公共政策研究机构，改革开放以来，体制内的公共政策研究机构越来越多，对党政领导部门的直接影响越来越大。随着不断地发展，体制外的公共政策研究组织越来越多地成立起来；关于公共政策学的教学和人才培养。 公共政策学的中国化，构建有中国特色的公共政策学学科体系，是这门从国外引进的新学科的发展方向，要在以下几个方面努力：1、强化研究者的主体意识；2、重视对政策哲学的研究；3、重视本土资源；4、重视当代中国公共决策实践，大力开展实证研究，从中抽象和构建公共政策学的概念、范畴、理论与模型。 学习公共政策学的目的(其必要性或者基本的意义)有以下几个方面：1、是为了改进政策系统，提高政策质量。公共政策的制定和执行是公共权力机关的基本活动，这种活动的出发点和归宿应当是人民群众的根本利益。但是，这一根本的价值取向只有通过科学决策和民主决策才有可能变成现实。一项好的政策的制定并取得令人满意的政策结果，单凭良好的主观愿望是远远不够的，而是需要进行科学的政策分析，并通过分析得以洞察有哪些因素影响政策制定和执行的方向，是怎样影响的，影响的深度与广度如何，在政策系统内部做出什么样的改进就可以使政策的制定和执行获得更好的结果。2、是为了教育群众理解公共政策，运用政策争取和保护自身的和公共的利益，以适当的方式向公共组织特别是公共权力组织提出政策建议。学习和研究公共政策学是对群众进行政策教育的一种基础性的、行之有效的方式。3、是为了推动社会科学和自然科学各学科的研究工作具有公共政策研究的取向。虽然推动社会科学与自然科学各学科研究的根本宗旨和动力都是认识世界和改造世界，但是通过公共政策学的学习和研究，人们才能更加自觉地认识到，公共政策是联结认识世界和改造世界这二者的至关重要的桥梁。因此，社会科学和自然科学各学科的研究工作都有必要从公共政策学这个视角去思考自身的研究工作的意义和价值。 第二章 公共政策与政策工具 公共政策：是公共权力机关经由政治过程所选择和制定的为解决公共问题、达成公共目标、以实现公共利益的方案。 公共政策的内涵： 1、公共政策是决定、决策的一种特殊形态，它具有决定、决策的一般特征； 2、公共政策是公共权力机关的基本的活动方式或活动过程，是公共权力机关的权力意志的表现； 3、公共政策是经由政治过程而进行方案的初拟、优化和择定的结果，主导这一过程的基轴是公共权力机关与公民的关系； 4、公共问题、公共目标和公共利益是公共政策的三大要素； 5、公共政策是一种权威性的价值分配方案； 6、公共政策在形式上可以是积极的，也可以是消极的。 公共政策的产生必须具备的三个初始条件或者说三个核心要素： 1、公共问题的形成； 2、公共决策机关的产生； 3、公共强制机构的出现 近代公共政策的转型或发展在四个方面的表现： 1、公共政策问题形成中的公民参与 2、现代国家和政府制度的基本理念是：主权在民； 3、公共政策领域向社会管理方面的大规模扩展； 4、以政策过程的民主化和科学化来保证政策质量 公共政策的类型划分： (一)从内容特征上划分： 公共政策的内容特征指的是具有不同的政策效力的各项公共政策构成一个统一的、相互作用的政策体系。 1、以同一政策体系中各项政策之间是否存在着涵盖与衍生关系划分： ① 元政策：② 基本政策 ③ 部门政策； (元政策，基本政策，部门政策及其相互关系：存在着涵盖与被涵盖，衍生与被衍生，统摄与被统摄的关系) 2、将同一政策体系中各项政策从时间和空间相结合的角度划分： ① 战略 ② 策略 ③ 战术 ； (相互关系：战略是全局的，策略是战略的一部分，是服从服务于战略，战术是微观的，针对一个一个的具体问题) 3、依政策的社会内容进行划分： ① 政治政策 ② 经济政策 ③ 社会政策 ④ 教育、科技、文化政策 4、其他分类方法： (1)以一项政策谋求达到的目标数量为标准划分： ① 单目标政策 ② 多目标政策； (2)以政策主体决策时有无现行规范可遵循进行划分： ① 程序性政策 ② 非程序性政策； (3)以政策是否改变客观对象为标准划分： ① 实质性政策 ② 程序性政策；(由美，安德森提出) (4)以政策效果为标准划分： ① 物质性(或实质性)政策 ② 符号性(或象征性)政策(由美，安德森提出) (5)以政策协调社会生活的方式为标准划分： ① 分配性政策 ② 调节性政策 ③ 自我调节性政策 ④ 再分配政策(由美，安德森提出) (6)由美国学者洛维为分析纽约市人事任免而做的一种类型划分： ① 分配性政策 ② 限制性政策 ③ 再分配性政策 (7)以政策的结果是双赢还是一方所得为他方所失为标准划分： ① 零和博弈政策 ② 非零和博弈政策 (8)以同一政策的始创或调整为标准划分： ① 初始政策 ② 反馈政策 (9)内容构成以政策结果的可预测性为标准划分： ① 确定型政策(如全国统考制度) ② 不确定型政策 ③ 风险型政策(建立股票市场) ④ 竞争型政策 (10)以政策主体希望的行为选择的范围为标准划分： ① 鼓励性(扩大性)政策 ② 限制性政策 (11)以政策主体是否行为为标准划分： ① 积极性政策 ② 消极性政策(改革初期对私企发展的不行动的政策) (12)以面向未来还是面向现实为标准划分： ① 能动型政策 ② 被动型政策 (二)从形式特征上划分： 公共政策的形式特征是由公共权力机关的权利划分和权利配置决定的。 现代国家的政府在横向结构上的构成由立法、行政、司法三个子系统构成； 在纵向结构上由中央(全国)政府、地方政府、基层政府三个层级构成； 公共政策在横向结构上是由立法决策、行政决策、司法决策构成的，在纵向结构上是由中央(国家)政策、地方政策、基层政策构成的. 1、依横向的形式特征进行划分： (1)立法决策：中国的人大决策和美国的国会决策。 1, 中国人大决策的主要形式： ① 宪法 ② 基本法律 ③ 其他法律 ④ 人大决定 2, 人大的四大职权： ① 立法权 ② 决定权 ③ 任免权 ④ 监督权； 3, 美国国会的权利分为： ① 立法权 ② 非立法权，立法权是美国国会的首要权利，非立法权主要是指国会对行政部门和司法部门的监督权。 (2)国家元首决策：总统制(模糊)、半总统半议会制、超级总统制这三类国家，才存在总统决策。 1,美国的总统决策通过如下途径做出： ① 他在内阁决策中的独断权 ② 总统在行政系统的末端建立起制定政策的总统直辖机构。 2,总统决策的类型： ① 总统向国会提出的国情咨文、预算咨文和经济咨文 ② 立法否决 ③ 委托立法 ④ 外交决策 ⑤ 防务政策。 (3)行政决策 —— 六种类型的政治体制中，只有美国联邦政府的行政决策与国家元首决策的界限含糊不清。 1, 中国的行政决策。 所谓行政决策，是指国家行政机关在法定的权力和职能范围内，按一定程序和方法做出的决定。 主要形式： ① 行政法规(以总理令的形式发布) ② 行政措施、决定和命令(以国务院文件形式或国务院办公厅文件的形式发布) ③ 部门规章(大都以部长令的形式发布，须报国务院备案) 2, 美国的行政决策。总统决策大多是行政决策。 行政机构分为四类： ① 内阁部 ② 独立管制机构 ③ 其他独立机构 ④ 政府公司。 3, 美国联邦行政机构的决策有以下几种： ① 对国会立法和总统决策的解释 ② 制定规章条例 ③ 行政裁决。 (4)司法决策: 1, 中国的司法决策：我国的司法机关是政策执行和政策监控的重要主体，而作为政策制定的主体，其作用不大显著的。 2, 美国的司法决策：最高法院是公共政策的直接制定者。 主要形式： ① 司法审查 ② 推翻先前的判决 ③ 司法命令。 (5)执政党政策 —— 除了中国为代表的政治体制外，其他体制中的执政党的政策，不能直接成为公共政策。 当代中国现行的政治体制是中国共产党领导的议行合一制。 1.横向结构特点： 1).全国人民代表大会是国家的最高权力机关； 中国共产党是中国政府系统的领导核心，主导着政府工程的运行； 2).党的政策转变为公共政策的形式： ① 直接形式——党的会议文件和党的领导人讲话； ② 间接形式——党的领导是政治的领导，即政治原则、政治方向、重大决策的领导和向国家政权推荐重要干部。 3).党对国家事务实行政治领导的主要方式：使党的主张通过法定程序，变为国家意志； 4).将党的政策变成国家意志的法定程序有三种类型： ① 中共中央与国家机构联名发布政策方案 ② 提出政策创议 ③ 政府决策以党的政策原则为依据。 2、`纵向形式特征`上：公共政策的类型取决于国家结构。 所谓国家结构：是国家的整体与部分，中央政权机关与地方政权机关之间的关系。 1)国家机构划分为两个基本类型： ① 单一制 ② 邦联制 2)以决策者即公共权力机关的层级或纵向结构为标准，公共政策类型可划分为： ① 中央政策(国家政策) ② 地方政策 ③ 基层政策 公共政策的基本功能： ① 管制功能 ② 引导功能 ③ 调控功能 ④ 分配功能 公共政策的本质 1、公共政策的认识论本质——理论与实践的中间环节。 政策兼具理论与实践的二重特征。 (1)政策与理论的基本关系：理论是政策的理念依据，政策是理论的具体化 (2)政策与实践的基本关系：政策是实践经验的原则化并在实践中得以完善和发展，实践须以政策为出发点并贯穿其整个过程 (3)理论是政策的理念依据或指导思想有两方面的含义： ① 理论的内容影响和决定政策的内容，理论依据的不同造成政策的基本差别； ② 理论的正确与否，决定政策的成败； (4)理论和政策同属观念形态，其存在和发展都依赖社会实践；政策只有通过实践才能实现其目标和功能； 2、公共政策的社会本质：公共性与偏好性的对立统一 现代公共政策起决定作用的规定性：公共政策是公共权力机关为了一定的目标而进行的社会资源的配置和社会价值的分配。 公共政策的基本特征： (一)政治性、权威性与强制性： 公共政策是由政治性组织制定的，是国家、政府、政党为实现其政治目的而制定的行动方案和行为准则，因此，公共政策具有鲜明的政治性； 公共政策是社会关系的调节器，公共政策的权威性是和它的政治性紧密联系在一起的； 公共政策的权威性是由它的强制性决定的。 (二)公共性与偏好性的对立统一 (三)应然与实然的统一 (四)回应性与普遍性的统一 政策工具： 指的是被设定为旨在实现一定政策目标的各种措施、策略、方法、技术、机制、行动、作为以及配置的人力、资金、设备、资源等手段。 政策工具的类型： (一)两分法：规制性工具与非规制性工具；政府部门直接提供与非政府部门提供；诱导性工具与规制性工具。 (二)三分法：法律工具、经济工具、交流工具；管制型工具、财政激励工具、信息传播工具；市场化工具、工商管理技术工具和社会化手段；自愿性工具、混合性工具、强制性工具。 (三)四分法:1、哈内孔把政策工具划分成立法、委托服务、征税、说服四类形态。2、艾尔莫尔把政策工具划分成命令性、激励性、能力构建、系统变迁四类。3、休斯认为政府干预大多采用经济手段，从经济方面把政策工具区分为供应、补贴、生产、管制四类。4、丘昌泰把政策工具分为：管制类工具、财务类工具、沟通类工具、组织类工具 (四)五分法:对中国学者影响较大的五分法：1、史耐德和英格拉姆：权威式、刺激式(包括激励、收费、制裁、强制)、能力构建式、符号和劝告式、学习式2、韦默和维宁：市场自由化、使用财政补贴和课税的方式改变诱因；建立规章制度；经由市场机制提供物资；提供保险与社会保障。 (五)七分法:林德和彼得斯：命令条款、财政补助、管制、课税、劝告、权威、契约 (六)八分法:胡德使用信息、财政、权威、组织四种基本资源达到监督社会和改变行为两项目的。奥哈雷从政府介入方式和政府行动的类别两个维度进行划分。 政策工具类型学研究的根本意义，在于政策工具的分类是政策工具的比较、选择和配置的基础。 既有分类的缺陷：大多只适用于公共权力机关的经济和社会政策所使用的政策工具；既有的政策工具分类过于重视正式、有形的、静态的政策工具，而看轻甚至无视非正式的、无形的、动态的政策工具；有些分类过于简括或过于庞杂，有些分类则纯属主观臆想。 如何进一步推动政策工具类型学的研究：1、重视政策工具箱的建设；2、坚持从个别到一般的认识路线；3、使政策工具与政策目标之间的因果关系明确化、明朗化，为政策工具的选择和配置奠定基础。 第三章 政策系统与公共决策体制 政策系统的三大子系统： ① 主体系统 ② 支持系统 ③ 反馈系统 公共政策主体是相对于政策客体而言的，指的是那些在特定政策环境中直接或者间接地参与公共政策制定、实施、评估、监控的行为者； 公共政策主体分为直接主体和间接主体两大类： 1、直接主体：即公共政策的法定生产者。 主要有 ① 代议机关 ② 行政机关 ③ 司法机关 ④ 其他直接主体(某些政治体制内的执政党和军队领导人或军队执政机构) 2、间接主体，分为三类： ① 次国家政策行为者 ② 跨国政策行为者 ③ 全球性政策行为者。 3、政策主体系统，包括三个子系统： (1)政策制定系统，基本功能是： ① 认定政策问题 ② 确认政策目标 ③ 组织政策方案的设计 ④ 主持审议备选方案并最终进行政策抉择 ⑤ 完成政策合法化程序并正式发布政策 (2)政策执行系统，基本功能是： ① 为政策方案的实施做好准备 ② 有效实施政策方案 ③ 分析和总结执行情况 (3)间接主体系统，基本功能是： ① 利益表达与利益综合 ② 提出公共问题 ③ 影响公共政策制定 ④ 影响并改变政策环境 ⑤ 填补政策直接主体所无法达到的空间 政策系统与环境的关系(政策网络)： 所谓政策网络是指在公共政策制定和执行过程中，政府和其他行为者围绕共同的、实际上是不断协商的信念和利益而结成的正式的和非正式的联系 1、公共政策环境变的复杂和动荡的主要表现： ① 不确定性 ② 关联性 ③ 模糊性 ④ 动态性 2、政策网络形成的原因主要有以下几个方面： ① 交流信息和意见的需要 ② 交换资源的需要 ③ 结盟的需要；④ 追逐权力的需要 ⑤ 协调的需要； 公共政策客体的定义： 是指政策发挥作用时所指向的对象或者说政策主体就哪些问题、针对哪些人制定政策；包括“人”，“事”； 1、从事的角度看，公共政策客体就是政策问题 2、从人的角度看，公共政策客体是目标人群—受制约的社会成员或社会团体 3、客体系统：由公共政策的客体组成的系统就是政策客体系统。 政策支持系统： 健全和完善政策支持系统是决策科学化、民主化的重要环节， 由以下子系统构成： 1、信息传播系统：是政策系统的“神经”系统，基本功能是： ① 信息的收集与整理 ② 信息的加工与储存 ③ 信息的传递 2、政策咨询系统： 也称“思想库”、“智囊”或“外脑”，通常由政策研究机构、政府与这些机构的关系、咨询活动构成 3、政策监控系统：是政策系统的一个特殊子系统， 基本功能是： ① 建立政策监控标准 ② 监测政策绩效 ③ 发现和纠正政策执行偏差 4、政策评估系统：政策系统的一个基础子系统， 五大构成要素是： ① 政策评估主体 ② 评估对象 ③ 评估目的 ④ 评估标准 ⑤ 评估方法 政策环境：对于具体的政策主体系统来说，存在两种不同的政策环境： 1、政策系统的一般环境即系统的生态环境，包括： ① 地理自然环境 ② 经济环境 ③ 政治法治环境 ④ 社会文化环境 ⑤ 国际环境。 2、政策系统的工作环境： 是指政策系统在制定和实施某项公共政策的过程中直接地对政策系统的运行产生影响的政策环境。 一国的现实国情是政策的工作环境。 政策反馈系统： 政策反馈系统是将政策的主体系统与客体系统、政策系统与政策环境连接起来的一个特殊子系统。 多层次、多网络是其突出特点。 政策系统的运行的步骤： ① 利益输入 ② 利益综合 ③ 政策形成 ④ 政策发布 ⑤ 政策执行 ⑥ 政策反馈 政府权力、政府职能与公共政策的关系：1、政府权力、政府职能的二重性决定了公共政策的二重性：① 公共政策是政府推行政治统治的基本工具② 公共政策是政府实施社会管理的重要手段 2、政府权力、政府职能决定政策的性质、类型与数量 国家结构与公共政策的关系：任何政策都是在一定的政治制度所提供的总体框架内运行的，国家结构形式主要分为：1、单一制：① 中央集权型(法国是中央集权型单一制的典型)② 地方分权型(英国是地方分权型单一制的典型)2、联邦制。 政府能力：政府在其职责范围内，运用公共权力，正确地制定并有效地实施公共政策的能力，其内涵包括如下：1、政府能力与政府权力、政府职能密切相关.2、政府能力包括政策制定和政策执行两个层次的能力 公共决策权的配置：1、根据最高决策权所属人数的多少，分为：① 首长制 ② 委员会制 2、根据决策权限的集中与分散程度，分为：① 分权制 ② 集权制 3、根据上级决策机关对下级的指挥控制方式，可分为 ① 完整制 ② 分离制 4、根据决策系统中个部门的职责权限和范围，分为 ① 层级制 ② 职能制。 公共决策规则：① 全体一致规则 ② 多数规则 公共决策体制的类型：① 总统制 ② 议会制 ③ 半总统制半议会制④ 超级总统制 ⑤ 委员会制 ⑥ 人民代表大会制 ⑦ 军人独裁制。 公共利益的内涵：首先是利益获得者的群体范围，其次才是利益实现的程度。 非政府政策行为者包括：公民、社会团体、政党、大众传媒 公民更多的是政策客体的理由：1、公民的真正意愿很难确定2、公民的意见多属短见3、公民参与成本过高，效率低下4、公民参与会导致社会不稳定 如何理解公民是公共政策的基石；1、整个政策运行过程都以公民为基础2、公民参与政策过程，可加深其对政策意义的理解，还可增加他们配合政策运行的自觉性，提高政策的效力3、政策过程的民主化、法制化要求公民参与4、随着信息网络技术的发展，政策信息的获得将变得十分便捷，公民的素质不断提高，消除了参与过程所遇到的障碍，提高其参与效率 社会团体、公民社会对公共政策的作用：① 政策信息沟通 ② 影响并制约公共政策 ③ 稳定公共政策秩序 ④ 角色替代 政党与公共政策：政党是公共政策制定最重要的倡导者和政策理念最重要的提供者，公共政策在很大程度上可以被视为执政党的政策，对公共政策的制定有着举足轻重的作用；在实行两党制的国家里，政党首先借助于公共权力才能够与公共政策现实地发生联系，政党的主张和要求转化为公共政策，只有那些在大选中获胜、取得国家政权的政党才能成为政策的直接制定者，其政治纲领和主张才能转变为公共政策。在实行一党制国家里，政党是公共政策的主导性力量。我国实行的是中国共产党领导的多党合作制度，作为唯一合法的执政党以及全国人民根本利益和意志的集中体现者，中国共产党在政策制定的各个环节上都发挥主导性作用，各民主党派不是在野党，而是参政党，特们通过政治协商制度参与国家大事情的讨论与决定 大众传播对公共政策的作用：1、提出公共问题并推动问题认定：① 监测环境变化，及时发现和提出公共问题② 促进信息交流，释放社会多元诉求③ 制造“焦点效应”，催生热点公共问题2、有效影响政策议程的设置：① 推动公众议程尽快转化为政策议程② 价值取向和利益导向的引领者③ 构建“第二现实”3、影响公共政策的抉择 大众传播对政策执行和监控：1、为政策执行提供良好的舆论支持；2、监督和控制政策执行过程 大众传播对政策评估和调整：1、及时收集和反馈公众对政策的意见；2、以自已特有的方式进行政策评估；3、推动公共政策的及时调整。 第四章 政策过程及其理论模型 模型：是对原型的抽象与模仿(仿真)，是认识主体为着一定的认识目的，依据相似性原则而构造出来的一种理念系统，以代表作为研究对象的真实系统即实际存在的事物；有实物模型(如地球仪)和理论模式两种。 模型及其认识论的意义：1、可以通过解释模型而认识原型的某种本质规定性，对所构模事物的运行结果和发展趋势做出了有效预测；2、模型是进行科学抽象的重要工具；3、模型是研究过程中资料搜集和经验观察的指南。 政策过程模型的必备条件：1、必须明确把握社会发展的方向；2、必须与宏观政策密切相关；3、必须建立在注重人文特点的行为科学与注重科学程序和方法的管理科学二者相互交融的基础上；4、必须对宗教、意识形态等大量非理性因素持客观态度；5、必须对时间非常敏感，并且具有历史色彩，即具有历时观察的功能 公共政策分析需要借助于模型的原因？1、模型及其认识论的意义2、公共政策学研究对象的具体性3、决策程序是根据模型的特征，人为地编制出的政策制定与执行的步骤顺序。 揭示认识论本质的政策过程模型有：① 理性主义模型 ② 渐进主义模型 ③ 规范最适模型与混合扫描模型 ④ 政治系统模型 揭示社会本质的政策过程理论模型有：① 机构—制度模型 ② 集团模型 ③ 精英模型 认识论本质理性主义模型 理性主义模型的含义：依据完整而综合的信息做出理性的决策，即遵循最小的投入获得最大产出的原则，选择最佳的方案，使用最佳的手段达到最大的政策结果 理性主义模型的具体运用：1、这种模式假定决策者是“理性人”；2、理性人的理性主义决策过程； 理性主义模型的缺陷：1、理性人缺乏经验支持；2、理性人的公正，客观和理智是有限的；3、过高地估计了逻辑推理和数学模型作为政策分析工具所起的作用，而对社会性，政治性，文化公共政策问题却往往束手无策；4、理性人在决策中拥有的知识，信息都是有限的； 西蒙和林德布洛姆德的修正：西蒙提出决策有限理性的命题，对其批评和改进形成了人们普遍接受的理性优化模型； 渐进主义模型 渐进主义模型的含义：林德布洛姆 主张援用民主智慧寓于社会互动之中的市场运作的原理，广泛地参与主体了解彼此德价值偏好，透过妥协调适，良性的互动进而实现政策的动态均衡； 渐进主义模型的具体运用：其两大命题为公共政策实际上只是过去政府活动的持续，只是根据过去的经验而对现行的政策做出局部的，边际性的调适；决策者把决策看做一个典型的一步接着一步永远没有完结的过程. 渐进主义模型的缺陷：其具有显而易见的保守性，只注重看起来微不足道的政策目标的制定及其实现，压制政策创新和具有根本意义的社会变革； 规范最适模型(德洛尔)：1、以四项假设为基础；2、把政策过程分为：① 决策前 ② 决策中 ③ 决策后；3、其特点是开放性和包容性； 混合扫描模型 混合扫描模型(埃齐奥尼)：1、试图保留理性主义模式和渐进主义模式各自的优势并弥补它们的缺陷.2、存在的缺陷：与规范最佳模型一样，是试图调和理性主义模型和渐进主义模型在思维方式和操作方法上的矛盾，就难免在价值取向上显得有些模棱两可； 政治系统模型 政治系统模型：1、系统论的创始人：贝塔朗菲；政治系统方法的创始人：伊斯顿；2、决策主体(政治系统)做出对社会具有约束力的权威决定，包含着一系列分配价值的决定和行动；3、把政策过程假定为：输入-决策-输出-反馈的系统运行过程；4、其特点是最具解释力、最具普适性的模型；5、缺陷：适合宏观分析的模型，只能给人们提供一个轮廓，不能够指明所分析的政策的具体特性； 社会本质的模型 机构—制度模型：1、特点是在公共政策分析中应用最广泛而又最缺乏理论色彩的决策模型；2、是建立在习惯性的思维模式上的(如人们对一项决策的好坏，有无总是与一定的政府机构-制度联系起来，或自然而然的在两者间建立某种因果关系或相关性)；3、戴伊：认为公共权力机关赋予公共政策三个显著特征：① 合法性 ② 普遍性 ③ 强制性； 集团模型：1、戴维.杜鲁门：集团理论更加系统化2、莱瑟姆：从集团理论这一视角去分析政府在政策形成的作用，形成了政策分析的集团模型； 对公共政策的界定是：某一特定时间集团间的争斗所达到的平衡； 3、特点：具有很强的洞察力和解释力；4、缺陷：过分夸大了集团的重要性而低估了公共权力机构自身所起德独立的又富有创造性的作用；无法解释人类在政府与政治过程上的许多问题；对于多元主义政治体制以外的那些政治体制内的决策过程缺乏解释力； 精英模型：1、现代精英政治理论的创始人莫斯卡、帕雷托和米歇尔斯，经由熊彼特和拉斯韦尔进行民主改造，到第二次世界大战以后逐步成为西方国家特别是美国政治学研究中的一个重要的分析途径；2、戴伊和齐格勒&lt;&lt;民主的嘲讽&gt;&gt;3、认为实际的政治过程和决策过程是由直接掌管政权的少数人来主导的4、缺陷：忽视了现代民主国家公民参与政治的要求和能力，以及这种参与政策形成的影响. “上来下去”政策过程模型——基于中国经验的政策过程模型： 1、建构的两种资源： 一是理论，特别是认识论和历史理论； 二是公共政策的经验认识 2、鉴于政策制定过程在认识论上是一个从“形而下”到“形而上”的的过程， 政策执行过程在认识论上又是一个从“形而上”到“形而下”的过程； 与此同时整个政策过程在政策主体和政策客体的关系则是“从群众中来， 到群众中去”的过程；它是一个逻辑过程； 3、 “上来下去”政策过程模型的特征是容纳性和开放性： 由若干个亚模型组成： ① 决策认识的真理性模型； ② 群众—领导性模型； ③ 个别——一般性模型；(民主--集中性模型) 4、具有鲜明的中国化，民族化特色的决策模式，它能容纳从国外引进的以科学决策为 根本诉求的任何决策理论，决策模式和决策手段 5、西方学者在另外的理论背景和经验事实的基础上建构的决策模式， 经过改造是可以被整合到我国“上下来去”模型的某一个亚模式中去的 6、西方现代社会调查的程序设计和技术手段，统计学方法， 计算机辅助决策系统等都可以在”上下来去”模型的社会操作过程中大显身手 构建中国特色的政策过程模型的原因：① 港、澳、台因素论 ② 华人经济圈论③ 儒家文化圈论 ④ 伟大人物论 ⑤ 政府功能论⑥ 国际形势论 ⑦ 政策决定论 决策过程理性化的含义：公共政策的制定必须以科学的精神，经由合法的公共权力机关，经由合法的程序，获得其合法性和强制力。 决策过程专业化的原因：(政策过程专业化也是公共政策科学化的重要内容)1、政策议程的确立需考虑专业技术人员的研究意见；2、提供政策建议，充当参谋3、专业人员的价值观、素质和利益等因素经常影响到政策实施效果；4、政策效果需专业人员来评估。他们的判断和诊断能够对政策的命运产生巨大影响 政策过程科学化的含义：就是决策者及其他决策参与者尊重客观规律，采用合理的决策程序，从实际出发，充分利用现代科学技术知识和方法，对政策问题及其产生的客观环境，事实求是地进行分析，并以此为基础对未来做出预测、判断和抉择 政策过程的民主化的含义：是指保障公民和各社会政治团体以及政策研究组织能够充分参与公共政策过程，保障政策内容尽可能充分地反映广大人民群众的根本利益与要求，在决策系统及其运行中形成民主的体制、程序和气氛 第五章 政策问题与议程设定 政策问题： 是指统治集团或社会大多数人感到现实中出现的某种情况与他们的利益、期望、价值和规范有相当严重的矛盾和冲突， 进而通过团体或组织活动要求有关社会公共组织和政府采取行动加以解决，并被后者列入政策议程的社会问题或公共问题； 公共问题的基本内涵： 1、客观的事实或问题情境； 2、问题的察觉； 3、现实与利益期望等的冲突性； 4、团体或组织活动； 5、政府或社会公共组织的必要政策行动； 公共问题和政策问题之间的关联及区别： 1、问题是泛指实际状态与社会期望之间的差距； 2、公共问题范围最宽，包括社会问题； 3、公共政策问题是基于特定的社会、公共问题，由政府列入政策议程并采取公共行动以期解决的问题。 政策问题的基本属性(基本特征)： ① 关联性与公共性 ② 客观性和主观性 ③ 历史性与动态性 政策问题的分类： 1、从政策问题的结构角度： ① 结构优良 ② 结构适度 ③ 结构不良三种类型 2、根据政策问题发生领域的不同： ① 政治问题 ② 经济问题 ③ 文化问题 ④ 外交问题 ⑤ 民族问题等 3、根据作用范围不同： ① 国际问题 ② 全国性问题 ③ 区域性问题 ④ 地方性问题。 常见的公共问题提出主体： 1, 政府部门 2, 政治人物 3, 政党组织 4, 利益集团 5, 大众传媒 6, 专家人士及咨询机构 7, 公民和社会团体 8, 政策网络 政策网络的含义：由政府机构与民间组织及市场主体、利益相关者或意见领袖们以及其他相关主体及人士组成的能对有关政策过程产生一定影响的政策社群、政策联盟或政策联合体。 主要可以分为： ① 利益型政策网络 ② 意见型政策网络 ③ 混合型政策网络。 问题认定：就是对需要由公共政策来解决的公共问题进行性质、范围、涉及领域及相关利益关系的界定过程。 问题认定的方法： 1、边界分析法：是一种对政策问题的本质属性和实际范围进行分析和界定的方法； 三个步骤： ① 饱和抽样 ② 诱导性提问 ③ 边界估计。 2、多角度分析： 即一种通过系统地运用个人，组织，技术等多重认识来获得对公共政策问题的全面了解和解决办法的分析方法； 多角度分析的三个角度： ① 个人 ② 组织 ③ 技术 3、类别分析法：是科学研究的常规方法之一，同样也是政策问题的分析方法之一，通常要经过逻辑区分和逻辑归类两个过程； 4、层次分析法：将政策问题的原因划分成可能原因、合理原因和可诉原因三个层次的一种分析方法。 其实属一种分类分析方法； (1)可能原因：是指一切有可能促成某种问题得以产生的因素； (2)合理原因：是指以科学的研究或直接的经验为基础所探查出的问题成因； (3)可诉原因：是合理原因中实际起作用的原因； (4)如就贫穷原因来说，拒绝工作，失业以及精英之间财富与权力的分配都算可能原因，而失业和精英之间财富与权力的分配属合理原因，而失业则是唯一的可行原因； 5、头脑风暴法：又称脑力激荡术，激智术，脑力激发术等，是指由一定数目的人员，尤其是一些专家学者或利益当事人，从各个角度共同讨论有关的公共政策问题，并因而激发大量新构想的一种分析过程和方法； 包含如下阶段： ① 组建团体 ② 意见产出 ③ 意见评估 ④ 意见排序 。 6、假设分析法：是一种旨在将相互冲突的政策问题立论假设创造性地综合为一体的分析技术.它比所有分析方法都更具有综合性，更适合于处理结构不良的问题 问题认定的步骤：1、对拟认定的问题进行初步观察2、勾勒出该问题的边界的轮廓3、搜寻事实依据4、列举目的和目标5、明确政策封套6、匡算政策相关者潜在的成本和收益7、在此审视对该问题的表述 政策议程：指有关公共问题受到政府及公共组织的高度重视并被正式纳入其政策讨论和被确定为应予以解决的政策问题的过程 政策议程的类型：1、系统议程：指政治系统正式讨论和认定有关公共政策问题的过程2、政府议程，即正式议程：指政府组织正式讨论和认定有关公共政策问题的过程； 政府议程的分类：(1)按照议程项目的新旧状况，分为：① 旧项目 ② 新项目(2)按照其建立过程中各项功能活动的先后次序，分为：① 界定或认定议程 ② 规划议程 ③ 磋商议程 ④ 循环议程； 系统议程和政府议程的差异，这是政策系统的划分的两大类：1、系统议程：由一些较抽象的项目组成，其概念和范围都很模糊，仅是整个政策过程中的问题发生或提出阶段；它不涉及可行性解决方案问题，所体现出来的往往是众说纷纭的特点；2、政府议程：由一些较具体的项目组成，处于政策问题认定的最后阶段，主旨在于最终认定与政策问题有关的种种事实，如青少年犯罪问题一旦进入政府议程阶段，政府就要详述该问题情形及各种具体的解决办法； 国外有学者将公共政策议程按照政策问题的重要性程度划分为：1、实质性议程：是指认定哪些影响深远和潜在意义重大的政策问题的议程；2、象征性议程：指一些政策问题虽然属象征性的，但也会引起社会和决策者政治上的关注的议程 进入政策议程的条件：1、事件或问题必须明朗而严重；2、要有政治权威领导人及专家学者的预测性发动；3、要有正常，民主和开放的察觉机制与过程。 进入政策议程的障碍：1、事件和问题并没有明显的严重化，政策问题仍处于潜在的状态和轻微的程度上；2、领导人和有关学者并没有察觉其严重性；3、社会缺乏正常的、民主和开放的察觉机制，过程(以上四点是于进入政策议程条件相对应的相反条件均可造成障碍)；4、不符合社会既得利益者价值规范的要求，不合乎社会制度和程序要求的问题；5、表达方式不当； 政策议程确立过程的模型： 1、科珀等学者的模型理论:(1) 外在创始模型：是属非政府团体创始政策问题的过程，通常先散布到公众议程，再介入政府议程；该类型通常在民主和平等的社会中比较常见。(2) 动员模式：属政府直接创始政策问题并将该问题扩散到公众议程的过程；该模式通常出现在不太民主的社会中；(3) 内在创始模式：属政府因解决纯政府内部事务而提出政策问题且不愿将该问题扩散到公众议程当中的过程；该模式在财富和权力高度集中的社会较为流行 2、芭芭拉.尼尔森的模型理论：议程的确立过程分为四个阶段：① 议题确认 ② 议题采纳 ③ 议题重要程度排序 ④ 议题持续。 3、约翰.金登的模型理论：三源流模型，建立在三种源流的基础上：(1)问题流：主要关注问题的定义，包括预算约束，问题是如何被认知的，以及客观条件是如何被定义为问题的(2)政策流：与解决问题的技术可行性、问题解决方案的公众接受度等有关；(3)政治流：设计政治对于问题解决方案的影响。(4)当问题流、政策流、政治流汇合到一起，政策窗口就打开了。 4、中国学者的模型理论：① 关门模式 ② 动员模式 ③ 内参模式 ④ 借力模式 ⑤ 上书模式 ⑥ 外压模式。 第六章 政策方案的规划与抉择 政策目标：就是有关公共组织特别是政府为了解决有公共政策问题而采取的行动所达到的目的、指标和效果 政策目标的特征： ① 问题的针对性 ② 未来的预测性 ③ 目的的多元性。 公共政策目标的分类：P279 公共政策目标的基本目标： ① 公平 ② 效率 ③ 自由 ④ 安全 确定政策目标的意义：1、能为制定政策方案提供方向性指导；2、能为政策方案的规划和实施提供核心的评估标准 确定政策目标的原则： ① 实事求是 ② 面向未来 ③ 系统协调 ④ 明确具体 ⑤ 伦理考量 政策规划，即政策构建：是指建立有关政策议程后，为了实现一定的政策目标，政府组织力量草拟和评估政策方案与行动步骤的过程。 政策规划的特征：1、从政策规划的主体来说，多元化与政府主导并存；2、从时间进程上来看，政策规划主要存在于政策目标的确定与政策抉择之间 政策设计：是政策分析人员有系统地探讨政策问题，并组合解决问题的相关政策要素，产生政策方案，使各政府要素间具有一致关系，并符合现实环境，以达成政策问题能够解决的一种不断调整的动态过程。 政策设计的逻辑结构：1、方案设计的 基本要素：① 结果 ② 目标人群 ③ 执行机构 ④ 法规2、政策的 联系机制 构成：① 规制 ② 工具 ③ 假定 政策规划的主体：1、政策规划的政府主导化：体现在规划的组织和管理方面。在现实的政策规划过程中，政府可能不仅仅在规划的组织和管理上占主导地位，在规划方案进入抉择阶段上也可能常常占主导地位；其中有政府的地位的影响，也有政府在设计方案时往往比较务实等原因 2、政策规划的主体多元化。政策主体可以是单一的，也可以是多元的，多元化是现代公共政策过程中各国通行的模式 3、单一主体的政策规划：规划主体为政府机构；优点：能把握全局。缺点：公正、科学难以保证；缺乏民主性 4、多元主体的政策规划：规划主体为政府机关、研究机构、利益集团；优点：公正、科学、民主.缺点：可能失之于片面；通常采取听证制度； 政策方案设计的原则：① 紧扣政策目标 ② 规划多重方案 ③ 方案彼此独立 ④ 方案要有创新 ⑤ 方案切实可行。 政策规划的主要模型： 1、韦默和维宁的政策分析框架，将政策分析过程分为两个阶段：(1)问题分析 由三个重要步骤构成：① 理解问题 ② 选择和解释目标与约束 ③ 选择解决办法(2)解决方案 分析，分为四个步骤：① 说明相关标准，也就是确定备选政策方案的评估标准;② 详细说明能够潜在推进政策目标的备选政策方案;③ 用每一种衡量标准来评价每一种备选政策方案，预测其可能产生的影响;④ 推荐一种备选政策方案，并提供选择的依据 2、帕顿与沙维奇的政策分析框架，政策分析的六个步骤：① 认定和细化问题 ② 建立评估标准 ③ 确认备选政策④ 评估备选政策 ⑤ 展示和区分备选政策 ⑥ 监督和评估政策实施 政策学习的类型(从内容及程序上)：① 工具学习 ② 概念学习 或者 问题学习 ③ 社会学习 政策移植的类型：1、按政策借鉴的程度不同：① 复制 ② 效法 ③ 混合 ④ 启发 2、从政策制定者的意愿角度：① 自愿的政策移植 ② 被迫的政策移植 公共政策的抉择：是由公共政策的制定者根据政策规划建议和要考量的事项，按照一定的决策制度和规定，对解决有关政策问题的行动方案作出决定性选择的过程。这是公共政策制定过程中最具实质意义的阶段。 公共政策的抉择主体：① 国家元首；② 行政首长；③ 民意代表；④ 法官；⑤ 执政党首脑以及军事首长等 公共政策抉择的原则：1、尊重科学分析的价值；2、考量各方利益的平衡；3、发挥决策者的能动作用；4、遵照有关程序的规定 政策抉择的环节：1、政策论证；2、政策审议；3、政策采纳 政策论证的六大要素：① 政策相关信息 ② 政策主张 ③ 立论理由 ④ 立论依据 ⑤ 驳斥理由 ⑥ 可信度 政策论证的八种模式：① 权威模式 ② 统计模式 ③ 类别模式 ④ 直觉模式⑤ 分析模式 ⑥ 解释模式 ⑦ 实用模式 ⑧ 价值评价模式 政策论证的特殊形式——政策探究和政策对话 政策审议的基本方法——评估和择优 方案评估与择优的两种主要方法：1、预测性评估：(1)预测性评估的步骤：方案调查；详细研究；进一步的分析；试验式证实。(2)预测性评估的方法：① 外推预测：分析人员根据目前的和历史的数据，来判断未来的社会状况② 理论预测：理论预测帮助分析人员以理论假设，以及当前和历史的数据为基础对未来的社会状况做出预测③ 判断预测：试图就各种判断进行推导和合成。 2、可行性评估：(1)林水波、张世贤提出可行性包括四个层次：适当、可能、可行的、可行性实验；(2)可行性分析的对象：技术可行性，政治可行性，经济可行性，行政可操作性 政策采纳：就是决策者正式同意采用某一政策方案来解决列在政策议程中的特定问题。 公共政策抉择的合法化：是有关政策抉择主体依据有关法律，按照法定程序对政策方案加以审查，通过或批准，签署及发布的过程；其内容包括三个方面：1、政策内容合法化的含义：就是决策者择定的政策在内容上不能与既定的宪法和法律相抵触。必须合乎有关法律的原则甚至具体规定。 2、决策程序的合法化：就是政策抉择过程应合乎法定的程序要求。(1)行政系统的决策程序：① 法制部门的审查 ② 领导会议的讨论决定 ③ 行政首长的签署发布。(2)立法系统的决策程序：① 提出议案 ② 审议议案 ③ 通过议案 ④ 公布政策 3、政策的法制化：就是有立法权的国家机关将有些成熟、稳定的政策上升为法律的过程，也称政策立法，其实是一种立法过程。 危机决策的构成需要具备三个要素：1、决策问题的发生、发展具有突然性、急剧性，需要决策者当机立断2、可供决策者利用的时间和信息等资源非常有限3、事态的发展危及决策单位、决策者的根本利益，并且决策的后果很难预料 第七章 公共政策执行 公共政策执行：是政策执行主体为了实现公共政策目标，通过各种措施和手段作用于公共政策对象，使公共政策内容变为现实的行动过程。 公共政策执行的特点：① 目标的导向性 ② 内容的务实性 ③ 行为的能动性 ④ 手段的权威性 公共政策执行的作用：1、政策执行是实现政策目标的重要途径；2、政策执行是检验政策质量的唯一环节；3、政策执行是制定后续政策的基本依据 基于中国经验的政策执行“上来下去”模型内涵：1、政策执行是一个“从群众中来到群众中去”的过程；2、政策执行是一个“实验-推广”的过程；3、政策执行是一个“执行-总结”的过程 基于西方经验的政策执行理论模型：1、过程模型(史密斯模型)：提出政策执行主要涉及四大变量：① 理想化的政策 ② 执行机关 ③ 目标群体即政策对象 ④ 环境因素 2、互适模型(也称互动理论模式，麦克拉夫林)：政策执行是执行者与受影响者之间就目标或手段相互调适的过程；有效的政策执行有赖于成功的相互调适。 3、循环模型(雷恩—拉宾诺维茨模型)：(1)政策执行经历的三个阶段：① 拟定纲领阶段 ② 分配资源阶段 ③ 监督执行阶段；(2)每个阶段都应该贯彻的原则：① 合法 ② 理性 ③ 共识 4、博弈模型(巴达克)：参与竞赛者是完全理性人，政策执行是一种游戏，它包含 6 个规定：① 竞赛者 ② 利害关系 ③ 竞赛资源 ④ 竞赛规则 ⑤ 信息沟通 ⑥ 结果的不确定 5、系统模型(霍恩—米特模型，霍恩和米特提出的)：影响政策执行的变量来自系统本身和系统环境；合理有效的政策执行模型必须重视五个重要变量：① 政策目标与标准 ② 政策资源 ③ 执行者的属性 ④ 执行方式 ⑤ 系统环境)。 6、综合模型(梅兹曼尼安—萨巴提尔模型)：认为政策执行是一个受多种变量影响的动态过程；将影响政策执行的变量追溯到了政策问题 政策执行机关的特性：① 执行性 ② 服务性 ③ 权威性 ④ 法制性 下级执行人员执行行为的地位及作用：1、行政人员的执行行为是政策执行的主体行为；2、行政人员的执行行为是实现政策目标的重要保证；3、行政人员的执行行为是塑造政府形象的重要途径 公共政策执行力：是政策执行者通过对政策目标及其方向的把握，设计政策实行方案，调度和配置相关资源，运用政策工具，从而实现政策目标、最终解决社会问题的能力及其成效。高效的政策执行力必须具备的要素：① 必须具备较高的政策执行能力 ② 必须具备较好的成效力。 公共政策执行力的影响因素：① 执行者因素 ② 资源因素 ③ 工具因素 ④ 环境因素 创新提升公共政策执行力的机制：1、优化公共决策机制；2、创新政策执行的动力机制；3、构建政策执行的功能共享机制；4、完善政策执行的利益均衡机制。 影响政策执行的主要因素1、政策本身。政策本身对于政策执行的影响因素：① 政策的合理性 ② 政策的具体性 ③ 政策的稳定性 2、公共政策执行主体：是指负责组织落实公共政策的人员或组织，主要包括国家和地方的行政机关、司法机关、被赋予执行权的其他公共权力机关以及供职于这些机关的公职人员。政策主体对于政策执行的影响因素：(1)政策执行组织：① 执行组织的结构的合理性：要求组织的纵向结构层级化和横向结构专业化；② 执行组织权责的明确性。(2)政策执行人员：① 利益因素 ② 心理因素 ③ 知识因素 ④ 能力因素 3、政策对象。政策对象对于政策执行的影响因素(公共政策对象的特点)：① 政策规定性 ② 受动性 ③ 主观差异性 4、政策环境。政策环境对于政策执行的影响因素：(1)自然环境；(2)社会环境：① 政治环境 ② 经济环境 ③ 文化环境 公共政策执行偏差：是指执行者在实施政策的过程中，由于受主客观因素的制约，其行为效果偏离目标并产生了不良后果的政策现象 政策执行偏差的表现形式：① 象征性政策执行(不务实或阳奉阴违，前紧后送，敷衍塞责)；② 附加式政策执行(土政策)。③ 残缺式政策执行(断章取义，为我所用)。④ 替代性政策执行(挂羊头，卖狗肉；上有政策下有对策；)。⑤ 观望式政策执行(软拖)。⑥ 照搬式政策执行(原原本本传达，不折不扣执行，呆板执行)⑦ 规避式政策执行(扯皮推诿) 执行偏差产生的主观原因：① 政策执行者自身利益和需求。② 执行者的素质缺陷。③ 执行机构的管理缺陷。④ 政策执行的宣传缺陷。 执行偏差产生的客观原因：① 政策本身的复杂性。② 政策环境的变化。③ 目标群体的压力(利益集团的压力；目标群体的文化障碍)。④ 缺乏健全的监督机制。 政策执行偏差的矫正：1、加强公共政策执行的成本-收益分析；2、加强公共政策的认知力度；努力提高公共政策执行者的素质；3、加强公共政策执行的控制与监督；4、加强公共政策执行的制度创新； 政策失灵：政策失灵通常被称为“政策失效”、“政策失败”，其实质是指政策执行之后，政策不一定总是能产生政策主体所希望的结果。 政策无效执行：在政策执行的过程中，会有许多的意外和多变因素，当这些因素致使政策执行行为偏离政策目标时，就会导致政策执行无效。 政策无效执行的具体表现：1、执行机制与执行者的缺陷；2、利益群体或压力集团的影响；3、政策执行原则把握不好；4、政策执行环境的影响；5、目标群体的不配合或抵触 公共政策有效执行的原则：① 忠实原则 ② 民主原则 ③ 法治原则 ④ 创新原则 公共政策有效执行的机制：1、公共政策信息沟通机制 2、公共政策的公民参与机制，表现以下几个方面：① 公民参与执行计划 ② 公民参与执行监督 ③ 公民参与执行评估 3、公共政策的激励、责任与监督机制：① 激励机制 ② 责任追究机制 ③ 监督机制 第八章 公共政策的评估与监控 公共政策评估的含义： 依据一定的标准和程序，通过考察政策整个政策过程的各个阶段，各个环节，对政策的效率，效能，效益，价值等进行检测和评价，以判断政策结果实现政策目标的程度。 公共政策评估的目的： 1、积极目的： ① 发现政策制定过程中的偏差，为备选方案确定优先顺序提供依据； ② 明确政策的可行程度，得出继续执行政策或停止执行政策的判断； ③ 依据评估结果，改善政策执行程度与技术； ④ 分清多项政策的轻重缓急，对政策资源进行重新配置，为下次政策制定、执行和调整过程准备一定的有利条件。 2、消极目的： ① 炫耀工作业绩，为本级政策或相关政策部门歌功颂德，追求个人职位的升迁； ② 夸大工作难度，要求追加政府活动预算，增加工作机构和人员； ③ 规避责任； ④ 批评政策以达到改变政策的目的。 公共政策评估的作用： 1、政策评估是获取政策运行可靠和有效信息的重要手段； 2、政策评估是进行政策调整、提出政策建议的重要依据； 3、政策评估是检验政策结果的必要途径； 4、政策评估是重新配置政策工具和政策资源的基本前提； 5、政策评估是构建良好公共关系的有效策略； 6、政策评估是管理科学化和民主化的必要保证。 政策评估的主体： 除了立法机关、政党组织、司法机关、社会组织和公民外，比较重要的评估主体是： 1、政策制定者和执行者： 了解全貌、评估结论容易被采纳。容易受到固有观念和利益的束缚， 同时因为往往缺乏评估专业训练，所以影响评估质量。 包括五方面的工作： ① 政策调查报告 ② 政府工作报告 ③ 公民意见投诉 ④ 政策听证会 ⑤ 政府效能考评或绩效考评。 2、专业机构和人员： 机构系统内部的评估者和受托者： 评估结论易受重视，但是容易受到牵制和暗示，而影响评估质量。 独立观察者和研究者：不带偏见，但是材料困难，结论不易受重视。 3、大众传播媒介： 中国正处于转型期，政府信息披露程度较低， 因此大众传播媒介作为政策评估主体占有很重要的地位。 公共政策评估的类型： 1、正式评估和非正式评估 2、内部评估和外部评估 外部评估分为两种类型： (1)受委托进行的评估，最主要的外部评估方式； (2)不受委托进行的评估，这类评估包括： ① 立法机关评估 ② 司法机关评估 ③ 大众传播媒介评估 ④ 投资者(如企业)评估 ⑤ 公民评估 ⑥ 研究机构评估 ⑦ 社会团体(第三部门)评估 3、预评估、过程评估和结果评估 4、单一政策评估与复合政策评估 公共政策评估的内容： ① 政策成本评估 ② 政策需求评估 ③ 政策效益评估 ④ 政策过程评估 ⑤ 政策影响评估、⑥ 政策价值评估。 政策评估的过程： 1、评估筹划： ① 明确评估目的 ② 选定评估对象 ③ 制定评估计划 ④ 明确评估条件 2、评估实施； 3、评估总结。 公共政策评估的标准： 1、事实标准：能够用数量值、比率关系、统计结果等手段来反映事物过去、现在和将来的存在状况。其内容包括： ① 政策效率，即政策的投入与产出或成本与收益之间的比例关系； ② 政策效益，即政策目标得以实现的程度； ③ 政策影响，指政策产出所引起的人们在行为和态度方面的实际变化。 ④ 回应性， 即既定政策目标实现后，政策结果满足人们需求、价值与机会的有效程度。 2、技术标准：是以技术手段、技术规范和技术工具为手段来服务整个政策评估活动，是评估活动建立在科学、客观与可信的基础之上。 其内容包括： ① 多样化 ② 系统化 ③ 数量化 3、价值标准反映评估主体在评估活动中的倾向性准则和原则，建立在一个国家特定的历史与现实、伦理与文化、社会和经济价值取向的基础上。 其内容包括： ① 社会生产力的发展 ② 社会公正社会可持续发展 影响公共政策评估的重要因素： ① 政策信息、资料 ② 政策制定者与执行者 ③ 政策目标 ④ 政策的沉淀成本 ⑤ 政策评估方式、方法和规范 以定量分析为主的公共政策评估方法：1、指标法，政策指标：是一种将公共统计数值用于评估公共政策的一种衡量工具。政策指标体系的价值取向：① 经济效益取向 ② 主观性的福利取向 ③ 公平性取向 2、回归分析法，一元线性回归分析：是指找出只有一个自变量与一个因变量之间线性相关关系的回归方程，然后再做进一步的趋势分析的技术。 3、实验法，实验法评估公共政策：就是运用随机指派的方法，将一群受试者分配到两个以上的研究小组中，其中一组接受政策实验的处理，称之为实验组，另外一组是没有接受政策实验的小组，称之为对照组。 以定性分析为主的政策评估的程序：1、认定承受政策风险的利益相关者；2、界定出政策利益相关者的政策认知，尤其是其利益诉求；3、营造质化评估的网络与方法；4、寻找各种利益相关者的利益诉求平衡点；5、对于没有达成共识的政策诉求设定一个妥协的日程表；6、尽可能更多的采集与妥协议程相关的信息；7、建立利益相关者的论坛；8、将已经达到妥协和共识的政策诉求形成报告；9、将尚未达成共识的各种政策诉求求按照上述顺序重新构建一次，直到满足大多数人的政策诉求为至 公共政策监控：为了确保政策过程各项活动的合法性、合理性和有效性，及时纠正各个环节中出现的偏差，提高决策目标的实现程度，保障公民和组织的合法权益，有必要对政策运行过程的各个环节加以检查、督促、指导和纠偏。 公共政策监控的内容：① 政策监控的主体 ② 政策监控的对象 ③ 政策监控的目的 ④ 政策监控的过程。 公共政策监控的类型：1、以实施的时间先后为标准，分为 ① 预防性监控 ② 过程性监控 ③ 结果监控。 2、以监控的经常性为标准，分为 ① 经常性监控 ② 引发性监控。 3、以监控的参与程度为标准，分为 ① 单方面监控 ② 抗辩性监控。 公共政策监控的功能：1、使政策制定过程合法化、决策科学化和民主化2、确保政策执行过程的有效性3、体现政策评估活动的价值取向4、明确政策调整活动的方向 公共政策监控机制：是由政策监控主体、政策监控对象、政策监控主体发生作用的内容和方式等要素构成的一个系统。 1、内部政策监控机制： ① 自上而下监控 ② 自下而上监控 2、外部政策监控机制： (1)立法机关对公共政策的监控：是最重要的政策监控的主体之一； ① 以法律形式对政策进行监控； ② 听取和审议政府工作报告、预决算安排等形式； ③ 形式人事任免权的方式。 ④ 以诘问、质询和弹劾的方式； ⑤ 以提出不信任案的方式； ⑥ 以检查、视察或组成特别调查委员会的方式。 (2)司法机关对政策的监控： 是一种消极的形式，即对各项政策内容，环节和各种措施的违法行为的强制纠正。 体现为以下几方面； ① 裁定公共政策的制定程序与原则是否合法 ② 裁定公共政策的内容是否合法、合理， ③ 裁定公共政策的执行是否合法 ④ 裁定公共政策执行的方式是否符合法律程序 (3)政党组织对公共政策的监控，一般采用以下几种方式： ① 执政党通过党员选入立法机关来影响和监控政策的制定； ② 通过党员掌握国家权力和政府权力来主导执法和行政决策 ③ 通过其掌握的社会团体，社会组织和大众传媒等制造社会舆论来监控。 (4)利益集团对公共政策的监控，主要表现以下几方面 ① 接近 ② 提供信息 ③ 游说 ④ 提供竞选支持。 (5)大众传媒对公共政策的监控 (6)公民对公共政策的监控 公共政策监控的过程：(1)对公共政策制定过程的监控；(2)对公共政策执行过程的监控；(3)对公共政策评估过程的监控；(4)对公共政策调整的监控 第九章 公共政策的稳定、变动与终结 公共政策稳定的内涵：是现行政策在受到来自外部和内部的压力影响下，任然保持其既定的目标，由原来的执行机构按照既定的方式、沿着既定的方向继续得以实施。 但政策稳定是相对的，表现在两个方面：1、从时间上看，政策稳定是阶段性与连续性的统一2、从空间上看，政策稳定是局部性与全局性的统一 政策稳定的意义：1、政策稳定有利于国家与社会的稳定。2、政策稳定有利于贯彻落实执政者或决策者的意志和决定，进而取得预期的成效。3、政策稳定有利于提高政策的可预见性，提高政策效果。4、政策稳定有利于降低政府成本。5、过分注重稳定的政策可能使其趋于保守，甚至导致政策僵化。 影响公共政策稳定的动力因素：除了上述政策稳定的积极效果以外，具体因素还包括以下几方面：1、决策主体和决策网络的相对稳定2、政策问题的解决需要一个过程3、政策本身的稳定：(1)政策目标的长期性；(2)政策的有效性；(3)政策的合法性；(4)修改的复杂性；(5)持续政策的失败；(6)政策终结的失败。4、政策环境的稳定 政策变动：政策变动是政策系统的一种常态表现，是政策系统对内部因素和外部环境的变化所作出的一种适应性变革。 公共政策变动的原因：① 决策者的变动 ② 政策环境的变化③ 政策资源的现值 ④ 政策的失效或低效⑤ 政策的合法性受到置疑。 公共政策变动的类型： 1、按照变动的强度：① 断裂型 ② 渐变型 2、按照变动的程度：① 部分变动、② 重大变动 ③ 完全变动 3、按照变动的内容：① 目标变动 ② 计划或项目变动③ 资源变动 ④ 机构或人员变动 ⑤ 政策本身的变动 4、按照变动的形式：① 替代 ② 合并 ③ 分解 ④ 废止 ⑤ 创新 5、按照变动的规律性：① 周期性变动 ② 不规则变动 6、按照变动的动力：① 主动变动 ② 被动变动 公共政策变动的模式：① 周期型 ②Z 字形 ③ 学习型。 公共政策创新的内涵：是公共政策主体根据政策环境变化的需求，主动改变现存政策要素的组合形态或功能，创造新政策的行为和过程。即可能发生在政策过程的所有环节，又可能仅发生在某一环节中。 公共政策创新的动力：(1)从内部动力看：① 政策主体的变革愿望 ② 政策本身的要求；(2)从外部动力看：① 经济制度和体制变革是政策创新的直接动力② 民众诉求是政策创新的根本动力③ 地区之间竞争压力的需要④ 参与世界竞争的需要。 公共政策调整：在公共政策的实施过程中，根据政策评估和监控所反馈的信息对原有政策中不适应政策对象和政策环境变化的部分，进行的增删，修正和更新。有三个特点：① 渐进性 ② 局部性 ③ 动态性。 公共政策调整的内容：① 政策目标调整 ② 政策方案调整 ③ 政策措施调整④ 政策关系调整 ⑤ 政策主客体调整 公共政策调整的形式：① 政策的增删 ② 政策的修正 ③ 政策的更新。 公共政策调整的程序：① 重新界定问题 ② 提出调整方案 ③ 选择调整方案 ④ 执行调整决定 公共政策调整的原则：(1)实事求是原则 (2)渐进调适原则 (3)追踪反馈原则 公共政策调整的原因：① 利益刚性的限制 ② 现行政策的制约 ③ 公共意志的趋中④ 变革成本的约束 ⑤ 人类理性的局限 ⑥ 社会稳定的需要 公共政策调整的作用：① 及时纠偏、预防失误 ② 协调关系、有序运行 ③ 发展完善、保持稳定 公共政策接续：以政策问题为中心，努力保持政策目标稳定和连续的行为和过程，其形式通常表现为旧的政策、政策执行程序或执行组织被新的政策、政策执行程序或执行组织所替代。 公共政策终结：是公共政策的决策者通过对政策进行审慎的评估后，通过采取必要的措施，以终止那些错误的、过时的、多余的或无效的政策、政策功能、政策计划或政策组织的一种行为。 公共政策终结的对象：① 功能(终止由政策执行带来的某种或某些服务)② 组织(专为政策组成的组织)③ 政策④ 计划(指执行政策的措施和手段) 公共政策终结的方式：(1)政策废止 (2) 政策替代 (3) 政策分解 (4) 政策合并 (5) 政策缩减 公共政策终结的原因：1、经过评估认为政策的目标已经实现，政策问题已得到解决，政策没有继续存在的必要；2、经过评估发现政策存在的是的失误或局限使其无法解决所面临的问题。如果继续执行不仅浪费资源而且会带来不良后果。 推动政策终结的三种力量：① 反对者 ② 节约者 ③ 改革者。 公共政策终结的作用：(1) 政策终结有利于节省政策资源 (2) 政策终结有利于提高政策绩效 (3) 政策终结有利于促进政策优化 公共政策终结的障碍：1、组织的持久性：(1)组织机构的功能性；(2)组织机构的保守性；(3)组织机构的适应性 2、代价：(1)情感和政治上的代价；(2)法律和财政上的代价。 公共政策终结的策略：① 重视说服工作，消除抵触情绪；② 注意因势利导，营造有利气氛；③ 公开评估结果，争取支持力量(是政策终结成败的关键)；④ 废旧立新并举，缓和终结压力；⑤ 试探试点先行，避免矛盾激化；⑥ 终结必要部分，减少终结代价。 第十章 公共政策学知识的应用 知识的含义：知识是人们通过经历、观察或学习而获得的对事物的理解或会意，它依靠人们的好奇心、思维能力、记忆和想象力等得到开发、积累、传承，并在人类的活动中得到运用并发挥效用。 知识的特征：① 不可逆性 ② 共享性 ③ 非磨损性 ④ 交换的不对称性 ⑤ 可传播性。 政策学知识的应用：指的是使用者选择并运用所掌握的政策学知识以分析和解决现实的政策问题或创造新的知识的过程。主要形式：政策分析。 政策分析：是指政策研究者和政策研究组织以及决策者，把科学的知识和方法应用于政策的选择和公共问题的解决，在公共政策领域内创造和应用知识的复杂的社会过程。 政策分析的要(与政策内容和政策过程的构成要素是一致的)：① 问题 ② 目标 ③ 方案 ④ 模型 ⑤ 评估标准 ⑥ 实施效果 ⑦ 环境 ⑧ 信息 政策分析的原则：① 民主化原则 ② 系统性原则 ③ 协调原则 ④ 多样性原则 ⑤ 分合原则 ⑥ 预测性原则 政策分析的过程：(1)定义(2)预测(3)规定(4)描述(5)评估 政策分析的注意事项：① 墨守成规的政策建议 ② 生搬硬套的政策建议 ③ 姗姗来迟的政策建议④ 一知半解式的政策建议 ⑤ 狗急跳墙式的政策建议⑥ 反复无常式的政策建议 ⑦ 脱离政治式的政策建议 应用性政策研究组织的含义：指的是那些在系统调查的基础上，为政府、企业或社会团体出谋划策、提供政策依据，以期影响其决策行为的社会组织。 应用性政策研究组织的作用：最重要职能是为决策者或掌权者服务，一方面是直接填补掌权者的职责与实际能力之间的差距，另一方面是间接起到补强政府职能作用，为政府机构的有效运行服务。具体作用是：① 作为辅助决策的咨询机构，向决策者提供政策建议;② 作为政策学知识的应用者和创造者，提供新的观念、理论和方法③ 作为评估性机构，提出解决问题的方案④ 作为人才成长、储备机构，源源不断地向政府输送高质量的官员和专家。⑤ 作为思想和知识传播机构，通过传播其思想和观点，对公众进行政策教育。 应用性政策研究组织的类型：1、行政型政策研究组织；2、事业单位法人型政策研究组织；3、学术型政策研究组织；4、产业型政策研究组织；5、民办非企业法人型政策研究组织。 政策分析师的角色定位：P446 政策分析师的素质要求：① 具有政治头脑 ② 具有总体观念 ③ 致力于创新④ 具有洞察力 ⑤ 着眼于未来 ⑥ 弹性的思维 应用性政策研究组织与政策分析师的职业伦理：① 道德品质要求 ② 行为规范要求 ③ 价值判断要求","link":"/2021/01/28/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/%E5%85%AC%E5%85%B1%E6%94%BF%E7%AD%96/%E5%85%AC%E5%85%B1%E6%94%BF%E7%AD%96%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"title":"重点汇总","text":"00315 当代中国政治制度 考核知识点与考核要求(重点汇总)1 - 6 8 9 10 11 16 人民代表大会制度民族区域自治制度特别行政区制度基层民主制度一般地方行政制度 1 - 6 8 9 10 11 16第 1 章 *结论一、选择题 一个社会的经济制度与政治制度是 决定 和 被决定 的关系。 经济制度决定政治制度 中国社会主义的 根本政治制度: 人民民主专政的国体(国家制度) 、人民代表大会制度的政体(国家政权组织形式)。 中国社会主义基本政治制度: 中国共产党领导的多党全作和政治协商制度。 中国共产党 第十六次全国代表大会 明确提出 政治体制改革 是社会主义政治制度的 自我完善和发展。 列宁 指出 国家问题 是关系到全部政治生活的根本问题。 二、简答题 政治制度具有以下几个显著的特点：(1) 历史性。即它随着历史发展而变化。(2) 稳定性。即它在一定有历史条件下形成的，受国家经济制度所决定，而不是某人或某社会集团的主观意志决定的。(3) 强制性。即它不仅有法律予以规范，更重要的有强大的国家机器作后盾。(4) 合法性。即它是由各国权利主体指定的宪法决定的，具有法律依据。 简述 政治体制改革的主要改革成果。(1)废除干部领导职务终身制，建立干部离退制度(2)党政职能分开(3)实施公务员制度(4)加强社会主义基层自治制度建设(5)完善人大立法制度(6)明确了中国共产党执政的基本方式(1) 废除干部领导职务终身制，建立干部离退制度，实现了干部队伍的年轻化、革命化、专业化、知识化、保持了党和国家的活力。(2) 实现了党政职能分开，调整了党的组织形式和工作机构。(3) 加强了社会主义基层自治制度建设。(4) 实施公务员制度。(5) 转变政府职能，根据高效、精简、统一的原则，进行了行政机构改革。(6) 调整和规范中央和地方的政治经济关系，更有利于调动中央和地方两个积极性。(7) 提出依法治国方略，加快人大立法速度，完善人大立法制度，2000 年全国人大通过了《中华人民共和国立法法》，就立法权限、立法程序、法律解释、行政法规、地方性法规等作出了法律规定。(8) 进一步明确了中国共产党执政的基本方式。(9) 进一步加强了中国共产党领导的多党合作和政治协商制度建设。(10) 按照依法治国和构建社会主义和谐社会的要求，进一步完善司法机关和司法制度。 第 2 章 *当代中国国家制度一、选择题 国体是指反映国家阶段本质的制度。 当代中国的国家制度是人民民主专政。(国体) 《共同纲领》第 1 条规定：“中华人民共和国为新民主主义即人民民主主义的国家”，它以新民主主义即人民民主主义为建国的政治基础。 第 一 届 全 国 人 大 召 开 前，代行 全 国 人 大 职 权 的是 中国人民政治协商会议。 1954 年 第一届人民代表大会 产生前 中央人民政府委员会 行使 国家权力机关 和 中央行政机关 的职权，兼有国家 最高权力机关 和 最高行政机关 的双重性质。 1949 年根据《共同纲领》建立起来的新中国国家政权性质是 新民主主义国家政权。 1954 年 中国全面进入社会主义 在社会主义建设时期，中国政治制度大体上经历了三个主要发展的时期：(1) 1956 — 1966 年开始全面建设社会主时期；(2) 1966 — 1976 年“文化大革命” 时期；(3) 1978 年党的十一届三中全会以来新的历史时期。 1956 年— 1966 年全面建设社会主义时期政治制度发展的主要特点是 共产党的 一元化领导体制的全面加强。 1959 年 4 月，中共八届七中全会讨论了撤销国家监察部的问题，同月，第二 届全国人民代表大会第一次会议作出决议，宣布撤销监察部，党的监察委员会取代 原国家行政监察机构执行行政监察职能。 “文化大革命”中：(1) 取代地方国家政权机关是 革命委员会；(2) 人民代表大会制度 全面瘫痪；(3) 我国的司法制度被“彻底砸烂”；(4) 我国 社会主义政治制度 的所有方面都遭到了严重破坏。 国家的实质是 阶级统治的工具，是一个阶段压迫另一个阶级的的暴力机 器。 中国的人民民主专政坚持以工人阶级为领导，以 工农联盟 为基础。 1982 年通过的新的宪法规定：“中华人民共和国是工人阶级领导的、以工农联盟为基础的 人民民主专政的社会主义国家 ”。 二、简答 简述 1966 — 1976 年“文化大革命”时期，中国政治制度发展的主要特点。(1) 是党对国家政权的领导遭到破坏，中央文革小组代替了中央政治局。(2) 成立“革命委员会”，代替国家政权机构，成为集党政军在权于一身，包揽党务、行政、司法各项工作的权力机构。 人民民主专政的特点。(1) 中国的人民民主专政坚持以工人阶级为领导，以工农联盟为基础。(2) 中国共产党在人民民主专政的国家制度中居于领导地位。(3) 人民民主专政的国家政权具有很大的灵活性和适应性，把新民主主义革命任 务和社会主义革命任务、社会主义现代化建设任务有机联结起来。(4) 人民民主专政具有广泛的民主性和群众基础，能够团结一切可以团结的力量，结成广泛的统一战线，调动一切积极因素，保证社会主义事业胜利发展。 三、论述题 试述 “文化大革命” 结束后，我国社会主义政治制度逐步完善体现在哪些方面。(1) 党的领导制度得到了完善和加强。(2) 人民代表大会制度得到了全面恢复和加强。(3) 共产党领导的多党合作和政治协商制度得到巩固和加强。(4) 国家立法、司法、监督制得到了进一步完善，法制建设得到了明显加强。(5) 进入 90 年代以后，提出了以法治国的治国方略，我国的社会主义民主政治建 设进入了一个稳定又积极的发展阶段。 论述“改革开放”后我国政治体制改革的成果有哪些？(1) 实施国家公务员制度。(2) 加强了社会主义基层民主自治制度建设。(3) 根据高效、精简的原则，进行了行政机构改革。(4) 实现了党政职能分开，调整了党的组织形式和工作机构。(5) 加快人大的立法速度，提出依法治国的方略，建立社会主义法治国家。(6) 调整了中央和地方的政治经济关系，更有利于调动中央和地方的积极性。(7) 废除领导干部终身制，建立了干部的离休制度，实现了干部队伍的年轻化、革命化、专业化、知识化，保持了党和国家的活力。 第 3 章 *当代中国国家形式和国家机构一、选择题 国家形式，主要是指国家政权的组织形式，即 政体。 决定国家形式的根本要素是国家的 政权性质。 国家结构形式主要分为 单一制和复合制(联邦制) 两种形式。 单一制国家 是由若干行政区域组成的单一主权国家，实行统一的中央集权，具 有统一宪法和国籍，全国只有一个立法机关、一个中央政府。 联邦制国家 是复合制国家的主要形式，它是指由共和国、州、省、邦等联邦成 员组成的联邦制国家，它在中央政府和区域政府(联邦成员) 之间划分权力，各自 都拥有某些独立的权力。 中国的国家政权组织形式是 人民代表大会制。 人民代表大会制度就是由选民或代表依照 民主集中制的原则 依法选举代表。 我国的政权组织形式是 民主共和制、人民代表大会制度。 在我国行使国家权力的是 人民代表大会、人大常委会。 决定国家机构性质和形式的是该社会的 经济基础。 政府职能变化 是指国家机构变革的根本依据，而政府职能是由社会需求产生 的。 精简和合理地组织国家机构，提高国家机构工作效率，吸收广大劳动人民参加 国家的管理活动，是社会主义国家机构发展、变革的基本方向和要求。 亚里士多德提出各类政体都具有三个要素，分别是：有关城邦一般公务的 议事机能； 行政机能； 审判(司法)机能。 1982 年宪法规定，中华人民共和国中央军事委员会 领导全国武装力量。 根据中国 1982 年的《宪法》第三章规定，中国国家机构由下列国家机关组成：全国人民代表大会，中华人民共和国主席，国务院，中央军事委员会，地方各级人民代表大会和地方各级人民政府,民族自治地区的自治机关,人民法院和人民检察院共七类。 我国国家机构系统，按其性质和职能可以分为五部分：国家权力机关、国家行 政机关、国家军事机关、国家审判机关 和 国家检察机关。 中国国家权力机关是 全国人民代表大会和地方各级人民代表大会。 中国国家行政机关是 中央人民政府即国务院和地方各级人民政府。 中国国家审判机关是 人民法院。 中国人民检察院 是国家的法律监督机关。 在中国国家机关体系中，国家权力机关 居于首要地位。 中国国家机构设置主要遵循三个原则：国家的一切权力属于人民的原则； 议行 合一的原则； 民主集中制原则。 二、简答题 简述我国国家结构形式的复杂性。(1) 在少数民族聚居的地方，建立民族自治机关，实行区域自治。(2) 在香港、澳门及台湾地区，设立特别行政区。(3) 在一般地方行政区域，设置地方国家机关。 简述国家的一切权力属于人民的原则的含义。国家一切权力属于人民主权的原则，主要是通过实行人民代表大会制度体现出 来的。(1) 我国人民代表大会是由人民或人民代表大会民主选举产生，对人民负责，受 人民监督，代表了全国各族人民的意志和利益；(2) 我国的人民代表大会是国家权力机关，它享有立法以及组织国家机关，对国 家重大问题作出决定等权力。(3) 人民代表大会的权力来自人民，按照人民的利益和意志进行活动，集中人民 的意见和意见对国家重大问题作出决定，并制定各种制度和法律。这就从根本上保 证了国家的一切权力掌握在人民手中。 简述议行合一原则。(1) 议行合一是我国国家机构设置的基本原则之一。在我国，人民代表既是立法 者又是执行者，体现了议行合一原则。(2) 人民代表大会是国家权力机关，统一行使国家权力，如制定法律、决定国家 重大问题、产生其他国家机关等。(3) 各级人民政府必须密切联系群众。在人大开会期间，人民代表要把人民群众 的意见变成国家的法律和决定；在人大闭会期间，人民代表带头并监督执行国家的 法律和决定。 简述党的民主集中制的基本原则是什么？(1) 少数服从多数，下级组织服从上级组织原则；(2) 党的各级领导机关由选举产生原则；(3) 党的最高领导机关，是党的全国代表大会和它所产生的中央委员会。党的地方 各级领导机关，是党的地方各级代表大会和它们所产生的委员会。党的各级委员会 向同级的代表大会负责报告工作；(4) 党组织上下级之间要互通情报、互相支持和互相监督；(5) 党的各级委员会实行集体领导和个人分工负责相结合的制度；(6) 党禁止任何形式的个人崇拜。 三、论述题 试论述我国实行单一制国家结构形式的原因。(1) 我国自秦汉以来，一直采用单一制国家结构形式，它符合我国历史发展趋势和各族人民的共同愿望。(2) 中国是以汉族为主体的多民族国家，平等团结是民族关系发展的主流，各民族间形成了大杂居、小聚居的分布状况，具备采取单一制的民族条件。(3) 我国汉族与少数民族地区在资源、经济发展、人口、文化诸多方面，具有较强的互补性，采用单一制，有利于经济发展。(4) 采用单一制也有利于粉碎西方列强及少数民族败类企图分裂中国的野心，有利于国家的统一和稳定。 第 4 章 当代中国选举制度一、选择题(1) 建国以来我国颁布的《选举法》共有 2 部。 (2) 1953 年 2 月，中央人民政府委员会颁布了新中国第一部选举法 (3) 1979 年通过第二部选举法直接选举人们代表的范围由乡、镇一级扩大至县级。差额选举1953 年中只需出 席过半数 即可通过改为 全体过半数。 (4) 1982 年对第二部选举法做第一次修改(1) 将“人民公社”改为“乡、民族乡”(2) “另行选举”即第一次投票不过半数，则第二次投票只需过 1/3 (5) 1986 年对第二部选举法做第二次修改(1) 选民或代表 10 人以上联名，可推荐代表候选人(2) 取消预选，规定了差额选举的比例（间接选举：1/3-1？直接选举 1/2-1/5） (6) 1995 年对第二部选举法做第三次补充和修改（简答）(1) 将乡、镇选举委员会受县（区）级选举委员会领导改为受县（区）级人大常委会领导。(2) 五倍改为“四倍”(3) 增加了罢免内容，县和乡级人大代表，原选区选民 30 人以上联名可提出，半数通过则可罢免，县级以上，主席团或 1/10 以上代表联名，可对上一级人代会代表提成罢免。 (7) 2004 年修正后的《选举法》规定，原选区选民对县级人大代表提出罢免案必 须有 50 人以上联名。 (8) 平等原则: 选举的 平等原则 首先表现在 “一人一票制” 上 (9) 《选举法》第 2 条规定：“ 不设区的市、市辖区、县、自治县、乡、民族乡、镇的人民代表大会的代表，由选民直接选举。” (10) 在我国县级及县级以下主持直接选举的选举机构是 县、乡两级 选举委员会。 (11) 根据《选举法》规定，直接选举的地方公布选民名单的日期是选举日的 20 日以前。 (12) 《选举法》规定，各级人民代表实行差额选举，由选民直接选举的代表侯选 人名额，应多于应选代表名额 1/3 至 1 倍。 (13) 由选民直接选举的人民代表侯选人，是由各选区选民和各政党、各人民团体 提名荐的，选民 10 人以上联名 就可以推荐代表侯选人。 (14) 在直接选举时，选区全体选民的 过半数 参加投票、选举有效。 (15) 省、自治区、直辖市、设区的市、自治州的 人民代表大会常委委员会 主持本 级人民代表大会代表的选举。 (16) 《宪法》和《选举法》都规定，全国人大代表名额不超过 3000 人，名额的分 配 由全国人民代表大会常委委员会 根据情况分配给各省、自治区、直辖市、人民解 放军、香港特别行政区、澳门特别行政区、台湾省。 (17) 全国人大代表中，少数民族代表的名额，应占全国人大代表总名额的 12% 左 右。人口特少的民族，至少应有全国人大代表 1 人。 (18) 省、自治区、直辖市的代表名额基数为 350 名，省、自治区每 15 万人可以 增加 1 名代表，直辖市每 2.5 万人可以增加 1 名代表； 但是代表总名额不得超过 1000 名。 (19) 如果所提侯选人的人数符合 《选举法》 规定的 多于应选代表名额 1/5 至 1/2 的比例，可以直接进行投票选举。如果所提侯选人的人数超过《选举法》规定的 上述比例，可以进行预选。 (20) 全国人大常委会关于台湾省出席全国人大的代表的选举办法规定：由在各省、自治区、直辖市和中国人民解放军的台湾省籍同胞派代表到 北京 协商选举产生 (21) 特别行政区选举全国人民代表大会代表由 特别行政区组成的人国人民代表 大会代表选举会议 选出。 (22) 对于乡级人民代表大会代表，原选区选民 30 人以上联名，可以向县级的人 大常委会书面提出罢免要求。 (23) 对县级以上人大代表提出罢免案有两种方式：(1) 县级以上地方各级人代会 举行会议时，主席团或者 1/10 以上代表联名，可以提出对由该级人民代表大会选 出的上一级人民代表大会代表的罢免案。(2) 在人民代表大会闭会期间，县级以上 的地方各级人大常委会主任会议或者常委委员会 1/5 以上组成人员联名，可以向常 务委员会提出由该级人民代表大会选出的上一级人民代表大会代表的罢免案。 (24) 罢免由县级以上的地方各级人民代表大会选出的代表，须经各该级人民代表 大会过半数的代表通过，或者须经 该级人大常务委员会组成人员的过半数通过。 二、简答题 2004 年 10 月 27 日十届全国人大常委会第十二次会议对选举法进行了第四次修 正包括：(1) 再度引入预选。1979 年第二部选举法规定县以下直接选举人民代表时可以进 行预选。但 1986 年选举法第二次修正取消预选。2004 年选举法第四次修正再度规 定可以进行预选。(2) 组织候选人与选民见面。修正案规定：“选举委员会可以组织代表候选人与选 民见面，回答选民的问题”。(3) 严惩贿选行为。针对近年来屡次发生的贿选现象，选举法第十章对破坏选举 的制裁进行了修改。(4) 对县级和乡级代表罢免案提出的联名人数作出了不同规定：对于县级人大代 表，原选区选民 50 人以上联名，对于乡级人大代表，原选区选民 30 人以上联名，可以向县级人大常委会书面提出罢免要求。 选举权和被选举权的普遍原则 有选举权和被选举权只受到两个条件的限制：(1) 年龄条件的限制，必须年满 18 周岁才享有选举权和被选举权；(2) 政治条件的限制，被剥夺政治权利的没有选举 权和被选举权。 结合邓小平有关论述说明我国实现直接选举是个逐步实现的过程。(1) 1987 年邓小平在《会见香港特别行政区基本法起草委员会委员时的讲话》中 指出：“大陆在下个世纪，经过半个世纪以后可以实行普选。现在我们县级以上实 行的是间接选举，县级和县以下的基层才是直接选举。因为我们有十亿人口，人民 的文化素质也不够，普遍实行直接选举的条件不成熟。”(2) 直接选举是民主程度更高的体现，但民主的发展是受经济、文化条件制约的，因此直接选举的扩大是一个逐步实现的过程。 秘密投票的原则。(1) 秘无记名投票原则，指选民或代表在投票时秘密填写选票，在选票上只填写自己同意的代表侯选人姓名或在代表侯选人名字上打上规 定的赞成符号、不赞成符号、弃权符号，而不注明投票人自己的姓名，以及选票写 好后，自己亲自投入票箱的投票方法。(2) 实行无记名投票方法，可以最充分地保护选民的民主权利，真正尊重选民的 意愿，让选民在无顾虑、不拘束的环境中行使自己的民主权利，选择他最满意的人。 各级人民代表大会会议期间人大代表的职权：(2) 有权提出议案；(3) 参加本机人民代表大会的各项选举；(4) 向本级有关国家机关提出询问；(1) 参加大会全体会议、代表团全体会议、小组会议，审议议案和报告；(5) 县级以上人大代表可以向本级人民政府及所属各部门、人民法院、人民检察 院提出质询案；(6) 向本级国家行政机关组成人员、人民法院院长、人民检察院院长提出罢免案 等(全国人大代表还可对国家主席、副主席、中央军委组成人员提出罢免案) 。 人民代表履行代表职权时有哪些基本保障。《代表法》规定了人大代表执行职务的保障，主要有：(1) 代表在人民代表大会各种会议上的发言和表决，不受法律追究。(2) 非经本级人大常委会许可，不受逮捕或刑事审判；(3) 一切组织或个人不得阻碍代表依法执行代表职务；(4) 对代表履行职责给予物质和时间等方面的保证。 三、材料分析 《代表法》和《选举法》关于罢免人大代表的有关规定。《代表法》规定人大代表必须模范地遵守宪法和法律，应当与原选区选民或原选举 单位保持密切联第，听取和反映他们的意见和要求，努力为人民服务，并受原选区 选民或原选举单位的监督。选民和原选举单位有权罢免自己选出的代表。郭海领导 的公司损害了原选区选民的利益，表明郭海身为人大代表不能真正代表选民的利 益，不能反映选民的要求，选民有权依法罢免他。 选民罢免人大代表的程序 对直接选举产生的区(县) 人大代表，原选区选民 50 人以上联名，可以向区(县) 人大常委会提出书面罢免要求。西山区有 216 名选民联名提出罢免要求符合法定人 数。区(县) 人大常委会派有关负责人主持，并由选区选民过半数表决通过。 提出罢免案的意义 选民联名提出对人大代表的罢免案，具有重要的意义。(1) 选民对自己的选举权、罢免权有较高的认识，依法予以行使。(2) 对人大代表也是一次教育，使其认识到 当选人大代表后就要代表选民的利益，负起人大代表的责任。选民自觉行使罢免权 有利于我国人大制度的完善。 第 5 章 *当代中国人民代表大会制度(上)一、选择题(1) 1953 年至 1954 年春，全国进行了第一次普选。 (2) 我国的人民代表大会制度体现了 国家一切权力属于人民的根本原则。 (3) 人民行使国家权力的机关是 全国人民代表大会 和 地方各级人民代表大 会。 (4) “中华人民共和国 全国人民代表大会 是最高国家权力机关”。 (5) 全国人民代表大会每届任期 5 年。 (6) 宪法的修改，由全国人大常委会或者 1/5 以上 的全国人大代表提议，并由全 国人民代表大会以全体代表的 2/3 以上 的多数通过。 (7) 我国批准设立特别行政区的机关是 全国人民代表大会。 (8) 《宪法》和《全国人民代表大会组织法》规定，全国人民代表大会会议每年举 行一次，有 2/3 以上的代表出席，始得举行。 (9) 全国人民代表大会会议由 全国人大常委会召集。每届全国人民代表大会第 一次会议，在本届全国人大代表选举完成后的两个月内由上届全国人大常委会召 集。 (10) 预备会议由 全国人大常委会 主持。预备会议选举本次会议的 主席团和秘 书长，通过本次会议的议程和其他准备事项的决定。 (11) 全国人民代表大会全体会议，由本次会议 主席团 主持。 (12) 一般法律议案由 全国人民代表大会主席团、全国人大常委会、全国人大专 门委员会、国务院、中央事委员会、最高人民检察院、1 个代表团、30 名以上代表 提出。 (13) 我国宪法规定，全国人大常委会委员长、副委员长、秘书长、委员的人选，中华人民共和国主席、副主席人选，中央军事委员会主席的人选，最高人民法院院 长和最高人民检察院检察长的人选，由 主席团 提名。 (14) 国务院总理由中华人民共和国主席提名，国务院副总理、国务院其他组成人 员的人选由国务院总理提名。 (15) 中央军事委员会除主席以外的其他组成人员的人选，由 中央军事委员会主 席提名。 (16) 全国人大常委会是 全国人大的常设机构，是全国人大的一部分，是经常行 使国家权力的机关，是国家立法机关。 (17) 全国人大常委会会议，一般 两个月 举行一次。 (18) 全国人民代表大会的职权：立法权、决定权、任免权、监督权 (19) 全国人大常委会的职权：立法权、决定权、任免权、监督权、行使全国人民 代表大会授予的其他职权 (20) 宣布全国进入战争状态或个别省、自治区、直辖市进入紧急状态的权力归 国 家主席。 (21) 有权撤销与宪法、法律、行政法规相抵触的省级地方性法规的是 全国人大 常委会。 (22) 《宪法》第 68 条规定全国人大常委委员会的 委员长、副委员长、秘书长 组成 委员长会议，处理全国人大常委会的重要日常工作。 (23) 全国人大常委会的委员长会议是 委员长主持常委会工作的一种工作机构。 (24) 宪法规定，全国人大常委会是合议制机关，实行集体讨论、集体决定的集体 领导制度。 (25) 有权向全国人大常委会提出属于常委会职权范围内议案的有：委员长会议；国务院、中央军委、最高人民法院、最高人民检察院；全国人大各专门委员会；常 委会组成人员 10 人以上联名。 (26) 全国人大常委会通过的法律，由 中华人民共和国主席签署主席令予以公 布。 (27) 在全国人大常委会会议期间，常委会组成人员 10 人以上联名，可以向常委 会书面提出对 国务院及国务院各部、各委员会和最高人民法院，最高人民检察院 的质询案。 (28) 全国人大常委会机构：代表资格审查委员会、办公厅、工作委员会。 (29) 《宪法》第 70 条和《人国人民代表大会组织法》规定，全国人民代表大会设 立民族委员会、法律委员会、财政经济委员会、教育科学文化卫生委员会、外事委 员会、华侨委员会和全国人大认为需要设立的其他专门委员会。 (30) 各各专门委员会的工作职责是在 全国人大及其常委会领导下，研究，审议 和拟订有关议案。 二、简答题 简述通过宪法修正案的程序。(1) 修改宪法议案由全国人大常委会或者 1/5 以上全国人大代表提议。(2) 经全国人代会和有关的专门委员会审议，并向主席团提出审议结果报告和修 改稿。(3) 宪法修正案由全国人大全体代表的 2/3 多数通过并由全国人大公告进行发 布。 简述我国人大常务委员会的组成和产生方式。(1) 全国人大常委会是全国人大的常设机构。组成人员有委员长、副委员长若干 人、秘书长及委员若干人。(2) 全国人大常委会委员由全国人大从代表中选举产生，委员人选由人大会议主 席团提名，经各代表团酝酿协商后，再由主席团根据多数代表团的意见确定正式侯 选人名单，交大会选举。(3) 获得全国人民代表大会全体代表过半数的选票始得当选。 《中华人民共和国立法法》对人国人大常委会的立法程序作出了如下规定：(1) 要经有关专门委员会审议和法律委员会统一审议。(2) 要听取和征求意见。(3) 列入全国人大常委会会议议程的法律草案，一般应当经三次常委会会议审议 (即三审) 后再交付表决。 全国人大、全国人大常委会、国务院三者的职能怎么区别？ 都是国家机构。(1) 全国人大是最高国家权利机关，是行使国家立法权的机关。(2) 国务院是最高国家权利机关的执行机关，是最高行政机关，对全国人大及其 常委会负责并报告工作。(3) 人大常委在全国人大休会期间代替全国人大处理事物，对全国人大负责并报 告工作 全国人民代表大会的地位、组成、任期、职权(1) 法律地位：a. 全国人民代表大会统一行使国家权力，它在国家权力机关中处于最高地位。b. 中央其他国家机关如兴致机关、审判机关、检察机关都由人民代表大会产生，受它监督，对它负责。(2) 代表的组成：省、市、自治区、特别行政区(港澳台) 、解放军(3) 四大职权：立法、决定、任免、监督 a. 任免权：由主席提名，决定国务院总理人选 b. 监督权：工作监督和法律监督。 听一府两院的报告 质询和询问。 任免代表大会选举或决定的其他国家机关的领导人 审查执行报告，审查国家预 算。 全国人民代表大会常务委员会(1) 含义：全国人民代表大会常务委员会是常设机构，对全国人大负责并报告工作。闭会期间，其他国家机关：一府两院、中央军委主席也要对全国人大常委会负 责。(2) 人员组成：委员章，副委员长若干人，秘书章，委员若干人、适当少数民族 代表。(3) 五大职权 a. 国家法权：解释宪法和法律。 国家某些重大事项的决定权。(与第七章内容重叠) 人事决定和任免权：根据最高人民法院院长的提请，任免最高人民法院副院 长。批准省、自治区、直辖市的人民检察院检察长的任免。 监督权 其他职权(无重点) 第 6 章 *当代中国人民代表大会制度(下)一、选择题(1) 地方各级人民代表大会是当代中国 地方各级国家权力机关。 (2) 拥有地方立法权的有：省、自治区、直辖市的人大、省级政府所在地的市的 人大、经国务院批准的较大的市的人大。 (3) 省级人大制定的地方性法规应 不能同宪法、法律和行政法规相低触、报 全国人大常委会备案、报国务院备案。 (4) 县级以上行政区域内的国民经济和社会发展计划的审查与批准权在 同级人大。 (5) 省级人代会选举产生的省人民检察院检察长须得到 全国人大常委会的批准。 (6) 县级以上地方人大代表 10 人以上联名，可以向本级人大提出属于 本级人大职 权范围内的议案。 (7) 县级人大代表 10 人以上书面联名，可以提出 本级人大常委会组成人员、人民 政府领导人员、人民法院院长、人民检察院检察长的侯选人。 (8) 人大常委会副主任，人民政府副职领导人员的侯选人数应比应选人数多 1-3 人，人大常委会委员的侯选人数应比应选人数多 1/10 至 1/5，由本级人民代表大会 根据应选人数在选举办法中规定具体差额数，进行差额选举。 (9) 县级以上地方各级人大换届选举本级国家机关领导人员时，提名、酝酿侯选 人的时间不得少于 两天。 (10) 县级人大常委会由本级人大在代表中选举 主任、副主任 若干人、委员 若干人 组成。县级人大常委会不设秘书长。 (11) 县级以上地方各级人大常委会的组成成员不得担任 国家行政机关、审判机关 和 检察机关 的职务。 (12) 在省人代会闭会期间，省人大常委会有权撤销 个别副省长的职务。 (13) 决定省级人民政府秘书长、厅长、局长、委员会主任任免的机构是 省级人大 常委会。 (14) 决定省人民政府代省长人选的权力归 省人大常委委员会。 (15) 省级人民政府组成部门行政道长的任免权归省人民代表大公常务委员会。 (16) 县级以上地方各级人大常委会主任会议，人民政府，人民代表大会各专门委 员会，省、自治区、直辖市、自治州、设区的市的人大常委会组成人员 5 人以上联 名，县级人大常委会组成人员 3 人以上联名，可以向本级人大常委会提出属于常委 会职权范围内的议案。 (17) 县级以上地方各级人大常委会机构：代表资格审查委员会； 综合办事机构； 工作机构； 省、自治区人大常委会根据工作需要可以在地区设立工作机构。 (18) 我国《宪法》及《地方组织法》规定：乡、民族乡、镇设立人民代表大会。组成人民代表大会的代表由 选民直接 选举产生。 (19) 乡级人民代表大会是我国 最基层的国家权力机关，它直接代表各选区选民 行使国家权力，并由它产生乡、镇人民政府，乡、镇人民政府是它的执行机关，向 它负责，受它监督。 (20) 2004 年《地方组织法》进行第四次修正，规定地方各级人大每届任期 5 年。 (21) 目前我国乡长、镇长的任免权在 乡、镇人民代表大会。 (22) 乡级人大的工作机构有 ：乡级人民代表大会主席团，人民代表大会主席、副 主席，代表资格审查委员会。 二、简答题 县级以上地方人民代表大会会议主要内容是：(1) 听取和审议本级人民政府、人民法院、人民检察院的工作报告；(2) 提出和审议、表决议案；(3) 选举本级人大常委会组成人员，决定和选举本级人民政府、人民法院、人民 检察院领导人；(4) 向本级人大及常委会提出工作方面的建议、批准和意见；(5) 提出对本级人大常委会组成人员、人民政府组成人员、人民法院院长、人民 检察院检察长的罢免案；(6) 提出对本级人民政府、人民法院、人民检察院的质询案和询问。 《地方组织法》规定，乡级人大主席、副主席的职责是：(1) 在本级人民代表大会会闭会期间负责联系本级人民代表大会代表，组织代表 开展活动；(2) 反映代表和群众对本级人民政府工作的建议、批评和意见。《地方 组织法》规定乡级人大主席和副主席不是乡级人大主席团的主席、副主席，组织法 规定他们为主席团人员，因此不能行使人大主席团的职责，如不能主持本级人代会；不能负责召集下一次的本级人代会。他们也无权代表乡级人民代表大会行使乡级人 大的 13 项职权。 改革开放以来，人民代表大会制度得到了加强和完善，1982 年制定的《宪法》 及其修正案和多次修改的选举法、组织法等，对健全人民代表大会制度作出了一系 列新的重要规定。主要有：(1) 改进和完善了选举制度，把直接选举扩大到县级，把等额选举改为差额选举，还可以进行预选。政党、人民团体和选民或代表联合都可以依法提出侯选人。(2) 扩大全国人大常委会的职权并增设了人大专门委员会。(3) 规定县级以上地方各级人大设立常委会。(4) 规定省、自治区、直辖市人大及其常委会，省、自治区、直辖市人民政府所 在地的市和经国务院批准的较大的市的人大及其常委会，可以制定地方性法规。(5) 改变农村人民公社政社合一的体制，设立乡政权，并设立乡镇人大主席等。 三、论述题 试述如何进一步加强和完善人民代表大会制度。(1) 提高对人民代表大会制度的认识，自觉地维护国家的这一根本制度。(2) 加强人民代表大会立法和执法监督职权，全国人民代表大会及其常委会，省级地方人大及其常委会和经国务院批准的较大的市人大及其常委会具有立法权，可 以制定全国性法律或地方性法规。(3) 健全监督机制，加强国家监督(4) 加强国家权力机关的组织制度建设。(5) 加强和改善党对人大的领导。坚持和完善人民代表大会制度必须依靠党的领 导，必须加强和完善党的领导。要在坚持党的领导的前提下充分发挥人大的作 用。 第五章 当代中国人民代表大会制度（上）人民代表大会是当代中国的政权组织形式和根本政治制度。 第一节 人民代表大会制度是当代中国的根本政治制度一、人民代表大会制度的确立 人民代表大会制度就是由选民或代表依照民主集中制原则依法选举代表，组成全国及地方各级权力机关体系即全国及地方各级人民代表大会，通过国际权力机关组织其他国家机构，行使人民当家作主的权力。 人大制度是在中国人民长期革命斗争中产生和发展起来的。 31 年 成立中华苏维埃共和国 执委会 34 年 人民委员会 执行机关 49 年 《共同纲领》人民代表大会由人民用普选方法产生。 53 年 普选（第一次） 54 年 人大一次会议召开 五年一次 二、人民代表大会制度是中国的根本政治制度（简答） (1) 我国的人民代表大会制度是与我国人民民主转正的国家制度相适合的政权组织形式。体现了人民民主专政国家一切权力属于人民的根本原则和核心内容，也体现了人民管理国家事事务的权利的实现。(2) 我国的人民代表大会制度具有深厚的群众基础和广泛的代表性，从政治上和组织上保证全体人民掌握国家权力，真正成为国家的主人。(3) 我国的人民代表大会根据议行合一的原则设置国家机关，可以有效地保证国家权力机关的决定得到迅速执行，人民的意志得到有效实现。 第二节 全国人民代表大会一、全国人民代表大会的地位、组成、任期、职权 法律地位：1. 全国人民代表大会统一行使国家权力，它在国家权力机关中处于最高地位。 2. 中央其他国家机关如行政机关、审判机关、检察机关都由人民代表大会产生，受它监督，对它负责。 代表的组成：省、市、自治区、特别行政区（港澳台）、解放军 四大职权：立法、决定、任免、监督 （详见书 P68-69） 任免权： 由主席提名，决定国务院总理人选 监督权：工作监督和法律监督。 听一府两院的报告 质询和询问。 爸妈任免代表大会选举或决定的其他国家机关的领导人 审查执行报告，审查国家预算。 二、全国人民代表大会会议 每年举行一次，有 2/3 以上的代表出席，才能举行。若有必要，或有 1/5 以上的全国人大代表提议，可以召开临时会议。 召开程序详见书 P70-71 选择 主席团是临时性机构 第三节 全国人民代表大会常务委员会全国人民代表大会常务委员会是常设机构，对全国人大负责并报告工作。 闭会期间，其他国家机关：一府两院、中央军委主席也要对全国人大常委会负责。 人员组成：委员章，副委员长若干人，秘书章，委员若干人、适当少数民族代表。 五大职权(1) 国家法权：解释宪法和法律。(2) 国家某些重大事项的决定权。（与第七章内容重叠）(3) 人事决(武汉自考)定和任免权：根据最高人民法院院长的提请，任免最高人民法院副院长。 批准省、自治区、直辖市的人民检察院检察长的任免。(4) 监督权(5) 其他职权（无重点） 二、全国人大常委会的会议制度和工作程序 委员长会议是委员长主持常委会工作的一种工作方式，不是一级国家权力机关，不能代替人大常委会行使职权。全国人大常委会是合议制机关，实行即讨论几天决定的集体领导制度。两个月举行一次，常委会组成人员 10 人以上联名。 全国人大常委会生意法律草案实行三审制。 P78 质询需 10 人以上联名。 三、全国人大常委会机构 （多选） 代表资格审查委员会： 必要时可组织特定问题调查委员会（临时性组织） 办公厅 ：性质：日常工作的机构，由全国人大常委会秘书长领导 工作委员会：组成人员不限于人民代表。 第四节 全国人民代表大会专门委员会二、工作职责 概括为提案、审议、调研三项。（详见 P82-83） 第六章 当代中国人民代表大会制度（下）第一节 地方各级人民代表大会一、地方各级人民代表大会的地位、组成、任期、职权 地位：规定省、自治区、直辖市、自治州、县、自治县、市、市辖区、乡、民族乡、镇设立人民代表大会。 乡、民族乡、镇每届任期三年，其余为五年。 省、自治区、直辖市的人大可制定地方性法规。15 项职权可归纳为五方面：保证权、决定权、任免权、监督权、保护权。 二、地方各级人民代表大会会议和工作程序(1) 每年至少举行一次。(2) 县级以上人大每次会议举行预备会议。（县级以下无人大常委会）(3) 本级人代会议主席团、常委会、各专门委员会、本级人民政府可提案；县级以上地方人大代表 10 人以上联名，乡、镇 5 人以上联名。（国家是 30 以上联名） 第二节 县级以上地方各级人大常委会一、县级以上地方各级人大常委会的地位、组成、任期、职权(1) 名额：省、自治区、直辖市 35 人至 65 人，人口超过 8 千万的省不超过 85 人，设区的市、自治州 13 人至 35 人，人口超过 8 百万的设区的市不超过 45 人，县、自治、不设区的市、市辖区 11 人至 23 人。（历届考过）(2) 县级以上地方人大，每届任期 5 年。(3) 省、自治区、直辖市和省级人民政府所在地的市、较大城市的人大常委会可以制定和颁布地方性法规。（选择） 二、县级以上地方各级人大常委会的会议和工作程序 设区的市人大常委会主人会议由本级人大常委会主任、副主任和秘书长组成。 县级人大常委会主任会议由本级人大常委会主任、副主任组成。 提案：县级以上，提案 5 人以上联名。县级，3 人以上联名。 质询：县级以上，5 人联名，县级，3 人联名 三、县级以上地方各级人大常委会机构多选）详见书 P93 第三节 方各级人大专门委员会一、地方人民代表大会专门委员会 县级人大不设类似政法财经等专门委员会，但可以成立特定问题调查委员会。 二、专委会职责（不需记忆，知道全国人大的即可） 专委会的性质是常设机构 第四节 坚持和晚上人民代表大会制度 （重点）一、人民代表大会制度和西方议会制的主要区别 产生的社会历史条件不同 资产阶级意会产生于封建社会末期资产阶级革命过程中。中国的人民代表大会是在中国人民长期斗争中产生和发展起来的。 法律地位不同 西方：议会作为三权分立中的立法机关，行使国家立法权。 我国：人民代表大会作为国家权力机关，同意行使国家权力，且具有唯一性和最高性。 与政党关系不同 中国共产党是执政党，任何别的政党都不能代替中国共产党的执政地位，因此(武汉自考)在中国不存在通过竞选各党轮流执政的问题。在中国只有执政党和参政党的区别，没有执政党和反对党的区别。 西方国家政党与议会的关系，主要是通过议会选举来确立的。划分为执政党和在野党。 人民代表和议员的区别 1）选举方式：西方国家议员大多通过竞选产生，而我国人民代表是按民主集中制原则通过差额选举产生。 2）阶级基础：我国：具有深厚的群众基础和广泛的代表性； 西方：行使上是代表选民的，但实质并不代表它是选民的代表。，议员是转职的，另外从代表性上来看，美英等国议员代表的是不同的利益集团。（阿尔蒙德提出） 组织行使、组织机构不同 1）议会体制有一院制（中国）、两院制（欧美）等。 2） 西方议会由议员、议长、委员会、议会党团、工作机构、国家元首组成。 二、加强人民代表大会制度，发展社会主义民主政治。 社会主义的本质是人民当家作主。 人民代表大会值得得到了加强和完善？（简答） 详见书 P103 页，共五点 建设社会主义民主政治，最重要的是坚持和完善人民代表大会制度。（选择） 如何进一步坚持和完善人民代表大会制度，充分发挥这一制度的优势和作用？（论述） 详见书 P104-105 第 7 章 当代中国国家元道制度一、选择题(1) 国家元首是 整个国家机关的一个组成部分，它的设立由宪法予以规定。 (2) 由于人民通过选举团选举产生国家元首的共和制政体国家是 美国。 (3) 议会制国家，如英国、德国等，既有国家元首，又有政府首脑，国家元首不 兼任政府首脑，因此只行使国家元首的职权，不行使国家行政权。议会制总统制国 家，如法国、俄罗斯等，总统是国家元首，不是政府首脑，但行使大部分国家行政 权，并有权通过议会任命政府首脑，掌握主要国家权力。 (4) 建国初期由 中央人民政府委员会 集体行使国家元道职权。 (5) 1954 年《宪法》 规定设置国家主席。 (6) 根据 1954 年《宪法》设置国家主席的规定，1959 年第二届全国人民代表大会 第一次会议选举 刘少奇 为中华人民共和国第二任国家主席。 (7) 1975 年和 1978 年《宪法》 规定不设置国家主席。 (8) 1982 年 2 月 第五届全国人民代表大会第五次会议通过 《宪法》，恢复设立 国家主席。 (9) 1982 年《宪法》规定国家主席侯选人次格为：有选举权和被选举权的 年满 45 周岁 的中华人民共和国公民。 (10) 1982 年 《宪法》 规定中国国家主席、副主席由全国人民代表大会主席团提名， 全国人民代表大会 选举产生。 (11) 中华人民共和国主席和副主席都缺位的时候，由全国人民代表大会补选；在 补选以前，由 全国人大常委会委员长 暂时代理主席的职位。 (12) 中华人民共和国国家主席是 独立的国家机构，它在整个国家机构中的地位 是：它代表中华人民共和国；由 全国人民代表大会 选举产生，全国人民代表大会有 权罢免； 根据全国人民代表大会及其常委会的决定行使职权。在国家机构的排列上，排在全国人民代表大会之后，国务院之前。 (13) 国家主席对内方面职权有：① 公布法律； ② 任免国务院总理和国务院其他 组成人员； ③ 授予国家的勋章和荣誉称号； ④ 发布特赦令； ⑤ 宣布进入紧急状 态； ⑥ 宣布战争状态； ⑦ 发布动员令。 (14) 在我国是全国人大及其常委会行使立法权，即提出法律草案，讨论和表决通 过法律，最后由 国家主席予 以公布。 (15) 全国人民代表大会在决定国家行政机关领导人和组成人员时，必须由 国家 主席 来提名和任免总理人选。 (16) 授予国家的勋章和荣誉称号的职权属于 国家主席。 (17) 现行宪法规定：全国人大常委会可以决定全国或者个别省、自治区、直辖市 进入紧急状态，并由 国家主席 宣布。 (18) 国家主席 根据全国人大及其常委会的决定宣布战争状态。 二、简答 目前世界各国国家元首的法律地位有三种重要类型：(1) 总统制国家，国家元首兼任政府首脑。如美国。(2) 议会制国家，既有国家元首，又有政府首脑，国家元首是“虚位元首”。如英、德。(3) 议会制总统制国家，总统是国家元首，不是政府首脑。如法、俄。( 国家元首有单一元首和集体元首 ) 简述国家领导职务实行任期制和限任制的意义(1) 可以避免终身制的产生，防止由于终身制而带来的各种弊端。(2) 可以防止因领导职务终身制而可能造成的国家干部队伍老化和缺乏活力，防 止出现因长期居于同一领导职位而可能出现的个人专断和个人崇拜。(3) 可以充分保证国家领导人以健康的身体、充沛的精力，适应繁重的领导工作，也有利于国家领导人注意培养新一代的接班人解决好国家领导人员的顺利接班问题，防止出现领导层的“断裂”而带来的政治、经济、社会的不稳定，保证了国家 的长治久安。(4) 实行限任制也是国家政治制度民主化、法制化的要求。 《宪法》规定国家主席行使下列对外方面的职权：(1) 代表中华人民共和国，进行国事活动。中华人民共和国元道是国家的代表，因此他可应邀出访其他国家，有权邀请外国国家元首来访，接受外国使节。(2) 根据全国人大常委会的决定，派遣和召回驻外全权代表。(3) 根据全国人大常委会的决定，批准和废除同外国缔结的条约和重要协定。 第 8 章 *当代中国中央行政制度一、选择题(1) 国家行政的性质是 执行性活动。 (2) 按照 1982 年制定的现行《宪法》规定，国务院由 总理、副总理若干人、国务 委员若干人、各部部长、各委员会主 任、审计会 和 秘书长 组成。 (3) 任命国务院组成人员的是 国家主席。 (4) 国务院其他成员均根据 国务院总理 提名，经全国人民代表大会全体代表过 半数通过决定，由国家主席任命。 (5) 国务院每届的任期同全国人民代表大会的任期一样，都是五年，总理、副总理、国务委员连续任职不得超过十年。 (6) 国务院的职权： ① 立法权 ② 提案权 ③ 领导权 ④ 监督权 ⑤ 人事权 ⑥ 决定紧急状态权 ⑦ 其他权力 (7) 国务院需要根据宪法和法律的规定以及全国人民代表大会及其常务委员会的 授权制定 行政法规。 (8) 国务院根据全国人民代表大会及其常务委员会的授权决定制定的行政法规，称 “暂行条例” 或者“暂行规定”。 (9) 规定中央和省、自治区、直辖市的国家行政机关职权的具体划分，属于国务院的领导权。 (10) 各部、各委员会工作中方针、政策、计划和重大行政措施，应向国务院请示 报告，由 国务院 决定。 (11) 1988 年进行的机构改革主要着眼点就在于 转变职能，按照加强宏观管理和 减少直接控制的原则，划清职责范围，然后再定机构、定人员、定编制。 (12) 中国人民银行属于国务院的 组成机构。 (13) 2003 年十届人大三次会议通过的国务院机构改革方案中规定设立的国务院直 属特设机构是 国有资产监督管理委员会。 (14) 国务院直属机构不是国务院的组成机构，其设立、撤销、合并，由 国务院常务会议 决定。 (15) 国务院中协助总理办理专门事项，直接向总理负责，并无独立行政管理权的 机构统称为国务院 办事机构。 (16) 国家环保总局是国务院的 直属机构。 (17) 国务院办公厅是国务院下设的一个工作机构，由国务院 秘书长 领导。 (18) 首长负责制贯穿着 民主集中制、法制 和 对国家权力机关负责 三项重要原则。 (19) 2007 年 4 月 5 日公布的《中华人民共和国政府信息公开条例》施行日期是 2008 年 5 月 1 日。 二、简答题 简述国务院的法律地位① 国务院是最高国家权力机关的执行机关。(1) 国务院由全国人大组织产生；(2) 国务院接受全国人大及其常委会的监督(3) 国务院对全国人大及其常委会负责并报告工作② 国务院是最高国家行政机关(1) 国务院负责统一领导全国的经济、政治、社会、文化等行政工作；(2) 国务院统一领导各职能机构、直属机构和办事机构的工作；(3) 国务院规定中央和省级行政机关的职权划分统一领导地方各级行政机关的工 作；(4) 国务院制定的行政法规，发布的决定和命令对全国各级行政机关具有普遍的 约束。 简述国务院提案权的内容。国务院有权向全国人民代表大会或者全国人民代表大会常务委员会提出议案，这种提案经由立法机关的法定程序，转化为国家的法律、法令。国务院有权建议国 家权力机关：(1) 制定或修改法律； (2) 增设或撤销行政机构； (3) 任免国务院部分组成人员； (4) 通过国民经济和社会发展计划及其执行情况的报告，通过国家预算及其执行 情况的报告。 ( 08-4 ) 政府正从以下三个方面着手转变职能：(1) 依法界定政府的管理职能。逐步理顺政府与企业、政府与市场、政府与社会 的关系，把政府不该管的事情逐步交给企业、市场和社会。(2) 深化行政审批制度改革，完善审批方式，加强后续监管，建立科学合理的行 政管理和监控机制。(3) 加强社会管理和公共服务。逐步健全和完善公共政策和公共服务体系，加大 财政对教育、科技、文化、卫生等社会事业的支持力度，积极稳妥地推进部分共产 品和服务的市场化进程。 总理负责制的具体内容包括(1) 全面领导权。总理对国务院工作拥有全面领导权。(2) 最后决定权。国务院工作中的重大问题在充分讨论的基础之上，由总理集中 正确意见，并作出最后决定。(3) 人事提名权。总理有权向全国人民代表大会及其常务会提名副总理、国务委 员、各部部长、各委员会主任、审计长、秘书长的任免人选。(4) 总理对国务院工作全面负责。 三、论述题：国务院会议制度 国务院会议由国务院全体会议和常务会议构成。 (1) 国务院全体会议。由总理、副总理、国务委员、各部部长、各委员会主任、人民银行行长、审计 长、秘书长组成，由问题召集和主持。国务院全体会议的主要任务是：① 讨论决定国务院工作中的重大事项； ② 部 署国务院的重要工作； ③ 通报国内外形势。国务院全体会议一般每半年召开一次，根据需要可安排有关部门、单位负责人列席会议。 (2) 国务院常务会议，由总理、副总理、国务委员、秘书长组成，由总理召集和 主持。国务院常务会议的主要任务是：① 讨论决定国务院工作中的重要事项；② 讨论 法律草案、审议行政法规草案；③ 通报和讨论国务院其他事项。国务院常务会议一 般每月召开三次，如有需要可临时召开。根据需要可安排有关部门、单位负责人列 席会议。 (3) 根据工作需要不定期召开的总理办公会议，是由总理或总理委托副总理召开 并主持，研究处理国务院日常工作中的主要问题。 第 9 章 *当代中国一般地方行政制度一、选择题 县、自治县、不设区的市、市辖区的人民政府分别由 县长、副县长，市长、副 区长和局长、科长等组成。 新一届人民政府领导人员依法产生后，应当在 两个月内 提请本级人民代表大 会常务委员会任命人民政府秘书长、厅长、局长、委员会主任、科长。 1993 年八届人大在通过的 《宪法修正案》 将地方政府任期由 3 年改为 5 年的是 县 级政府。 目前我国乡、民族乡、镇人民政府每届的任期为 5 年。 36. 地方政府的权力来源于 《宪法》、《地方组织法》等有关的法律、法规。 按现行 《宪法》 规定，制令权、执行权、管理权属于地方政府的权力，不包括 赦免权。 地方政府职权的规定，省、自治区、直辖市人民政府的职权有：(1) 执行权；(2) 地方行政立法和制令权；(3) 管理权；(4) 领导与监督权；(5) 保障权； 关于乡、民族乡、镇的建置的决定权和区域划分权。 我国现行宪法规定，乡、民族乡、镇的建置的决定权和区域划分权只授予 省、直辖市人民政府。 县、自治县的人民政府 在必须的时候、经省自治区、直辖市的人民政府批准，可以设立若干区公所，作为它的派出机关。 最能体现地方政府运作的三种会议是：政府会议、政府行政会议、政府扩大会 议。 政府行政会议 又叫“行政首长办公会议”，是指县级以上地方行政首长为处 理日常工作，召集本级政府有关成员出席，并邀请有其他人士列席的会议。 《中共中央、国务院关于在全国乡镇政权机关全面推行政务公开制度的通知》 规定了推行政务公开制度的基本原则是：(1) 依法公开。(2) 真实公开。(3) 注重 实效。(4) 有利监督。 就其实质而言，中央和地方关系是建立在一定利益基础之上的国家利益和地方 利益之间的一种利益分配关系，其核心是 中央政府代表的国家利益和地方政府代表 的地方利益两者之间的利益均衡问题，在现实中，往往表现为集权和分权关系。 中央与普通行政区域关系模式，具有主导性，是我国中央和地方关系的基本模 式。 我国中央政府处于核心地位。中央和地方之间是一种 领导和被领导 关系。 财政关系 是中央和地方的经济关系的核心内容。 中央与地方财政关系上 1994 年 1 月 1 日起在全国范围内全面推行 分税制财政 管理体制。 1994 年 全面推行税制后，中央与地方共享税包括：增值税，资源税，证券交易 税。 近年来改革和调整中央与地方关系一个突出的做法是监管和执法机构的 垂直 管理。 二、简答题 简述我国地方各级人民政府实行的行政首长负责制。我国的地方各级人民政府实行行政首长负责制，就是明确各级行政首长在本级人民 政府的全部工作中负有“三权一责”，即：(1) 全面领导权。行政首长对本级人民政府的工作负有全面领导权，副职协助其 进行工作，或受其委托分管某一方面的工作。(2) 最后决定权。行政首长召集并主持本级人民政府的常务会议或全体会议，并 在会议集体讨论的基础之上，集中正确的意见，对政府工作中的重大问题，作最后 决定。(3) 人事提名权。行政首长就本级人民政府的秘书长、厅长、局长、主任、科长 的任免，有权向本级人民代表大会常务委员会提名。(4) 行政首长负全面责任。行政首长对本级人民政府的工作全面负责，以本级人 民政府的名义向本级人民代表大会及其常务委员会提出的议案，向上级人民政府提 出的请示、报告，向下级人民政府发出的指示、指令等，均应由本级人民政府行政 首长签署。 中央政府和地方政府关系的基本原则(1) 利益原则和法制原则。(2) 发挥两个积极性的原则。(3) 应当明确中央与地方的权力和责任原则。 简述停改革开放以来中央与地方关系的重大变迁。(1) 中央对地方的“放权让利”，强化了地方政府的主体意识，调动了其建设地方 的积极性。(2) 缺乏规范化的放权让利和地方财政包干体制，衍生了地方本位主义，削弱了 中央政府的领导权威，导致中央与地方关系新的失衡。 三、论述题 试述我国地方各级人民政府具有双重性质。(1) 一方面，作为地方各级国家权力机关的执行机关，地方各级人民政府从 属于本级国家权力机关。它由本级人民代表大会产生，执行本级人民代表大会及其 常务委员会的决议，对本级人民代表大会负责并报告工作，接受其监督。(2) 另一方面，作为地方各级国家行政机关，地方各级人民政府除了对本级 国家权力机关负责外，还要对上一级国家行政机关负责并报告工作，这是我国单一 制的国家行政结构决定的。同时，地方政府是整个国家行政机关的从属部分，下级 政府必须接受上级政府的决议和命令。全国地方各级人民政府都是国务院统一领导 下的地方国家行政机关，都要服从国务院。 试述从建设服务型政府的角度看，县乡政府在新农村奸商中的职能包括哪三个 方面。(1) 为新农村建设提供基本的公共管理服务，包括为国家机器正常运转所提 供的管理服务，以确保县域社会经济运行的协调有序。这是县乡政府的基本职能，也是开展社会主义新农村建设的必要条件。(2) 落实中央提出的扩大公共财政覆盖农村范围的目标，促进县域范围内的 公共事业的发展。一方面，为辖区内农民提供教育、卫生、环保等公共产品和服务；另一方面，完善农村优抚、救济、救灾等社会保障体系，在有条件的地方建立农村 最低生活保障和养老、医疗失业保障制度，创建和谐有序的社会氛围。(3) 把握辖区的社会经济走向，特别是区域的比较优势及其变化，并通过制 订新农村建设规划和提供政策指导，为区域比较优势的发挥作出应有的贡献。 第 10 章 *当代中国民族区域自治制度一、选择题(1) 当代中国依然存在民族问题，但它基本上是 各族人民在根本利益一致基础上 的具体内部矛盾。 (2) 社会主义中国处理民族问题的基本原则是 坚持民族平等，加强民族团结，实 现各民族的共同繁荣。 (3) 马克思主义赋予民族平等以崭新的内容，指出民族平等首选指 各民族政治权 利和社会地位上的平等。 (4) 民族团结 是社会主义国家各族人民的最高利益。 (5) 马克思主义经曲作家曾经提出过两项解决民族问题的基本政策，即 民族自决权 和 民族区域自治政策。 (6) 列宁 最早提出民族区域自治思想。 (7) 民族区域自治制度 是马克思列宁主义与中国多元统一的民族格局相结合的产 物。 (8) 民族自治地方的区域界线一经确定，不得轻易变动；需要变动的时候，由 上级国家机关的有关部门 和 民族自治地方的自治机关 充分协商拟定，报国务院批 准。 (9) 1947 年，在中国共产党领导下，已经解放的中国蒙古族聚居地区建立 了中国 第一个省级民族自治地方——内蒙古自治区。 (10) 民族自治地方的人民代表大会有权依照当地民族的政治、经济和文化的特点，制定自治条例和单行条例。 二、简答 民族区域自治制度的特点：(1) 不具有独立性，中央统一领导。(2) 遵守国家根本大法，执行国家政策。(3) 人民民主专政在少数民族地区有具体形式。(4) 自治机关和地方自治结合。(5) 以少数民族聚居地为基础建立，区域自治制度。 中国民族区域自治政策制定的客观依据(1) 我国是统一的多民族国家 (2) 我国各民族具有大杂居小聚居的特点 (3) 历史上各民族就和睦相处 , 彼此产生深厚感情 我国采取民族区域自治政策的原因。(1) 我国自古以来就是一个统一的多民族国家；(2) 在中国，汉族和其他少数民族的关系从来不是一种殖民关系；(3) 在国际上还存在着民族分裂主义和其他敌对势力；(4) 中国历史上长期以来实行中央集权制度；(5) 中国的社会主义事业需要建立一个统一的多民族国家。 简述民族自治地方的自治机关的任务。(1) 必须维护国家的统一，保证宪法和法律在本地方的遵守和执行。(2) 领导各族人民集中力量进行社会主义现代化建设。(3) 要把国家的整体利益放在首位，积极完成上级国家机关交给的各项任务。(4) 维护和发展各民族的平等、团结、互助的社会主义民族关系，禁止对任何民 族的歧视和压迫，禁止破坏民族团结和制造民族分裂的行为。(5) 保障本地方各民族都有使用和发展自己的语言文字的自由，都有保持或者改 革自己的风俗习惯的自由。(6) 保障各民族公民有宗教信仰自由。 三、论述题 民族区域自治的优越性。(1) 民族区域自治制度的实施保障少数民族当家作主，管理本民族事务的权利。(2) 民族区域自治制度的实施，有利于发展社会主义民族关系。(3) 民族区域自治制度的实施，有利于国家的统一。国家的统一，是全国各民族 人民的共同愿望和根本利益，也是我们社会主义现代化建设事业取得胜利的根本保 证。(4) 民族区域自治制度的实施，有利于促进民族自治地方和社会主义事业的发展。 第 11 章 *当代中国特别行政区制度一、选择题(1) 1982 年，邓小平在会见英国首相撒切尔夫人时，首次阐明了 “一国两制” 的 构想。 (2) “一国两制”基本内容包括：① 坚持“一个国家”，即中华人民共和国；② 坚持“两种制度”，即在统一的中华人民共和国内，作为国家主体的大陆地区实行 社会主义制度，台湾、香港、澳门作为统一国家不可分割的组成部分保持原有的资 本主义制度本变；③ 高度自治。 (3) 中央人民政府对特别行政区行使下列权力：① 负责管理与特别行政区有关的 外交事务；② 负责管理特别行政区的防务；③ 任命特别行政区行政长官和行政机关 的主要官员；④ 对特别行政区立法机关制定的法律备案；⑤ 决定特别行政区进入紧 急状态；⑥ 有权解释和修改特别行政区基本法。 (4) 全国人民代表大会常务委员会 如认为特别行政区立法机关制定的任何法律不 符合《基本法》关于中央管理的事务及中央和特别行政区的关系的条款，可将有关 法律发回，但不作修改，这些被发回的法律立即失效。 (5) 根据《基本法》的规定：修改基本法的提案权属于 全国人大常委会、国务院 和 特别行政区。 (6) 特别行政区提出修改议案须具备三个条件：经特别行政区的全国人大代表的 2/3 多数、特别行政区立法会全体议员的 2/3 多数 和 特别行政区行政长官同意 后，交由特别行政区出席全国人民代表大会的代表团向全国人民代表大会提出。 (7) 特别行政区享有高度的自治权，主要是指 立法权、司法权、行政管理权。 (8) 行政长官的任职资格满足四方面的条件：① 必须是中国公民；② 通常在香港、澳门居住连续满 20 年的特别行政区永久性居民；③ 必须年满 40 周岁；④ 在香港无 外国居留权是参选行政长官的前提条件，而在澳门无外国居留权不是行政长官参选 的条件，只是行政长官任职的条件。 (9) 特别行政区行政长官 在当地通过选举或协商产生，由中央人民政府任命。 (10) 特别行政区行政长官任期为 5 年，可以连任一次。 (11) 香港特别行政区行政长官短期不能履行职务时，临时代理职务的首先是 政 务司长。 (12) 《香港基本法》和《澳门基本法》分别规定行政长官行使 13 项和 18 项的职 权，归纳起来主要有：① 领导权；② 执行权；③ 行使部分立法权；④ 批准决定权； ⑤ 人事任免权；⑥ 行使部分司法权；⑦ 有权解散立法会。 (13) 《香港基本法》规定：香港特别行政区的主要官员由在香港通常 居住连续满 15 年 并在外国无居留权的香港特别行政区永久性居民中的中国公民担任。 (14) “局” 是香港特别行政区政府的第二级政府机构。 (15) 香港公务员晋升有四个条件：① 行为良好；② 能力足 够；③ 经验丰富； ④ 学历相称。 (16) 《香港基本法》 规定外籍人士等可当选为立法会议员。 (17) 基本法规定，非中国籍的香港特别行政区永久性居民和在外国有居留权的香 港特别行政区永久性居民当选香港特别行政区立法会议员，其所占比例不得超过全 体议员的 20% 。 (18) 按照《基本法》的规定，特别行政区立法会有权行使下列主要权力：① 制定法律方面的职权；② 财政、税收方面的职权；③ 对行政长官提出弹劾案的职 权；④ 监督权；⑤ 对《基本法》的修改提案权；⑥ 立法会行使的其他职权。 (19) 《基本法》规定：特别行政区有权提出《基本法》修改提案的是 特别行政区 的全国人大代表 2/3 多数、特别行政区立法会全体议员 2/3 多数 和 特别行政区 行政长官。 (20) 《香港基本法》规定香港特别行政区立法会主席通过立法会议员互选产生，由 年满 40 周岁，在香港通常居住连续满 20 年并在外国无居留权的香港特别行政 区永久性居民中的中国公民担任。 (21) 澳门特别行政区 法院体系为初级法院、中级法院和终审法院。设立行政法 院，管辖行政诉讼和税务诉讼。不服行政法院裁决者，可向中级法院上诉。 (22) 澳门的律师分为 大律师和律师 两类。 (23) 大律师，即执业律师，是有资格独立开业，在法庭上为当事人代理或辩护，独立处理日常律师业务的法律专业人士。 (24) 律师 则被称为律师助理或法律代办，是协助执业律师处理律师业务的法律 专业人员。 二、简答题 特别行政区是中华人民共和国内享有高度自治权的地方行政区域，直辖于中央 人民政府，其法律地位是：(1) 特别行政区是单一制国家结构形式下的地方行政区域。(2) 特别行政区是一个享有高度自治权，基本保留原有法律，实行资本主义制度 和生活方式的特别行政区。(3) 特别行政区是直辖于中央人民政府的地方行政区域，它享有高度自治权，不 同于中华人民共和国的一般地方行政区和民族自治区。 简述行政长官在特别行政区中的地位。特别行政区行政长官的法律地位，既不同于中国内地省、自治区、直辖市的行 政首长，也不同于特别行政区建立之前的总督，其法律地位具有双重性质。(1) 作为特别行政区的行政长官，他是特别行政区的行全权代表，对外代表特别 行政区。(2) 特别行政区行政长官另一个身份是特别行政区政府的首长，由他直接领导和 指挥特别行政区政府，并通过政府全面负责整个特别行政区的工作。 简述香港特别行政区廉政公署的性质和职责。特别行政区设立廉政公署的审计署，是独立工作的政府部门。廉政专员和审 计署审计长对行政长官负责。廉政公署的主要职责是调查一切违反各项条例规定的贪污舞弊案件，并立案检 举或进行处分，其反贪污的主要对象是政府部门，还有公共机构和私人公司。香港 廉政公署设三个处级业务部门和一个行政部门，即执行处、防止贪污处、社区关系 处和行政总部。廉政公署的全体职员由公署自行招聘，不属于公务员。廉政公署官 员被授予广泛的权力，可无需拘捕令而拘捕嫌疑犯，有权进行搜查，有权检查政府 各部门及公共机构的行政程序，并负责廉政方面的宣传。 司法制度的基本原则 根据《基本法》，特别行政区司法制度的主要原则是：(1) 独立审判原则(2) 遵循先例原则(香港)(3) 陪审制度原则(香港)(4) 保留普通法的诉讼原则(香港) 第 12 章 当代中国司法制度一、选择题 我国审判机关与国家权力机关之间是 职能 分工上的独立。 公民担任人民陪审员，应当具备下列条件：拥护中华人民共和国宪法；年满 23 周岁；品行良好、公道正派；身体健康。 ( 07-4 ) 我国人民法院用有如下职权：① 审判权；② 司法解释权；③ 指导权；④ 司法行政权；⑤ 司法建议权。 ( 03-4 ) 最高人民法院作为 最高审判的机关，有权对审判过程中如何具体适用 法律、法令等问题做出解释。 我国的法院有普通法院与专门法院之分，普通法院包括由 基层人民法院、中级 人民法院、高级人民法院组成的地方各级人民法院 和 最高人民法院。 我国法定的审判组织形式有 独任庭、合议庭、审判委员会 三种。 《人民检察院组织法》第 1 条规定：中华人民共和国检察院 是国家的法律监督 机关。 在我国，检察机关内部实行检察长 负责制和民主集中制 的领导体制。 我国《宪法》和《人民检察院组织法》明确规定了双重领导原则，指的是 地方 各级检察机关既受同级地方权力机关的领导，又受上级检察机关的领导。我国行使公诉权的机关是 检察机关。 我国检察机关的职权包括以下几个方面：① 审判监督权；② 侦查监督权；③ 执 行监督权；④ 立案侦查权；⑤ 公诉权；⑥ 民事、行政诉讼参与权。 根据《刑事诉讼法》的规定，强制措施有以下四种：① 拘传；② 取保侯审；③ 监视居住；④ 拘留。 我国执业律师主要有 专职、兼职的特邀 律师三大种类。 在我国，律师事务所有四种形式：国资律师事务所、合作律师事务所、合伙律 师事务 所以及 个人律师事务所。 中国自 1994 年 起开始探索建立有中国特色的法律援助制度。 申请法律援助的公民必须具备两个条件，即申请人有充分理由证明为保障自己 的合法权益需要法律帮助；确因经济困难无能力或无完全能力支付法律服务费用。 二、简答题 简述我国审判制度的基本内容。(1) 两审终审制； (2) 公开审判制度； (3) 合议制度； (4) 回避制度； (5) 陪审员制度； (6) 审判监督制度。 三、论述题 试述我国审判制度的基本原则。(1) 独立审判原则。即指在国家权力机关监督之下的国家职能分工上的独立。各 级法院要向各级人大负责。(2) 依法审判和未经审判对任何人不得确定有罪的原则。以事实为依据，以法律 为准绳。(3) 平等审判原则。即对一切公民在适用法律上一律平等，任何人都没有特权，对任何人的合法权益都要加以保护，没有歧视。(4) 民主审判原则。首先体现在审判人员及机构由人大选举并任命；其次审判活 动必须贯彻民主集中制和群众路线；再次，体现在人民群众有权对审判工作提出意 见、建议、申诉、控告和检举。 第 13 章 当代中国军事制度一、选择题 新中国第一任国防委员会主席是 毛泽东。 《中华人民共和国宪法》 规定：中华人民共和国中央军事委员会主席由 全国人民代表大 十 分艰巨选举产生。 中央军委总部机关：① 总参谋部；② 总政治部；③ 总后勤部；④ 总装备部。 总参谋部 是负责部队作战指挥、管理和训练等工作的机关，同时隶属于中共中央军事委员 会和中华人民共和国中央军事委员会。 总政治部 是中共中央和中央军委领导下管理人民军队的党组织工作和思想政治工作的最高 领导机关。 1983 年 4 月 6 日，中国人民武装警察部队总部在北京成立。 国防部是中华人民共和国中央人民政府的军事工作部门，隶属于国务院。它成立于 1954 年 9 月 第一届全国人民代表大会第一次会议。 1994 年八届全国人大常委会 第七次会议修订的《中国人民解放军军衔条例》设三等十级：(1) 将官：上将、中将、少将；(2) 校官：大校、上校、中校、少校；(3) 尉官：上尉、中尉、少尉。取消原来的元帅军衔，还取消了大将、大尉。 根据新修订的《中国人民解放军军衔条例》，人民解放军的最高军衔是 上将。 1988 年 4 月，中央军委颁发 《中国人民解放军文职干部暂行条例》，实行了文职干部制度。 1955 年 7 月 30 日 我国开始实行义务兵役制。 义务兵 是士兵的主体，服役周期短。义务兵服役期满，根据军队需要和本人自愿，经团级 以上单位批准，可以改为志愿兵。 从 1999 年开始，陆军、海军、空军和武警部队义务兵服现役的期限一律改为 2 年。 战时遇有特殊情况时可征 36~45 岁 男性公民入伍。 政治委员制度是从 行政职务 上来保证中国共产党对军队绝对领导的制度。 党支部建在连队 是实现党对人民军队绝对领导的重要制度，是军队党的组织建设的一个 重要原则。 二、简答题 新兵役制的基本内容(1) 以义务兵投制为主体。(2) 义务兵与志愿兵相结合。(3) 民兵和预备役相结合。 第 14 章 当代中国政党制度一、选择题 中国共产党是 建设中国特色社会主义事业的根本保证，是中国工人阶级的先锋 队，同时也是 中国人民和中华民族的先锋队。 民主集中制 是党的组织原则和组织制度 党的根本组织制度是 民主集中制，是民主基础上的集中和集中指导下的民主相结合。 中国共产党的中央组织包括：党的全国代表大会 及其所产生的 中央委员会、中央纪律检查委员会，以及 党的中央军事委员会。 党的全国代表大会 是党的最高领导机关，由选举产生的党员代表所组成。 按现行《党章》规定，中国共产党的最高领导机关是 党的全国代表大会 和 中央委员会。 中共中央委员和侯补委员必须有 5 年以上的党龄。 中共中央委员会全体会议由 中央政治局 召集，每年至少举行一次。 在中央委员会全体会议闭会期，中央政治局和它的常务委员会行使中央委员会职权。 党的中央政治局、中央政治局常委会和 中央委员会总书记，由中央委员会全体会议选举。 中央书记处 是中央政治局及其常务委员会的办事机构，其成员由中央政治局 常委会提名，中央全会通过。 党的地方各级委员会全体会议 选举常务委员会和书记、副书记，并报上级党的 委员会批准。 《中国共产党章程》规定：企业、农村、机关、学校、科研院所、街道、人民 解放军连队和其他基层单位，凡是在正式党员 3 人以上 的，都应当成立党的基层组 织。 企业党的支部委员会、乡、镇党的委员会、村党的支部委员会 属于中国共产党 基层组织。 在中央和地方国家机关、人民团体、经济组织、文化组织和其他非党组织的领 导机关中，可以成立党组。党组的成员，由 批准成立党组的党的委员会指定。 党的纪律处分有五种：警告、严重警告、撤销党内职务、留党察看、开除党籍。 对党的中央委员会和地方各级委员会的委员、侯补委员，给以撤销党内职务、留党察看或开除党籍的处分，必须由 本人所在委员会体例会议 2/3 以上的多数决 定。 严重触犯刑律的中央委员会委员、侯补委员，由 中央政治局 决定开除其党 籍。 改革和完善党的领导体制和工作机制，最很重要的就是要按照执政党总揽全局、协调各方的原则，规范党委与人大、政府、政协和人民团体的关系 2003 年 12 月，中共中央颁发《中国共产党内监督条例(试行) 》，第一次以 党的法规形式对党内监督重点、途径和办法等重大问题作出全面规定，明确提出党 内监督的重点对象是各级领导机关、领导干部，特别是各级领导班子的主要负责人。 我国的多党合作是以 中国共产党的领导 为前提的。 中国民主促进会 (简称“民进” ) ，1949 年 12 月，在上海正式宣告成立，提 出以“发扬民主精神，推动中国民主政治之实现现”为该党宗旨。 现阶段我国民主党派共有 8 个。 中国共产党是执政党，各民主党派是 参政党，是友党。 二、简答题 简述中国共产党如何实现对国家生活的领导。党对国家的领导主要是通过以下三个方面来实现的：(1) 政治领导，即政治原则、政治方针和政治路线的领导；(2) 思想领导，即党通过对广大干部和群众进行思想政治教育从而引导人民走社 会主义道路；(3) 组织领导，主要通过推荐党的优秀人才担任国家机关的领导工作来实现的。 中国共产党对国家和社会生活的领导主要是政治、思想、组织领导。其中，政 治领导是根本、思想领导是灵魂、组织领导是保证。 简述民主集中制原则在党内选举、党内工作制度等方面的体现。(1) 党的各级代表大会的代表和委员会的产生，要体现选举人的意志，选举采用 夫记名投票的方式。(2) 党的各级领导机关，对同下级组织有关的重要问题作出决定时，在通常情况 下，要征求下级组织的意见。要保证下级组织能够正常行使他们的职权。凡属应由 下级组织处理的问题，如无特殊情况，上级领导机关不要干预。(3) 有关全国性的重大决策问题，只有党中央有权作出决定，各地方的党组织可 以向中央提出建议，但不能擅自作出决定和对外发表主张。(4) 党组织讨论决定问题，必须执行少数服从多数的原则。决定重要问题，要进 行表决。对于少数人的不同意见，应当认真考虑。 多党合作制的特点和优势 中国共产党领导的多党合作制度，既是我国的基本政治制度，也是符合国情的社会 主义政党制度。(1) 我国的多党合作是以中国共产党的领导为前提的；(2) 各民主党派是与中国共产党共同致力于中国特色社会主义事业的亲密友党，是参政党，而不是反对党或在野党；(3) 中国共产党的领导和执政地位与各民主党派作为亲密友党和参政党地位，决 定了我国多党合作制度的实质是团结合作；(4) 中国共产党领导的多党合作制，是以人民政协为主要政治形式和组织形式 的。 简述坚持和完善中国共产党领导的多党合作制度的意义。(1) 它是发展社会主义民主，推进政治体制改革，保持国家长治久安的一项重要 措施。(2) 它有利于加强执政党自身的建设，有利于完善我国的监督体系。(3) 它有利于发挥各民主党派的优势和特长，为社会主义现代化建设服务。(4) 实行多党合作，可以有力促进决策的科学化、民主化。(5) 实行多党合作，有利于维护港澳繁荣稳定和推动祖国统一大业。 三、论述题 试述政党制度的概念和政党体制的类型。(1) 政党制度是指政党领导或控制国家政权，干预政治的一种制度的通称；(2) 现代政党制度的类型按实质划分有资本主义国家政党制度和社会主义国家政 党制度；(3) 资本主义国家的政党制度主要有两党制、多党制和一党制三种类型；(4) 我国实行的是中国共产党领导的多党合作制度。 试论述中国共产党全国代表大会的地位和职权。(1) 党的全国代表大会是党的最高领导机关，由选举产生的党员代表组成。第五 年举行一次，由中央委员会召集。(2) 党的全国代表大会的职权是：听取和审查中央委员会和中央纪律检查委员会 的报告；讨论并决定党的重大问题；修改党的章程；选举中央委员会和中央纪律检 查委员会。 试述中国共产党的纪律检查机关及其主要职权。(1) 党的中央纪律检查委员会和地方各级纪律检查委员会。党的中央纪律检查委 员会在党的中央委员会领导下进行工作。党的地方各级纪律检查委员会和基层层检 查委员会在同级党的委员会和上级纪律检查委员会双重领导下进行工作。(2) 党的各级纪律检查委员会的职权。各级纪律检查委员会要经常对党员进行遵 守纪律的教育，作出关于维护党纪的决定；检查和处理党的组织和党员违反党的章 程和其他党内法规的比较重要或复杂的案件，决定或取消对这些案件中的党员的处 分；受理党员的控告和审诉。 第 15 章 当代中国政治协商制度一、选择题 1949 年 9 月 21 日至 30 日，中国人民政府协商会议第一届全体会议在北平召开。 政协第一届全国委员会委员 180 人，选举 毛泽东 为中央人民政府主席和政协 全国委员会主席。 1949 年 9 月第一届人民政协召开，人民政协代行国家权力机关职权，制定了 《中 国人民政治协商会议共同纲领》，作为新中国的临时宪法。 我国《宪法》在序言中规定：中国人民政治协商会议是具有广泛代表性的 统一 战线组织。 人民政协的主要职能：(1) 政治协商；(2) 民主监督；(3) 参政议政。 《政协章程》规定，人民政协由 中国共产党、各民主党派、无党派人士 、人民团体、各少数民族和各界的代表、香港特别行政区同胞、澳门特别行政区 同胞、台湾同胞和归国华侨的代表，以及特别邀请的人士组成，设若干界别。 政协全国委员会每届任期 5 年。 政协全国委员会设立 9 个专门委员会：提案委员会； 经济委员会； 人口资源环 境委员会； 教科文卫体委员会；社会和法制委员会； 民族和宗教委员会； 文史资料 委员会； 港澳台侨委员会； 外事委员会。 政协全国委员会对地方委员会、上级地方委员会对下级地方委员会的关系是 指 导性关系。 二、简单题 简述政治协商会议的历史发展阶段。第一阶段，1949 年 9 月—— 1954 年 9 月，一届全国人大召开前的人民政协，代行 国家权力机关的职权。制定了《中国人民政治协商会议共同纲领》，作为新中国的临时宪法。第二阶段，1954 年 9 月—— 1966 年 5 月“文化大革命”发生前，一届全国人大召 开后人民政协成为人民民主统一战线的组织。第三阶段，1966 年 5 月—— 1978 年 2 月，文化大革命发生后至党的十一届三中全 会召开前是人民政协陷于瘫痪时期。第四阶段，1978 年党的十一届三中全会以来进行中国特色社会主义现代化建设时 期，人民政府步入历史的新时期至今。 简述各级人民政协和各级人民代表大会对国家机关及其工作人员监督权的区 别。(1) 人民代表大会是国家权力机关，它是运用国家权力进行监督，具有法律的约 束力。(2) 人民政协不是国家权力机关，它的监督不具有国家监督的性质。(3) 人民政协的监督不具有法律的约束力，而是一种民主监督。 三、论述题 人民政协的主要任务。2005 年中共中央颁发了 《关于进一步加强中国共产党领导的多党合作和政治协商制 度建设的意见》，提出人民政府要围绕团结和民主两大主题，认真履行政治协商、民主监督、参政议政的职能。(1) 要坚持以邓小平理论和“三个代表”重要思想统揽政协工作。中国共产党和 各民主党派在多党合作和政治协商中必须坚持和遵循的重要政治准则，是坚持以马 克思列宁主义、毛泽东思想、邓小平理论和“三个代表”重要思想为指导，这也是 人民政协坚持坚定正确的政治方向的根本保证。(2) 要坚持按照围绕中心、服务大局的要求开展工作，积极为中国特色社会主义 事业贡献力量。人民政协应广泛联系社会各界人士调动一切积极因素。人民政协应 广泛联系社会各界人士调动一切积极因素，团结一切可能团结的人，同心同德，群 策群力，以经济建设为中心，维护和发展安定团结局面，不断促进社会主义物质文 明、政治文明、精神文明协调发展，为实现我国各族人民的根本任何而奋斗。(3) 要切实做好各方面的团结工作，不断壮大最广泛的爱国统一战线。人民政协 要宣传和协助贯彻知识分子政策、民族政策、侨务政策、外交政策，加强同香港特 别行政区同胞、澳门特别行政区同胞、台湾同胞的联系，充分发挥团结各界、凝聚 人心的作用，努力促进参加政协的各党派、无党派人士开展协商与合作，最广泛、最充分地调动一切积极因素，为会面建设社会主义和谐社会、促进祖国统一大业、实现中华民族伟大复兴凝聚新力量。(4) 要推进人民政协履行职能的制度化、规范化、程序化。要继续建立健全与政 协章程相配套的各项规章制度，逐步完善各种工作程序，进一步推进政协履行职能 的制度化、规范化和程序化，使人民政协更好地为改革开放和现代化建设服务。(5) 要进一步加强人民政协的自身建设。搞好自身建设，是人民政协发挥作用的 重要基础。要提高思想理论水平和政策水平，认真学习宪法和法律，自觉遵守宪法 和法律，坚决维护宪法和法律的权威，维护社会主义法律的统一，提高依法履行职 能的能力。 第 16 章 *当代中国基层民主制度一、选择题 我国的 职工代表大会，是保证职工对企事业实行民主管理的基本制度，是职工 行使民主管理权力的机构。 《企业法》规定，国有企业实行 厂长(经理) 负责制。 关于企业的经营方针、长远规划等事项，职代会有权行使审议建议权。 职工代表大会至少每半年召开一次，每次会议必须有 2/3 以上的职工代表出席。 《工会法》、《职代会条例》和《企业法都规定：“国有企业 工会委员会 是职工代 表大会的工作机构，负责职工代表大会的日常工作检查、督促职工代表大会决议的 执行。 我国的村民委员会是在 人民公社解体后 由农民自发组织起来的。 1982 年 《宪法》 把农民自发组织起来的村民委员会确立为 基层群众自治组织。 1994 年 2 月，国家民政部公布了 《全国农村村民自治示范活动指导纲要 (试行) 》，第一次明确提出了建立民主选举、民主决策、民主管理、民主监督四项民主制度。 1998 年 11 月 4 日，九届全国人大常委会第五次会议通过了 《中华人民共和国村 民委员会组织法》 (以下简称《村民委员会组织法》 ) 使我国的村民自治制度在法律 的保障下获得新发展。 村民委员会的设立、撤销、范围调整，由 乡、民族 乡、镇的人民政府 提出，经村民会议同意后，报县级人民政府批准。 村民委员会主任、副主任和委员，由 村民直接选举产生。 村民委员会的选举，又 村民选举委员会 主持。 1 3. 村民会议由村民委员会召集。有 1/10 以上的村民提议，应当召集村民会议。召开村民会议，应当有本村 18 周岁以上村民的过半数参加，或者有 本村 2/3 以上 的户 代表参加，所作决定应当经到会人员的过半数通过。 《城市居委会组织法》规定，居民委员会是居民自我管理、自我教育、自我服 务的 基层群众性自治组织。 居民委员会的建立、撤销、规模调整，由 不设区的市、市辖区的人民政府决定。 居民委员会每届任期 三年，其成员可以连选连任。 居民委员会决定问题，采取 少数服从多数 的原则。 城市社区居民自治的主要内容也是实行 民主选举、民主决策、民主管理、民主 监督。 城市社区建设的基本原则是：(1) 以人为本、服务居民；(2) 资源共享、共驻 共建；(3) 责权统### 一、管理有序；(4) 扩大民主、居民自治；(5) 因地制宜、循序 渐进。 二、论述题 试述如何正确处理职代会与“新三会的关系。(1) 职工代表大会和股东会的关系，是相互支持、相互配合，但又各有侧重、各 尽其职的关系。对于二者职权相同的部分，企业生产经营、规章制度等有关的重大 问题，可以同时召开“两会”，“两会”代表共同参与讨论。而对于那些属于各 自特殊职权范围内的问题和议案，则可以分别开会，各行其职，分别进行讨论和表决。(2) 职工代表大会和董事会之间的关系是监督和被监督的关系。职工代表大会有 权对董事会作出的决策实施监督。董事会作出决策后，凡属企业职工切身利益，属 职工代表大会职权范围内的主要问题，必须向职工代表大会报告，并经职工代表大 会审议通过后方可实施。此外，职工代表大会还可以对董事会的组成人员施工监督，参与董事候选人资格的审议，并提出参考性的意见。(3) 职工代表大会与监事会之间是既互相配合又监督的关系。一方面职工代表大 会运用其监督手段，对监事会行使监督职权给予支持，同时，监事会也通过其日常 监督活动，为职工代表大会实施监督提供依据，或者将职工代表大会在其监督过程 中反映出来的意愿付诸实现。另一方面，监事会也应当受到职工代表大会的监督，职工代表大会可以定期听取监事会的工作汇报，对监事会及其组成人员的业绩作出 评估，参与对监事会成员的选任和撤换等。","link":"/2021/03/01/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/%E5%BD%93%E4%BB%A3%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB%E5%88%B6%E5%BA%A6/%E9%87%8D%E7%82%B9%E6%B1%87%E6%80%BB/"},{"title":"社会学概论知识点总结","text":"社会学概论全书重点知识点 第一章 社会学的创立与发展第一节 社会学的创立与发展一、社会学创立的历史条件：★ （1）社会变革的需要（直接根源和关键因素）（2）自然科学发展的推动（原理和方法论）（3）社会经验研究的积累（4）社会研究先驱奠定的社会思想基础 二、社会学创立时期的主要代表：★★★ 奥古斯特·孔德致力于实证哲学体系研究，1838 年在《实证哲学教程》六卷本的第四卷首次提出社会学这一概念，标志着社会学的诞生，被称为“社会学之父”。孔德认为社会学居于科学的最高层次，是科学之“皇后”，所有其他学科都为它的建立作了准备。孔德认为社会学的研究对象是“秩序”和“进步”，也是其实证主义社会学的两个核心概念。孔德创造的实证方法是观察法、实验法、比较法和历史法。 马克思，著有《德意志意识形态》、《政治经济学批判》、《共产党宣言》、《资本论》等。 斯宾塞，英国人，著有《社会静力学》《社会学研究》《社会学原理》。其社会学思想主要围绕社会有机体和进化论两个方面展开。① 社会有机体论。斯宾塞认为，社会同生物一样也是一个有机体，存在结构分化和功能分化，不同部分之间相互影响；但社会不是简单的有机体而是“超有机体”。② 社会进化论。斯宾塞认为，宇宙的各个部分，不管是有机的或无机的，社会的或非社会学概论社会的，都受到进化定律的支配，这是一条公理。斯宾塞从进化论的观点出发，以社会内部的管理类型为依据，将社会区分为军事社会和工业社会。 三、社会学形成时期的主要代表：★★★ 涂尔干，法国社会学家代表作有：《社会分工论》、《社会学方法的准则》、《自杀论》。《自杀论》一书，就是涂尔干用一种社会事实（社会整合）去解释另一种社会事实（自杀）的范侧。其社会学观点如下：① 社会学的研究对象：社会学的特殊研究对象是社会事实。② 社会团结理论：涂尔干把社会团结分为“机械团结”和“有机团结”两个类型。社会团结：指以吸引为特征的把个人与个人、个人与群体、群体与群体协调、合作、结合在一起的社会联系状态。③ 失范理论。失范是指社会对个人的欲望和行为的调节缺乏统一规范和足够制约力的社会状态。④ 社会学研究方法准则：将社会事实当作物来研究是首要和最基本的社会研究方法准则。⑤ 功能分析和历史分析方法：系统的社会学功能分析推理方法是由涂尔干创建的。他明确地划分出历史探讨模式与功能探讨模式、功能结果与个人动机之间的区别。 韦伯，德国社会学家，著有《新教伦理与资本主义精神》、《经济与社会》等。其社会学观点如下：① 理解社会学。社会学的研究对象是社会行动。韦伯提出，对社会行动的研究的根本方法是理解。社会学不应当仅仅局限于发现支配社会行动的一般规则，它还应当试图对社会行动者的主观意向和动机作出“解释性的理解”。这些主观动机在下一个阶段可以被视为社会行动的原因，可以发展为“因果性的说明”。理解与解释是一致的，它最终必须与因果联系统一起来。② 社会行动类型：目的一手段合理性行动、价值合理性行动、情感性行动、传统性行动。③ 理想类型。韦伯为了避免德国人文学派和历史学派的个体化和特殊化的研究方法，提出一个关键性的概念工具——理想类型。④ 科层制理论。在韦伯看来，科层制是根据合理化原则组织的，它既是现代社会组织的一种结构方式，又是一种管理方式。 第二节 社会学主要理论流派一、芝加哥学派 ★★★ 著名的社会学家斯莫尔 1892 年在美国芝加哥大学创办了世界上第一个社会学系。所谓芝加哥学派，就是指以芝加哥大学社会学系师生为主而形成的社会学流派。 芝加哥学派的主要学术成就如下：（1）芝加哥学派开拓了现代城市社区的研究道路。（2）芝加哥学派形成了人文区位学的城市理论。（3）芝加哥学派推动了社会学调查研究方法的形成和完善。（4）芝加哥学派创建了符号互动论。 二、结构功能论 ★★★ 结构功能论兴起于 20 世纪 30 年代，即美国乃至世界经济危机时期，第二次世界大战之后成为最重要的社会学理论流派。 帕森斯：① 著有《社会行动的结构》和《社会系统》。② AGIL 功能分析图式是理解其结构功能理论的重要内容。帕森斯认为任何社会若要生存就必须具备维持系统所必须的一般条件，这些必要功能条件包括了四个方面： 1. 适应；2. 达鹄；3. 整合；4. 维模。 默顿，著有《社会理论与社会结构》。提出了显功能和潜功能。显功能：一种社会安排不会仅仅只具有一种功能，通常总是同时发挥着各种功能。其中有些功能是社会所期望和认识到的,默顿称之为显功能。潜功能：一种社会安排不会仅仅只具有一种功能，通常总是同时发挥着各种功能。有些功能则是社会所不期望或尚未认识到的，默顿称之为潜功能。 三、冲突理论 ★★★（1）马克思的阶级斗争理论被认为是最早、也是最深刻和最系统的冲突理论。（2）科塞的功能冲突论。代表作《冲突的社会功能》（3）达伦多夫的辩证冲突论。代表作《工业社会的阶级和阶级矛盾》。 四、交换理论 ★★★ 交换理论是美国社会学家霍曼斯（1910-1989）所建立的。 后布劳(1918-2002)对霍曼斯的交换理论进行了修正和发展。（1）霍曼斯，他认为人类的相互交往和社会联合都是一种交换行为。（2）布劳，著有《社会生活中的交换与权力》，认为交换常常是在资源和权力分配的不平等基础上展开的。 五、符号互动论 ★★符号互动论源于美国社会学家米德，主要代表人物有布鲁默和戈夫曼。 六、社会批判理论 ★★★社会批判理论，是法兰克福学派所主张的理论道路。法兰克福学派（批判资本主义制度）。 七、当代社会学理论的代表人物 ★★★ 艾尔弗雷德·舒茨， 现象学社会学，奥地利，后移民美国。著作有《社会世界的现象学》、《生活世界的结构》 吉登斯 结构化理论，英国社会学家，著作有《社会的构成》、《民族一国家与暴力》、《现代性的后果》、《第三条道路》 尤尔根·哈贝马斯，德国，法兰克福学派后期代表人物，著作有《公共领域的结构转型》、《作为意识形态的科学技术》、《合法性危机》、《交往行动理论》 皮埃尔·布迪厄，法国著作有《实践理论大纲》、《区隔》、《国家精英》、《实践与反思》 第三节 中国社会学百年一、社会学传入中国的代表人物 ★★★（1）康有为，在广州长兴里万木草堂开设“群学”，将其列入“经世之学”，与“政治原理学”等并列。（2）谭嗣同，在其所著《仁学》第一篇“仁学界说”里首次提出了“社会学”之名。（3）严复，最早译介西方社会学论著，最早翻译的论著为斯宾塞的《社会学研究》。为了呼吁上层社会人士变法图强，严复在 1895 年发表的《原强》一文已介绍了斯宾塞的社会学，文中说：“故学问之事，以群学为要归。（4）章太炎，翻译出版日本女子大学社会学教授岸本能武太的《社会学》。 二、早期社会学队伍和制度化建设 ★（1）社会学队伍的形成（2）学校教育的制度化（3）学术团体的建立 (东南社会学会)（4）期刊和论著的出版 三、社会学的恢复重建 ★★★ （1）正名:1979 年 3 月 15 日到 18 日，全国哲学社会科学规划会议筹备处在北京召开“社会学座谈会”，共同探讨社会学的恢复和重建问题。第一个在会议上提出此观点的人是邓小平。在座谈会上，代表党中央为社会学正名的是胡乔木。（2）“五脏六腑”说:由费孝通提出.“五脏六腑”是费孝通借用中医学的术语，比喻社会学的建设。① 五脏：是指学会组织、专业研究机构、各大学的社会系、图书资料中心和出版物。② 六腑：是指一个社会学专业至少要有六门基础课程，它们是社会学概论、社会调查研究方法、社会心理学、城乡社会学（社区概论）、文化人类学和国外社会学说。 四、社会学本土化 ★ 是一种使外来社会学与本土的优秀传统文化和现实社会的实际相结合，形成具有本土特色的社会学理论与研究方法的学术过程。 五、社会学中国化基本做法/实现目标/如何实现）★★★ 费孝通作为社会学科恢复重建的组织者和领导者，一开始就提出要建立中国自己的社会学，接着(1980)提出要建立具有中国特色的社会学。社会学本土化是一种使外来社会学与本土的优秀传统文化和现实社会的实际相结合，形成具有本土特色的社会学理论与研究方法的学术过程。实现社会学本土化的基本做法：（1）应当以马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想和科学发展观作为自己的行动指南，认真地开展社会现象研究；（2）把研究经济社会协调发展和人的社会化作为社会学的基本任务；（3）立足中国社会的现实，坚持理论联系实际，宏观和微观相结合，理论研究和经验研究相结合，使社会学的教学与研究能力切实为我国的社会主义建设事业服务；（4）采取积极的态度，在借鉴国外社会学和中国过去社会学的优秀成果的基础上，进行创新，逐步建立中国社会学的理论知识体系，形成中国社会学学派；（5）造就一支愿意并有能力为之奋斗的社会学专业队伍。 第二章 社会学研究方法第一节 社会学的研究对象、特征与功能一、社会学的研究对象 ★★★（齐美尔）社会学是研究个人与社会的关系的一门社会科学。 二、社会学的特征 ★★★（1）整体性。社会学从整体角度考察并分析个人与社会的关系。（2）综合性。社会学研究的整体性特征决定了它的综合性。（3）经验性。社会学是一门实证性科学，社会学成为一个独立学科后，始终是以社会调查研究所取得的经验知识作为学科发展基础的。（4）应用性。社会学是一门应用性很强的社会科学，应用社会学知识的主体是最广泛的，所以应用性或实用性也是社会学的一个特征。 三、社会学的功能 ★★★（1）研究功能① 描述性功能，是指那些为了解和掌握发生了什么事、什么情况而进行的探索性研究。② 解释性功能，是指对影响社会事实发生、变化的主客观因素，从其因果联系上加以说明的过程。③ 预测性功能，是要提示将来的社会事件和状态是怎样的。④ 规范性功能，是确定预定社会目标及其达到预定目标而采取的行动与手段，以及对社会目标、行动与手段的合理性可行性评价的过程。（2）教育功能：① 帮助人们自觉地完成社会化；② 帮助人们合理选择（3）社会管理功能：① 建立规范。② 提供模式。③ 反馈信息。（4）社会批评功能：对旧的思想、旧的观念和阻碍社会进步的事物、行为进行揭露，实事求是地进行理论分析，提出克服和解决问题的意见与建议。 第二节 社会学研究方法论一、实证主义方法论 ★ 指遵循自然科学法则，用普遍的因果律研究社会现象的方法理论。代表：孔德、涂干尔。 二、人文主义方法论 ★ 又称反实证主义方法论，是对社会行动过程及结果予以主观意义理论的方法。代表：狄尔泰和韦伯。 三、马克思主义社会学方法论 ★ 马克思的唯物主义和唯物辩证法第一次使科学的社会学的出现成为可能。 第三节 社会学的研究方式与方法一、统计调查 ★★★是根据调查目的与要求，运用科学的调查方法，有计划、有组织地搜集数据信息资料的统计工作过程。 普遍调查又称全面调查，简称普查，指为特定目的而专门组织的一次性或周期性的总体调查，是统计调查的组织形式之一。 抽样调查是非全面调查的一种，它是从总体中按一定的方法抽选一部分单位进行调查，并据以对总体调查研究对象作出估计和推断的一种调查方法。 二、问卷调查 ★ 以一组问题获得相关、有效信息的一种方法。问卷类型：自填式和代填式。 三、实地研究的类型 ★★★ 实地研究又称田野调查，是一种深入研究对象内部，以参与观察和非结构访问的方式收集资料，并通过这些资料进行定性分析，解释社会现象的一种研究方法。 包括：个案研究、典型调查、访谈法、观察法。 个案研究，是一种以某个社会单位或案例为一个整体，进行详细考察的方法。怎样做好实地研究（1）要有准备，搜索相关的文献，了解研究对象的背景。（2）要制定实地研究方案。（3）要作好个体或小组的定性访谈。（4）要尊重对方，忠实于研究的问题，认真作好观察记录。（5）要分析综合，撰写研究报告，概括总结出新的力量和范畴。 四、实验法 ★根据一定研究假设在有控制条件下，通过观察、记录和分析，以发现或证实变量间或社会现象间因果关系的方法。 五、文献法 ★★★ 文献法又称文件法、文案法和非介入性研究法，通过搜集现存的以文字、数字、符号、语音、画面等信息形式出现的文献资料，在不影响研究对象的情况下，分析和探讨个人与社会关系现象的方法 文献的来源。文献的来源有三大类：(1)官方文献，主要是政府机构和有关组织的记录、报告、计划、简报、公文、信函、统计等；(2)个人文献，主要是个人的日记、自传、照片、回忆录、契约及家谱等，(3)大众传播媒介，主要是报刊、书籍、绘画、图片、歌曲、电影、电视等。 六、典型调查的优点与不足 ★★（1）优点:可用较少的人力物力,在较短的时间内，对事物作较深入的研究。特别适用于对新情况和新问题的调查研究。（2）局限性：一是典型的选择容易受主观意识的诱导，二是所获取的资料难以标准化，三是结论的客观性和普遍性易受到较多的质疑。 七、观察法的优点与缺点 ★★★ （1）优点： 1. 可直接获得第一手资料； 2. 借助现场录像、录音、拍照等辅助手段,可获得详细、可靠的信息； 3. 特别适合无语言沟通能力的研究对象。 （2）观察法的局限性与缺点： 1.是对观察者要求高,不易达到；2. 是难以控制环境变量和时间变量,给数量分析和统计判断带来困难；3. 是易受观察者的价值观念和情感因素的影响,容易给收集资料造成损失和负面影响等。 八、定性分析 ★ （1）对收集到的资料进行归纳、分类、比较进而对某个或某类现象性质和特征作出概括的一种分析方法。（2）资料的来源：实地源和文献源。资料的整理：审查、分类和汇总。 第四节 社会学研究的一般程序与分析类型一、社会学研究的一般程序 ★★★（1）筹划阶段：选择研究题目、初步探索、建立研究假设、制订研究方案、组织工作。（2）实施阶段：是将研究方案付诸行动，依据研究方案的要求去收集资料，采用问卷调查或实地调查、文献或口述等方法。（3）总结阶段：任务是将收集到的资料进行整理，使之条理化和系统化，然后进行统计分析和思维加工，检验理论假设，提出新问题，最终撰写调查报告，结束该课题的研究等。 二、社会学研究的分析类型 ★★★ 定性分析定性分析是对收集到的资料进行归纳、分类、比较，进而对某个或某类现象的性质和特征作出概括的一种分析方法。一般来说，实地研究和非介入性研究属于定性方法。定性分析资料的来源与整理。定性资料的主要来源有二：一是“实地源”，包括非结构式访问和观察的记录；二是“文献源”，是以文字形式叙述的各种档案、文书和个人的传记、日记、信件，以及调查报告和研究论文等。由于资料来源和种类的不同，资料整理的方法也有所不同，但都要经过审查、分类和汇总三个步骤。社会学研究筹划阶段的主要工作：（1）选择研究题目，有新意，要适中，可操作。（2）初步探索，收集相关文献资料，接触研究对象，做到“心中有底”。（3）建立研究假设，作出理论解释，明确概念。（4）制订研究方案，选择调查地点，确定调查对象和研究单位，确定研究方式方法，制定调查问卷、量表和访谈提纲，准备调查工具，统筹与预算研究经费。（5）组织工作，包括研究人员的组成和培训，以及与协作单位的沟通等。 定量分析 ★定量分析是对社会现象的数量特征、数量关系与数量变化进行分析的一种方法。定量分析偏重经验实证主义的原则，强调量化的科学性、准确性。资料的来源：实地源和文献源。资料的整理：审查、分类和编码、汇总。定量分析的软件系统：社会科学统计程序包（简称 SPSS）、统计分析系统（简称 SAS）。对社会现象的数量特征、数量关系与数量变化进行分析的一种分析方法。 定性分析与定量分析的关系（1）区别：A 着重点不同。定性分析着重事物质的方面；定量分析着重事物量的方面。B 依据不同。定量分析的主要是调查得到的现实资料数据；定性分析依据的是大量历史事实和生活经验资料。C 手段不同。定量分析主要适用经验测量、统计分析和建立模型等方法；定性分析则主要运用逻辑推理、历史比较法等方法。D 学科基础不同。定量分析是以概率论、社会统计学为基础；定性分析则以逻辑学、历史学为基础。E 结论表述形式不同。定量分析主要以数据、模型、图形等来表述，具有概括性和精确性的特征；定性分析结论多以文字描述为主，具有深入细致地反映社会现象本质的（2）联系：A 在实际研究中，定性分析与定量分析是互补的，经常配合使用。B 定性方法是定量方法的基础，是它的指南，但只有同时运用定量方法，才能在精确定量的根据下准确定性。 第三章 社会与文化第一节 什么是社会一、社会的涵义与特征 ★★★ 社会: 社会是人们交互作用中产生的各种社会关系的总和。 社会的基本特征（1）社会以人为主体；（2）社会以人们的物质生产活动为基础；（3）社会以人与人的交往为纽带； 二、社会结构概念与类型 ★★★ 社会结构：是指社会诸要素之间在相互作用过程中形成的稳定的关系。 社会结构类型： ① 关系性社会结构 ② 实体性社会结构 ③ 规范性社会结构 个人与社会：相互联系的具有层次性的四个体系① 角色人格体系 ② 价值规范体系 ③ 权力制度体系 ④ 行为交换体系 社会关系：是人们在物质生产活动和社会交往过程中形成的相互关系的总称。 三、社会建设与社会管理 ★★ 社会建设：是在社会领域不断建立和完善各种能够合理配置资源和机会的社会体制和运行机制。中国共产党十六届四中全会明确地采用了社会建设概念，由原来的经济建设、政治建设、文化建设三位一体，扩展为经济建设、政治建设、文化建设、社会建设四位一体，使社会主义建设事业得以更全面、更完善地体现。 社会管理：是政府和社会组织为促进社会系统协调运行，对社会系统的组成部分、社会生活的不同领域以及社会发展的各个环节进行组织、协调、监督和控制的过程。 第二节 社会的基本要素一、人口 ★★★ 人口：指特定地域内，由一定社会关系联系起来的，一定数量和质量的有生命的个人所组成的总体。两重属性：自然属性和社会属性（1）人口数量: 是对人口的量的规定性，指一定时间和一定地区有生命的个体总和，通常人口数量指的是人口规模。（2）人口质量: 也称人口素质，是对人口的质的规定性，包括人口的身体素质、科学文化素质和思想素质等。（3）人力资源：指表现在劳动者身上的以劳动者数量和质量表示的资源，体现了包含在人体内的生产能力。其是在各种生产要素中最积极最活跃的主动要素，是社会经济发展的最重要的经济资源。（4）人口资源：是指在特定地域内具有一定数量、质量和关系的人的总称。 二、自然资源 ★★★ 自然资源：指与人类活动相关联的全部自然条件的总和，是社会赖以生存和发展的外部条件。（1）类型：① 环境资源，包括自然界中的光、热、空气、水和土地等。② 生物资源，包括自然界中的动植物和微生物等。③ 矿产资源，包括铜、铁、锡、钨、铝等金属矿产和石油、天然气、黏土、石墨等非金属矿产。（2）特点:有限性、无限性、系统性、不均匀性。 三、环境 ★环境：指围绕在人类周围的其他生物和非生命物质等因素所构成的人类的生存环境，是影响人类生存和发展的所有外界条件的总和。环境功能：支持、供给、调节、文化启迪。 第三节 什么是文化一、文化概念 ★ 文化：是指人类创造出来的一切物质产品和非物质产品的总和。 文化的构成要素：物质形态要素、精神形态要素、语言符号要素、社会关系和社会组织要素 文化的特征：★★★（1）创造性。文化，不论是物质形态的文化还是精神形态的文化，都不是天生的，而是人类在长期共同生活中创造出来或衍生出来的。纯自然的东西不是文化，只有人类制造出来或经过人类加工出来的东西才是文化。比如石头不是文化，用石头做出来的石器才是文化；水不是文化，自来水才是文化；刮风不是文化，利用风力发电才是文化，人的大脑不是文化，大脑创造的思想就是文化等。（2）习得性。文化不是先天遗传的本能，而是后天通过学习和模仿获得的知识、经验、技能和习惯等。 （3）共享性。凡文化都是一个群体、一个地区、一个民族，乃至一个国家的人们共同创造、共同享有、共同遵守的。 （4）累积性。文化是一个连续不断的积累和创新过程。每一代人一出世就生活在既有的文化模式当中，他们必须继承传统的文化，否则就无法生活。 （5）特殊性和共性。世界上只有各个民族的文化，如中国文化、美国文化、西方文化、东方文化等，而没有抽象的一般的文化。 二、文化结构：★★★（1）文化特质：是组成文化的最小单位。（2）文化集丛：功能上互相整合的一组文化特质，它们结合起来共同发挥一项功能，以满足人的某种需要，这些文化特质就组成了一个文化集丛。例如茶文化集丛、酒文化集丛。（3）文化模式：是指由许多文化集丛结合而成的一个文化整体。例如中国文化模式、美国文化模式等。 三、文化规范体系 ★（1）习俗：习俗是一种最古老最普遍的文化现象，几乎与人类历史一样长久。（2）道德：道德是由习俗演化而来的。（3）法律具有公正性和强制性。（4）宗教。 四、文化交流 ★★★指从文化传播开始的两种文化之间互相沟通、采借、冲突与融合的过程。 文化传播概念：指某种文化元素随同社会交往而扩散，为其他采借或吸必的过程。过程：美国人类学家 林顿 把文化传播分为三个阶段A 接触与显示阶段 B 选择阶段 C 采纳融合阶段。 文化冲突文化冲突：指异质文化传播、接触中出现的相互排斥的倾向和状态。根源：民族性、阶级性。 文化采借文化采借的选择标准：有用性；符合或接近本民族的价值观与民族性格的外来文化元素或集丛。（1）宗教：调整人们社会行为的重要规范，是集信仰、观念、组织、制度于一体的复合体。（2）文化采借：又译为文化杂交，是指一种文化接受或吸收另一种文化的某些文化元素或文化集丛，融入本文化的过程。 五、文化多样性 ★★★ 文化震惊：是指生活在某一文化中的人，当他初次接触到另一文化模式是所产生的思想上的迷惑、混乱与心理上的震撼。 主文化：又称主流文化，是在社会上占主导地位的，为统治集团指导，并被多数社会成员所接受的文化。 六、文化自觉 ★★★ 文化自觉:概念：是指生活在一定文化中的人对自己的文化有“自知之明”，对他人文化有“识人之明”。费孝通曾多次指出，“各美其美，美人之美，美美与共，天下大同”这四句话是“文化自觉”历程的概括。 意义：是努力创造现代的中华文化，放眼世界，了解和认识世界上他人的文化，学会处理解决文化接触的问题，为全人类的明天作出贡献。 内容：首先，“文化自觉”关注了中国现代化的反思；其次，“文化自觉”关注了文化断裂下的主体再造；最后，“文化自觉”提出了美美与共的价值诉求。 亚文化：是仅为社会上一部分成员所接受的成为某一地区，某一群体特有的文化。 文化中心主义：指各个国家、各个民族常有一种倾向，常将自己的生活方式、信仰、价值观、行为规范看成是最好的，优于其他民族的。 文化相对主义：认为各种不同的文化模式是不能评价和比较的。 第四章 社会化与社会角色第一节 什么是社会化一、社会化概述 ★ 社会化：社会对个人的文化教化和个人对社会主动选择与能动调适的统一过程。一是从时间方面理解，即个人社会化涉及人生发展的全过程；二是从内容方面理解，个人社会化关注个人作为社会一员所应具有的全部文化遗产；三是从关系方面理解，个人社会化注重个人与社会的交互作用以及个人社会化的结果。人的社会化作为个人与社会互动的成果，是强制性和能动性的统一。 社会化的内容：(1)生活技能社会化：是人们学习并获得维持生存状态和改善生活质量的本领的过程。(2)价值观念社会化：是人们认知与认同社会主导价值观念的过程。(3)政治社会化：是个人逐渐学习和接受被现有政治制度采用和确定的政治信念、思想体系、社会制度和政治态度的过程。(4)行为社会化：是人们按照通行的社会行为规范模塑自身行为的过程。(5)角色社会化：是按照社会上规定的角色的要求来支配自己的行为，使个人行为符合于一定社会期望的品质特征。 二、社会化的类型：★★★ 基本社会化：生物人”通过社会文化教化，获得人的社会性，获得社会生活资格的过程。① 任务：A 生理性成熟，即通过人的生理发育过程，形成完善健全的身心基础。B 社会性成年，即通过社会文化的教化与自我内化，成为具有独特个性行为能力的社会成员。② 预期社会化：社会化的一种特殊的表现形式，即一个人为适应特定角色需要而进行的知识准备过程。例如，职业学校教育。 继续社会化：是人在成年以后的社会化，或称二级社会化。继续社会化的必要性/意义：（1）基本社会化只是为人基本自下而上和发展能力打下基础，一个人要适应未来社会的环境和要求，只有在个人与社会的交互作用中继续学习，不断提高；（2）一个人如果不在更广阔的范围内继续学习，接受自己所需要的新知识，就可能被社会淘汰；（3）基本社会化时期的教育范围有较大局限性，面对个人交往范围的逐步扩大，必须充实更多更广泛的社会生活经验；（4）人不仅仅是学习社会文化，还肩负着发展社会文化的责任，成年人在生活的实践中更能主动地选择和内化知识，更能通过学习开创未来；（5）继续社会化是基本社会化的延续、完善和发展。 再社会化：也称重新社会化，是指使个人改变以前的知识结构、价值标准和行为模式，建立起新的、符合社会要求和新的形式要求的知识结构、价值标准和行为模式的过程。再社会化的类型：主动再社会化、强制性再社会化。 正向社会化和反向社会化正向社会化：是指上代人对下代人的文化传递和教化过程。反向社会化：反向社会化：是年轻一代用新知识、新观念影响前辈的过程，又被称为文化反哺。 三、社会化的有关理论：★★★ 弗洛伊德精神分析学说：人格由本我、自我和超我三个部分组成。 库利和米德自我理论:① 库利认为，自我作为一种社会的产物，它的出现有三个阶段。② 米德将自我分为两个部分：“主我”和“客我”。 科尔伯格道德意识发展阶段论(三种水平六个阶段) 第二节 社会化的条件一、社会化的条件：★★ 生物因素：是指个人所带有的一种由上代为下代提供的、有利于人类从事社会活动的特殊遗传素质。 环境因素：指影响个人社会化的全部社会环境，包括：家庭、学校、伙伴群体、工作单位、社区、大众传播。 互联网：是指一个由各种不同类型和规模的、独立运行和管理的计算机网络组成的全球性信息系统。特点：全球性、每台有地址、共同协议连接。互联网对青少年社会化的正面影响：（1）为青少年的教育提供了选择权。（2）开阔了青少年的视野。（3）有助于青少年更好地了解社会规范。（4）“虚拟环境”为青少年提供了很好的与人沟通的互动环境。 二、实现社会化目标的根本途径：★★★（1）社会实践是实现知识内化与积累，达到社会化目标的根本途径。（2）个人在生活实践中一般通过观察学习、角色扮演、知识积累三个方面实现社会化。（3）观察学习又称模仿学习，模仿需要榜样，模仿的榜样是在实践中产生的，模仿的过程也只有在实践中展开。（4）角色扮演是亲自实践的具体化，表现为三种情况，即扮演真实角色、扮演假想角色、暂时充当某一角色。（5）知识积累是知识内化的过程，是把他人的知识转化成自己的知识，把感性的知识加工成理性方面的知识的过程。 第三节 社会角色一、社会角色的概念 ★社会角色：由一定的社会地位所决定的、符合一定社会期望的行为模式。 二、社会角色的类型：★★★（1）依获得角色方式的不同，分为先赋角色和自致角色（2）依角色规范化程度，分为规定性角色和开放性角色。（3）根据角色追求的目标，分为功利性角色和表现性角色。 三、社会角色的扮演：★经过角色期待、角色领悟、角色实践三个阶段。 四、社会角色的失调：★★（1）角色紧张。个人在角色扮演的实际过程中时间和精力上的手足无措，称之为角色紧张。（2）角色冲突。指不同角色承担者之间的冲突，常由于角色期望的不同、角色领悟的差别、人们没有按角色规范行事等引发。（3）角色不清。指社会大众或角色的扮演者对于某一角色的行为标准不清楚而引起的角色矛盾。（4）角色中断。指一个人所承担的前后相继的两种角色之间发生的矛盾。（5）角色失败。指由于多种原因而使角色扮演者无法成功地扮演角色，从而出现严重的角色失败现象。 第四节 人的全面发展一、社会化的基本目标：★★社会化的目标，从根本上说，就是培养社会合格成员。中国人的社会化的基本目标，就是培养适应建设有中国特色的社会主义需要的新人。 二、马克思主义关于人的全面发展的思想：★★（1）人的全面发展，是马克思主义为人的社会化提出的最高目标。（2）人的全面发展是人的一切属性的全面发展，既包括人的智力和体力、又包括人的思想、情操、道德、审美能力等。同时，人的全面发展，还是人和社会关系的发展，是人的社会交往的普遍性和人对社会关系的控制的发展。在人与自然、社会的统一上，表现为在社会实践基础上的人的自然素质、社会素质和心理素质的发展。（3）人的全面发展不是指单个人的发展，而是指全社会每一个人的全面发展。人的发展不仅应当是全面的，而且应当是自由的。在整个社会不断发展的基础上，逐渐实现人的全面发展。（4）人的全面发展是每一个人都能得到平等发展、完整发展、和谐发展、自由发展。（5）人的全面发展，是人类进入文明时代后就开始产生的一种美好向往。马克思主义把人的全面发展作为共产主义社会成员的成熟标志。 第五章 社会互动第一节 社会互动的涵义与形式一、社会互动的界定 ★★★ 社会互动：是人与人之间通过一定的符号和交往形式而产生相互影响的过程。 社会互动的构成因素：（1）两个或两个以上的互动主体；（2）互动主体之间必须发生某种形式的接触；（3）参与互动的各方有意识地考虑到行动“符号”所代表的“意义”。 二、社会互动的基本形式 ★★★ 暗示：人们为了某种目的，在非对抗条件下，通过语言、表情、肢体语言以及某些符号，用含蓄的、间接的方式对他人的心理与行为进行影响，使其接受暗示者所示意见、观点或所示意的方式进行活动。暗示的类型：直接暗示、间接暗示、自我暗示、反暗示。 模仿：模仿是在没有外在压力条件下，个体受他人影响，而仿照他人，使自己与之在某些方面相同或相似的现象。 交换：是指在一定规则下，行为者为了获得回报而行动并获得回报的社会互动形式。交换的要素：目标、付出、回报、效益。 竞争：是指行动者之间为了共同的目标而展开的较量、争夺。 合作：是指在社会互动中，行为者之间为达到某些共同的利益或目标彼此密切配合的一种联合行动。合作的类型：(1) 自发性合作：比如，农村中的左邻右舍帮助乡里将病危老人送往山外医院救治，就是合作性的救助行为。(2) 制度化的传统合作：比如在一些农业地区逐步形成大家一起收获庄稼的合作习惯。(3) 指导性合作：比如在公司里工作的员工，有些工作任务可能是在部门经理或总经理的管理和协调下共同完成的。又如，大学生的社会实践是在他们的老师指导下，有序有效地进行的。(4) 契约式合作：比如在金钱借贷方面的合作，某公司几个合伙人之间的合作，都是契约式合作的例子。 冲突：是指不同行动者之间相互反对或阻止对方意图的自觉行动。冲突的类型：从方式或程度上，可将冲突分为：显性冲突 和 隐性冲突。显性的冲突方式有：争论、拳斗和械斗、仇斗、诉讼和战争等。 调适：即调整自己的行为以适应环境的要求，是对冲突情境加以适应的状态或过程。 第二节 社会互动的符号一、语言 ★★★ 符号：由一群人所共同认可的、有意义地代表其自身以外的别的事物的象征。 语言：指人类所特有的用来表达意思、交流思想的工具，是由语音、词汇和语法构成的系统。 二、身体语言 ★ 身体语言：是指用身体代替语言来表达意思的动作或方式。种类：面部表情、手势、静态的身体语言。 三、个人空间：★★ （1）含义：个人空间指的是环绕一个人周围的直接的物理区域，人们可以利用它在社会互动中表达某种意义。 （2）霍尔提出个人空间的理论。四种距离：① 亲密距离：45 厘米内,是亲密者之间求爱、安慰和保护的距离； ② 个人距离：45 厘米到 122 厘米,是为熟人或朋友保留的； ③ 社会距离：122 厘米到 365 厘米，是比较正式的场合保持的距离； ④ 公众距离：365 厘米以上，为一些类似演说家等公众人物保留的距离。 第三节 社会互动的理论一、符号互动论 ★★★符号互动论：指从互动个体的日常自然环境去研究人类群体生活的理论派别。布鲁默和他的追随者认为符号互动论可以简要归结为：人类行为的社会目的主要看他们赋予这些目的的意义，而这些意义在社会互动中是不断建立和再建立的。 美国社会学家库利、托马斯和米德等人是符号互动论的早期代表。库利的“镜中之我”理论同样对符号互动理论作出了开拓性的贡献。 依照戈夫曼的观点，社会互动的最重要特征就是“印象管理”或“自我呈现”。拟剧论(戈夫曼)：指用表演和比喻来说明日常生活中人与人之间相互作用的一种互动的理论。 二、常人方法学 ★★★ 是指对人们在日常生活互动中所使用方法的研究。代表：加芬克尔。其思想来源主要是舒茨的现象学社会学。 基本假设：在现实生活中，社会成员依据一定的规则和程序来进行社会互动，这些日常生活中不成文的、大家公认的互动规则是一切社会生活的基础。 第四节 社会网络与社会资本一、社会网络的涵义：★个人之间的关系网络。二、社会网络的特征：★★★（1）普遍性：人与人以不同的方式结合起来形成了地缘、血缘、学缘、业缘、网缘等重重关系网络，构成了生产关系和其他社会关系。（2）多重性：社会网络反映个人和社会关系的本质，是多重性的。（3）滚珠性：社会网络并不是单纯的个人与个人关系的存在，还有许多个人关系的外延。（4）多向性：社会网络是经过个人之间的社会互动所形成的。（5）隐蔽性：社会网络是可感知的，但却是看不到的，无形的。三、社会网络的形态与功能 ★★★ 社会网络的形态：（1）封闭形态和开放形态。以个人进出该社会网络的难易程度的不同来区分。（2）稳固形态和松散形态。以个人和社会网络的连接的紧密程度不同来区分。（3）互利形态和互补形态。以个人在社会网络中获得的利益来区分。 社会网络的功能：（1）社会网络对于个人的功能是显而易见的。个人在其中获得各种信息、获得各种精神上的支持以及物质上的资源。社会网络影响到个人社会生活的各个方面。（2）在我们的现实社会生活中，人和人之间有着广泛的联系，所以这个社会实际上充满了各种社会网络。（3）社会学对社会网络以及其他社会互动问题的研究，强调个人在社会过程中的主观能动性以及它背后各种社会力量之间的关系，为我提供了一种更具动态性的视角来观察社会、了解社会。 四、强关系与弱关系：★★（1）美国社会学家格兰诺维特提出人际关系网可分为强关系网络和弱关系网络两种。（2）强关系指的是个人的社会网络同质性较强，人与人的关系紧密，有很强的情感因素维系着人际关系。比如父母和子女之间的关系。（3）弱关系的特点是个人的社会网络异质性较强，人与人关系并不紧密，也没有太多的感情维系。比如公司上层和下层职员之间的关系。（4）关系的强弱决定了能够获得信息的性质以及个人达到其行动目的的可能性。（5）格兰诺维特通过研究发现，美国的劳动者更经常地通过弱关系而非强关系获得工作信息。在美国，弱关系分布范围广，比强关系更可能充当跨越社会界限的桥梁。（6）边燕杰对天津的一项研究表明，在中国的劳动者更经常地通过强关系而非弱关系寻找工作渠道。在中国，强关系可以创造连接其他没有联系的个人的网络桥梁。 五、社会资本 ★★ 指通过社会联系与社会关系所获取的资源。依据社会的性质分为：A 同质性社会资本有：家族型社会资本、宗族型社会资本、亲族型社会资本、乡土型社会资本、情感型社会资本等；B 异质性社会资本有：同事型社会资本、同学型社会资本、战友型社会资本、兴趣型社会资本、现代公民型的各类社会团体组织等。 第六章 家庭与婚姻第一节 什么是家庭与婚姻一、什么是家庭 ★★★家庭：是由具有婚姻、血缘或收养关系的人们组成的长期共同生活的群体，是人类生活中最基本、最重要的一种群体形式。 二、什么是婚姻 ★★★婚姻：通常是男女之间依照社会风俗或法律的规定而结为夫妻关系的一种社会制度。 三、家庭与婚姻的理论解释：★★（1）结构功能主义分析：① 社会化 ② 情感和陪伴 ③ 性规则 ④ 经济合作（2）社会冲突论：① 两性竞争冲突 ② 批判男权 第二节 家庭的功能和类型一、家庭的功能：★★（1）规范性行为功能 （2）经济生活功能 （3）人口再生产功能（4）精神生活功能 （5）教育功能 （6）抚养、赡养功能 二、家庭的结构类型：★★★（1）核心家庭。核心家庭一般由一对夫妇及其未婚子女生活在一起而组成的家庭。但也存在一种特殊情况，即一对夫妇没有子女并且自愿终生不育的家庭。（2）主干家庭。主干家庭由一对夫妇与父母和未婚子女聚居生活的家庭。（3）联合家庭。联合家庭是指由父母和多对已婚子女以及孙（外孙）子女组成的家庭。（4）其他家庭。其他家庭是指一些不完全的家庭，如残缺家庭、断代家庭、单身家庭等。 三、家庭的特殊类型：★★★（1）重组家庭。重组不仅意味着配偶双方或配偶一方曾有过婚史，而且配偶双方或一方有可能将与前妻或前夫所生的子女带到新的家庭。（2）失独家庭。是指失去家中独生子女的家庭。（3）同性恋家庭。是同性恋者因婚姻压力选择同性婚姻的家庭。（4）丁克家庭。即“无孩家庭”，有“双收入，无子女”之意。（5）留守家庭。指夫妻一方在外流动打工，一方留守的“半流动”家庭以及夫妻双方都在外流动打工的“双流动”家庭。 第三节 变迁中的家庭与婚姻一、家庭形态的变化：★（1）家庭规模小型化；（2）家庭离婚率上升；（3）家庭类型多样化 二、家庭功能的变化：★（1）经济功能弱化 （2）抚育和社会化的功能外移（3）家庭是生育偏好开始改变 （4）养老功能的挑战 三、家庭与婚姻观念的变化：★★★（1）性观念多元化。“谈性色变”的历史似乎已被人遗忘，中国人的性观念的转变可以说是前所未有的。（2）地位平等化。对家庭经济事务的处理和家政决策权的分配，最能反映夫妻在家庭中的地位和彼此间的相待态度。（3）行为理性化。在家庭与个人之间的关系上，家庭成员的自我意识进一步增强，家庭利益至上的传统观念已经动摇。 第七章 群体与组织第一节 什么是群体一、群体的涵义和特征 ★★★ 群体：是人们通过某种社会关系联结起来进行共同活动和感情交流的集体。 群体的特征：（1）有一定数量的社会成员； （2）有一定的为群体成员所接受的目标；（3）有明确的成员关系，并形成归属感；（4）有一定的行为准则；（5）时间上具有一定的连续性。 二、群体的类型：★★ 以成员的互动关系特征为标准，可划分为初级群体（家庭、邻居、伙伴）和次级群体（学校、职业群体、社团等）； 以群体的关系结构和组织功能为标准，可划分为正式群体和非正式群体； 以成员对群体的心理归属为标准，可划分为内群体和外群体； 以群体成员的归属感为标准，可划分为成员群体和参照群体（美国社会学家海曼提出）； 以群体的规模为标准，可划分为大群体和小群体 三、初级群体 ★★★ 初级群体：作为由面对面对的互动所形成的、具有亲密的人际关系的社会群体，在社会生活中具有重要的地位和作用。 初级群体的特征： （1）规模小。初级群体的规模一般在几人到十几个或二十几人之间，成员之间进行着全面深入的交往。（2）有长期的、经常的面对面互动。（3）成员的人格特征可以得到比较全面的表现。（4）成员之间的角色位置难以替代。（5）习惯、伦理道德和感情在维系群体中发挥着重要作用。 四、利益群体 概念：是在社会利益体系中具有相同的利益地位、有着共同的利害和需求、共同的境遇与命运的群体。 特征： ① 利益关系是利益群体的核心关系 ② 群体规模具有不确定性 ③ 群体成员之间的交往具有多样性。 类型 ① 从群体目标特点分为：经济利益群体、政治与社会权利利益群体、社会公众利益群体 ② 从群体组织形式分为：机构性利益群体、社团性利益群体、自组性利益群体 既得利益集团 概念：指对公共资源享有支配权的社会阶层，为了共有的特殊利益而结成的共同体。 最大特点：为维护少部分人的利益而不惜牺牲大多数人的利益。 加快社会主义市场经济建设和与此相适应的政治体制建设的步伐，是防止既得利益集团产生和存在的根本举措。 第二节 组织和组织理论一、组织的概念 ★组织：人们为了达到特定目标而有计划地建立起来的具有比较严密的结构的制度化的群体。 二、组织过程：★★（1）组织决策。是指组织成员从两个以上的行动方案中进行选择决断，以期最优化地达到组织目标的过程。四个阶段：情报阶段、设计阶段、抉择阶段、审查阶段。 （2）组织沟通。是指组织内部的信息交流，及组织成员之间通过各种形式的交往以传达思想、观点、态度、感情或情报的过程。① 从沟通信息的方向上看，可分为：横向沟通和纵向沟通。② 从沟通的性质上看，可分为：正式沟通和非正式沟通。 （3）组织控制。是指组织用各种规章制度和奖惩手段约束组织成员的行为，以保证组织的决策和指令能够有效地贯彻执行，维护组织的各项秩序。可分为：预先控制、现场控制、反馈控制。 三、组织的科层制理论 ★★★ 科层制：又叫官僚制，是指建立在法理型权威基础上的，以正式规则为管理主体的，具有职权分工和职位等级体系的组织形式和管理方式。 韦伯提出的科层制的特征：（1）明确规定的固定权限 （2）明确规定的职位等级（3）执行职务建立在公文基础上 （4）职务的专业化和量才录用 （5）照章办事 科层制组织的优点和弊端：（1）科层制的最大优点在于，相比其他组织体系和管理方式，行政效率高。韦伯相信，建立在法理型基础上的科层制是对工业社会中大型和复杂的组织进行行政管理的最有效手段。（2）一般认为，科层制组织在实际操作中存在以下问题：A 形式主义。 B 繁文缛节。 C 用人困境。D 人情味欠缺。 E 对外界变化反应不灵敏。 韦伯对合法性统治的分类：超凡魅力型、传统型（家长制、世袭制和封建制）、法理型（科层制）。 四、组织管理理论 ★★★ 科学管理理论：为了使组织更有效地实现它的目标，必须使组织的结构和过程科学化和合理化。代表：泰罗、法约尔。 人际关系理论：（1）基本观点：人是组织中最重要的因素，不是简单的生产工具，而是具有复杂的个性和多方面的需求；在生产组织中，影响职工积极性的原因并不主要是物理因素和生理因素，起决定作用的主要是社会因素和在工作中形的人际关系。代表：梅约、罗伊斯里斯伯格。（2）主要观点：A 要求组织管理重视非经济因素的影响；B 强调组织成员的群体身份对组织管理的作用 C 要求组织管理重视人际沟通。 组织行为理论：代表：巴纳德、麦克雷戈（1）巴纳德：提出了“组织平衡论”，认为组织的存在和成功取决于在组织成员的贡献与满足之间所维护的平衡。（2）麦克雷戈：提出了著名的“X”理论和“Y”理论，对不同管理模式背后的理论假设进行了区别和分析。“X”理论是指一种专制型的管理理论。“Y”理论是指一种人道主义的帮助型的管理理论。（3）组织行为理论呼吁组织采取民主而非集权专制的领导方式，认为民主型领导比专制型领导的组织效果更好。 权变理论：又称情势理论，认为组织管理不只是和组织本身有关，而且涉及组织和环境之间的关系，组织的管理者应根据不同的环境和具体情况，灵活地决定组织的决策方式、领导方式和行动方式。代表：摩尔斯、洛斯奇提出的超“Y”理论。 第三节 集体行为一、什么是集体行为 ★ 集体行为：是指在缺乏确定组织程序和制度规范的条件下，很大程度上自发形成的，由许多个体参加的非制度化的行为。 集体行为的特征：群众性、自发性、非组织化和非制度化。 二、集体行动的理性选择理论：★★★ 斯梅尔瑟的价值累加理论：斯梅尔瑟认为不能单纯地从心理的角度来解释集体行为，而应该把集体行为的形成和社会结构联系起来。斯梅尔瑟提出，只有当六个因素不断累加影响下，才会导致集体行为的发生。这六个因素分别是：（1）结构性助因（2）结构性紧张（3）一般化信念（4）触发性因素（5）行动动员（6）社会控制。 奥尔森的搭便车理论：让其他社会成员承担公共费用。理论的假设：如果个体越理性，群体规模越大，那么这个群体发生集体行为的可能性就越小。 社会运动资源动员理论：代表：麦卡锡、扎尔德。所需要的资源：时间资源、参与者规模、金钱与物质资源、外界支持、理念资源。社会运动：是指有比较明确的变革社会的目标、组织化程度也相对较高的那类集体行为。 第八章 教育、劳动与消费第一节 教育一、教育的概念与类型 ★ 广义教育：泛指一切传播和学习人类文明成果——各种知识、技能和社会生活经验，以促进个体社会化和社会个性化的社会实践活动，产生于人类社会初始阶段 教育类型：（1）根据教育发生的场所，可分为家庭教育、学校教育和社会教育。（2）根据个体对教育的需求，可分为生存教育和地位教育。 二、依照默顿的观点现代学校教育的显功能和潜功能:★★★ （1）现代学校教育的显功能： ① 社会化的功能 ② 社会选拔的功能③ 提高人口素质的功能 ④ 知识技术创新的功能 （2）现代学校教育的潜功能：① 建立未来人际关系 ② 减少就业压力 ③ 社会控制 三、教育的社会学分析视角：★★ （1）功能论视角下的教育：对教育的考察首先应当关注其功能，即为专门化的社会角色提供训练有素的能力。（2）冲突论视角下的教育：社会秩序不是建立在对共同价值的一致认可上，而是建立在统治阶级的控制权力上。（3）互动论视角下的教育：互动论传统被称为“人本主义”和微观倾向。 四、教育与社会不平等：★★★ （1）教育不平等现象：① 教育资源分配的不平等；② 教育没有带来大规模的向上社会流动 （2）教育不平等的社会学分析：① 对制度化教育的批判。② 教育与文化资本。③ 劳工阶层子弟的“亚文化”。 第二节 劳动一、劳动的概念与类型 ★★ 劳动：是有目的、有意识地变换、调整和控制自然界的活动，包括脑力活动和体力劳动。 劳动的意义：（1）马克思认为劳动是人类最基本的实践活动，是人类生存和发展的基本条件。（2）劳动具有经济意义。（3）劳动具有社会意义。（4）劳动也具有文化意义。 劳动的类型：（1）根据有否劳动报酬，可分为：有薪劳动和无薪劳动；（2）根据消耗体力还是脑力，可分为：体力劳动和脑力劳动；（3）根据劳动的二重性，可分为：具体劳动和抽象劳动。 二、工业时代的劳动过程：★★★（1）福特主义：指以泰勒制原则和市场为导向,以分工和专业化为基础的生产劳动方式。特征：A 标准化效率 B 劳资谈判新型关系 C 高设备低工人结合 （2）后福特主义：指以精益生产、柔性专业化等非大规模生产方式为核心的新的资本主义积累方式及其对社会经济结构的生产劳动方式。特征：A 灵活；B 减少不增值的间接劳动形式；C 自主权增加；D 合作信任。 （3）当代资本主义劳动过程批判：① 布雷弗曼的压迫机制理论（资本主义剥削）② 布洛维的生产政体理论（生产与政治规范） 三、就业 ★ 影响求职成功的主要因素：① 人力资本 ② 社会网络 ③ 社会制度 ④ 社会偏见 失业：是指达到就业年龄具备工作能力谋求工作但未得到就业机会的状态。失业的类别：（1）摩擦性失业，指人们在转换工作过程中的失业。（2）结构性失业，由于产业结构或者生产技术的改变，使得原有的工作机会消失而造成的失业。（3）周期性失业，由于经济周期波动所造成的失业。（4）季节性失业，受季节性因素影响的失业。农业、营建业与旅游业季节性强，容易产生失业。（5）残余性失业，因无就业能力的失业。 第三节 消费一、消费的概念与特征 ★★★ 消费：为满足生产和生活需要而消耗物质和文化财富的活动。 消费的特征：（1）经济属性（2）心理属性（3）社会属性（4）文化属性。 二、消费社会 ★ 消费社会：是一个以生活必需品之外的消费为主的社会。 消费社会的特征：（1）消费成为社会的核心。（2）消费水平和消费规模的不断扩张。（3）消费主义盛行。 第九章 社区与社区发展第一节 什么是社区一、社区的概念和功能 ★★★ 社区：指以一定地域为基础的社会生活共同体。社区概念最早是由德国社会学家滕尼斯在 1887 年所著《社区与社会》一书得到经典的阐述。 构成要素：人口、区位、经济、文化、组织。 社区的功能： 经济生活、社会化、社会控制、社会参与、社会保障（1）经济生活功能：社区具有一套生产、分配、交换和消费的体系，通过生产或进口，满足社区成员的需求，这是社区的首要功能；（2）社会化功能：社区具有一系列的组织和设施，将社区共有的价值观念、行为规范、基本常识等传递给下一代社区成员，使他们能够融入到社区生活中来。（3）社会控制功能：任何社区都会对其社区成员偏离社会规范的行为施以某种形式的制裁，以督促人们遵守社会规范，维护社区的社会秩序。（4）社会参与功能：社区可以向社区成员提供生活和交往的场所、设施和途径，帮助社区成员参与社区事务以及更大范围的社会事务。（5）社会保障的功能：社区可以提供一套社会保障体系，以帮助社区中遇到问题、需要求助的社区成员，如社会救济。 二、人文区位学理论：★（1）同心圆理论提出者：伯吉斯(美国)（2）扇形理论 提出者：霍伊特（3）多核心理论提出者：哈里斯、厄尔 三、社区全貌研究：★★★ 美国学者林德夫妇在社区研究中开创了以小市镇为对象的全貌研究。并于 1929 年发表了名著《中镇》。所谓全貌研究，就是描述社区的各个不同部分并解释这些不同部分的相互关系。 第二节 社区类型一、农村社区 ★★★ 农村社区：也称乡村社区，是指以农业生产为主要谋生手段的人们为主体构成的同质性较高的地域性生活共同体。 农村社区的特点：（1）农村社区的人口密度低；（2）农村社区的经济活动相对简单；（3）农村社区的社会结构相对简单；（4）传统的农村社区的社会变迁比较缓慢。 二、城市社区 ★★ 城市社区：又称都市社区，是指以从事各种非农业生产为谋生手段的具有一定规模的人口所构成的异质性较高的地域性生活共同体。 现代城市社区生活方式的特点：（1）城市社区的分工复杂，居民从事更专门化的工作，彼此工作背景相差很大；（2）城市社区中家庭和初级群体作用减弱，取而代之的是各类正式组织；（3）城市社区中，人际互动趋向功利化、理性化和肤浅化；（4）城市社区存在和包容了更多文化差异。 第三节 社区发展一、什么是社区发展 ★ 社区发展：是指在城乡基层社区中社区居民依靠社区自身力量，在政府和其他组织结构的支持下，推动社区有计划地社会变迁，改善社区的经济、社会和文化状况，提高社区居民的生活质量。社区发展概念在第二次世界大战以后由联合国倡导并在世界范围内推广。 二、社区发展的目标与原则：★★★（1）社区发展的目标具有双重性。① 任务目标：改善生活； ② 过程目标：全员参与（2）社区发展的原则：① 民主的原则；② 民众需要的原则；③ 自力原则；④ 自下而上与自上而下相结合的原则。⑤ 物质文明、精神文明和政治文明建设并重原则。 三、中国城市的社区建设 ★★ 社区建设： 以人们日常居住和生活的基层社区为载体，通过社区居民自治，社区与政府、企业和其他社会组织共同合作，来建立一个和现代社会保障体系、现代城市管理制度和社会化服务网络相适应的社区支持系统。 社区建设的原因及其本质： (1) 原因： 在原来计划经济体制下的城市社区的管理体制和运行机制已不能适应社会主义市场 经济和现代化发展的新变化、新情况和新要求。 具体表现在： ① 在计划经济体制下的城市中，国家通过占支配地位的国有经济以及在很大程度上依附于国 有经济的集体经济，建立起隶属于国家各个部门的企事业单位，这些单位基本上覆盖了整个城市 社会，国家通过这些单位对社会成员实现直接的控制。这种管理体制我们称之为“单位制”。在 单位制的城市管理体制和机制下，两个突出的表现是：城市的经济、政治和社会事务事实上是由 政府进行着全方位的垂直管理；政府及其下属的企事业单位包揽了几乎所有的社会服务。 ② 推行社会主义市场经济体制之后，单位制赖以存在的社会和经济基础发生了深刻的变化，单 位制逐步消解。这表现在两方面：单位体制外人员的增加；传统单位的功能性转变。 ③ 正是在这一体制背景下，我国政府和人民逐步认识和社区的很重要作用，作为人们日常生活 的居住地，社区可以承担从单位中剥离出来的许多社会功能，成为各项社会政策的实现场所。 (2) 本质：中国社区建设是对对传统城市社会管理模式的制度变革与创新。 当前社区发展的基本任务： (1) 促进城市治理体系的进一步完善。 (2) 促进民主政治建设。 (3) 减轻市场经济发展对社会生活带来的负面影响。 第十章 城镇化第一节 城镇化概述一、城镇化的概念与特征 ★★★ 城镇化：也称城市化、都市化，指人口和社会职能向城市或城市聚集，生产方式、文化模式和社会角色发生变更，使城乡接近、融合的过程。 世界城镇化演进模式：（1）欧美模式：属于市场主导型城镇化，其起始和演进是产业革命引导的工业发展、社会分工和市场细化的自然结果。（2）墨印模式：属于政治主导型城镇化。是发展经济学中所谓的“无工业化的城镇化”，是与西欧资本主义城镇化截然相反的低水准的城镇化 二、世界城镇化的“推一拉”理论 ★★ 世界城镇化的“推-拉”理论 P191：工业革命兴起之时，英国是工业革命的策源地，率先实现了城镇化。雷文斯坦在“人口迁移的规律”的著述中提出“推-拉”理论。人口流动过程中迁出地的推力和迁入地的拉力相互作用形成的合力理论。 三、城镇化的类型：★★★ 从城镇化与工业化发展水平关系来考察，城镇化可分：同步城镇化、过度城镇化、滞后城镇化、低度城镇化和逆城镇化五种类型。（1）同步城镇化。指城镇化的进程与工业化和经济发展的水平趋于一致的城镇化。（2）过度城镇化。又称超前城镇化，城镇化水平明显超过工业化和经济发展水平的城镇化。（3）滞后城镇化。指城镇水平落后于工业化和经济发展水平的城镇化。（4）低度城镇化。指以农业产业为主导，工业基础薄弱的城镇化。（5）逆城镇化。指城市市区人口尤其是大城市市区人口郊区化、大城市外围卫星城镇布局分散化的城镇化。 四、世界城市 ★★ 世界城市：是国际城市的高端形态，是指在城市国际化进程中处于最高层次，能够在世界经济、政治、文化等领域发挥全球性影响的国际城市，又称全球城市。代表：纽约、伦敦、东京。 五、世界城市群 ★★★ 又称“都市圈”、“都市带”、“都市丛”、“大都市连绵区”等，是指人口规模在 2500 万以上和人口密度超过每平方公里 250 人的城市集聚区。（1）田园城市。1898 年，英国城市学家 E. 霍华德出版《明天：通往真正改革的平和之路》一书，提出了田园城市的理论。（2）组合城市。1915 年，英国生物学家、社会学家、教育家和现代城市研究与区域规划理论先驱帕特里克·格迪斯创造了“城市学”的概念。（3）区域整体发展理论。美国学者刘易斯·芒福德继承了格迪斯区域规划思想，创造性地提出区域整体发展理论。（4）城市集中发展理论。法国建筑学家和城市理论家勒·柯布西耶从城市规划视觉角度提出了城市集中发展理论。（5）城市群理论。20 世纪 40 年代初，琼·戈特曼首先对美国东北部海岸波士顿、纽约、费城、巴尔的摩和华盛顿五个较大都市区进行了研究。（6）城乡融合区。20 世纪 80 年代，麦吉等人对印尼、泰国、印度、中国大陆和中国台湾等亚洲国家和地区的大都市周边地区进行了研究，发现中心城市主体及周边地区一起形成了“扩展大都市区”。 第二节 中国城镇化进程一、中国城镇化的三个阶段：★★★（1）第一阶段（1949-1957），平稳起步阶段。（2）第二阶段（1958-1977），大起大落阶段。（3）第三阶段（1978 至今），加速发展阶段。 第三节 中国城镇化道路的选择与小城镇的建设一、中国城镇化道路选择的不同观点：★★（1）大中城市论：根据中国经济发展的现状，在相当长时期内，城镇化的主要动力来源于大中城市的扩张。（2）均衡发展论（又称城市体系网络论）：中国的城镇化应该建立以大城市为领导，以中等城市为骨干，以各类小城镇为基础的多层次、多功能的网络系统。（3）多元模式论：主张城镇化道路应该考虑到巨大的地域差异性。（4）小城镇重点论：中国建设社会主义，从根本上看，首先要把 2/3 的农村剩余劳动力转移到工业方面去，使整个国家的多数人口称为非农业劳动者。 二、促进中国小城镇的健康发展：★★★ 发展小城镇的同时,要注重和加强城镇的规划。《国民经济和社会发展第十一个五年规划的建议》给城镇道路的可持续发展指明了方向： （1）小城镇建设要有科学规划。在小城镇的数量布局、规模把握、功能定位上要很好地规划，防止遍地开花，盲目铺摊子，搞低水平的重复建设。 （2）小城镇建设规模要适度。小城镇建设规模大小，占地多少，基础设施布局等应当严格地进行论证。 （3）小城镇建设要重视生态环境保护。现代化的小城镇建设必须考虑环境科学要求，把环境保护列为小城镇建设的一项重要内容通盘考虑，把小城镇建设为环境优美、交通便利、居住安康、设施相对完善、文明程度较高的生产和生活生活社区。 （4）建立健全健康发展的体制机制。① 建立与城镇化健康发展相适应的财税、征地、行政管理和公共服务等制度；② 加快小城镇住房、就业、医疗、教育和社会保障制度的市场化改革；③ 加大对小城镇建设的投入，在政府引导下主要通过发挥市场机制的作用，引导社会资金投入小城镇开发；④ 在保护耕地和保障农民合法权益的前提下，妥善解决小城镇建设用地；⑤ 改革小城镇管理体制，尽快形成符合小城镇经济社会特点的行政管理体制；⑥ 特别要加强小城镇居民的市民素质教育，使之尽可以地适应城镇文化，承担起城镇建设者的责任。 第十一章 社会分层与社会流动第一节 社会不平等一、什么是社会不平等 ★社会不平等：即社会差别，指个人或群体间的任何差异。 二、社会不平等相关概念：★★★（1）性别：男女两性在生理和心理上的差别。（2）年龄：依据一个人的年龄而确定的地位，称为“年龄地位”。对占某年龄地位的人的行为期望，称为“年龄角色”。（3）种姓：以血统、血缘和职业为标准，将社会成员划分为不同群体或社会集团的社会等级制度。（4）种族：亦称人种，指在体制形态上具有共同生活遗传特征的人群。（5）等级：指按经济地位和政治法律地位不同而相互区别的群体或社会集团。（6）阶级：指的是这样一些集团，它们因为在历史上一定社会生产体系中所处的地位不同、对生产资料的关系不同、在社会劳动组织中所起的作用不同，从而领得自己所支配的那份社会财富的方式和多寡也不同。（7）阶层：一是指阶级内部的层次划分；二是泛指具有不同社会地位的群体。 三、社会分工与社会不平等 ★★马克思和恩格斯的社会分工理论：（1）分工有“自然分工”和“真实分工”之别。从物质劳动和精神劳动分离的时候起，“分工” 才开始成为真实的分工。（2）从“自然分工”到“真实分工”是一个质的飞跃，社会从无阶级社会进入到阶级社会。（3）在“真实分工”出现的同时，产生了产品的不平等分配和私有制。（4）分工的发展导致了物质劳动和精神劳动相分离。（5）物质劳动和精神劳动的最大一次分工，就是城市和乡村的分离。（6）在阶级对立的社会中，分工的发展具有矛盾的性质。社会不平等根源于社会的物质生产方式中，其实质是以生产资料占有关系为核心的生产关系的不平等。 第二节 社会分层一、社会分层的概念 ★社会分层：是社会资源在社会中的不均等分配。 二、社会分层的相关理论 ★★★ 韦伯的社会分层理论：（1）阶级的划分：上层有产阶级、优势职业阶级、小资产阶级、工人阶级；（2）划分的标准：财产占有情况和市场处境（3）社会分层维度：阶级范畴（经济）、地位范畴（社会）、政党范畴（政治） 帕累托的精英理论：将精英阶级分为：执政的精英阶级和不执政的精英阶级。帕累托还提出了精英循环理论。马克思主义的阶级理论：（1）阶级理论是马克思主义的核心组成部分。（2）马克思对阶级分析的新贡献，主要体现在三方面：① 阶级的存在，仅仅同生产发展的一定历史阶段相联系；② 阶级斗争，必然导致无产阶级专政；③ 这个专政本身不过是达到消灭一切阶级和达到无产阶级社会的过渡。（3）马克思的贡献，实际上分别对应着阶级分析的两大研究主题：关于统治阶级剥削的研究以及关于被统治阶级反抗的研究。（4）马克思阶级学说的最重要贡献，是将阶级的存在同生产发展的一定历史阶段，即所有制联系起来，从生产过程的工人与资本家占有生产资料的关系，来揭示阶级的本质。 当代社会分层理论：（1）功能主义的社会分层理论：:社会分层是社会不平等的体现，社会分层之所以在各个时代、各个社会中普遍存在，是因为社会运行过程的需要。提出者：戴维斯和摩尔。（2）冲突论社会分层理论：强调冲突在不平等形成过程中的作用。是社会所固有的。代表：达伦多夫（3）折中的社会分层理论：功能主义和冲突论两家的社会分层理论，未必一定是水火不相容的。既有整合，又有竞争。代表：格尔哈特. 伦斯基。 三、当代中国的社会分层及其变迁：★★ 改革开放前的阶级阶层结构①1949-1952 年，四个阶级：工人阶级、农民阶级、小资产阶级、资产阶级；②1953-1956 年，两个阶级、一个阶层：工人阶级、农民阶级和知识分子阶层；③1977 年，中国社会的阶级、阶层情况：工人阶级、农民阶级、知识分子阶层。 改革开放以来中国社会阶级阶层结构：十个阶层。 第三节 社会流动一、社会流动的概念与类型 ★★★ 社会流动：指社会成员从一种社会地位或职业向另外一种社会地位或职业的变动。索罗金于 1927 年发表的《社会流动》一书，被社会学界认为是第一部用现代观点论述社会流动的著作。 社会流动的类型：（1）垂直流动，指在社会分层体系当中的不同层次之间的上下流动，又称纵向流动（2）水平流动，指在同一个社会分层的层次当中，在同一个层内部的流动，又称横向流动。（3）代内流动，指个人一生中特别是其工作生涯中的社会地位变化。（4）代际流动，指的是子女相对于父母的地位的变动。（5）结构式流动，是由于生产技术或社会体制变革而引起的规模较大的社会流动。（6）自由流动，指那种不是由于体制的变化而是由于个人特殊的原因而导致的社会流动，是在整个社会阶层结构不发生变化的情况下，某些社会成员阶层地位的变化。（7）竞争式流动，作为公开竞争目标的较高的社会地位，需要通过追求者自身努力去获得。（8）赞助式流动，指较高的社会地位不是个人通过竞争可以直接获得，而由已经获得了较高地位的人根据某种既定的标准来授予。（9）个人地位获得模式：美国社会学家布劳和邓肯提出，探讨了代际流动的影响因素。 社会流动的意义：合理的社会流动是现代社会生存和发展所必需的。首先，社会化大生产客观上要求实现劳动力流动和人才流动，实现劳动力的合理配置，其次，在现代社会中，传统的基于个人出身的地位获得模式，正逐步被基于个人业绩的现代模式所取代，社会流动成为个人取得社会地位的重要途径，第三，社会流动加强了个人才能和成就与其社会地位之间的联系，有利于造成一种积极向上的精神，增强社会的活力；第四，社会流动有利于加强各社会集团之间的联系，消除可能存在的社会隔阂，促进社会成员的社会认同，从而对社会发展起到积极的推动作用。 二、当代中国的社会流动 ★★ 影响中国社会流动的因素与机制： （1）三个层面因素的影响：&emsp;&emsp;A. 在宏观层面，受制于社会结构和国家的制度安排；&emsp;&emsp;B. 在中观层面，则依赖于工作单位和家庭；&emsp;&emsp;C. 在微观层面，则取决于个人后天的努力。 （2）前两种因素属于先赋因素，后一种属于自致因素。 （3）社会流动的机制（四种类型）：&emsp;&emsp;A. 制度安排本身导致的社会流动&emsp;&emsp;B. 制度安排与先赋因素、自致因素混合导致的社会流动；&emsp;&emsp;C. 制度安排抑制先赋或自致因素而导致的社会流动；&emsp;&emsp;D. 制度安排中的某些漏洞或偏向，被一部分社会成员利用而导致的社会流动。 当前中国社会流动的特点：（1）社会流动模式发生重大改变。改革前与改革后，中国经历了两种社会流动模式：政治主宰型的社会流动模式和经济诱致型的社会流动模式。（2）社会结构从封闭迈向开放。（3）社会流动呈向上流动的趋势。改革开放以来，我国的职业结构也正经历着符合工业化国家发展趋势的高级化过程，表现为高层次的职业位置数量大幅增加。（4）当前，中国社会流动仍然受制于社会转型和体制转轨，带有明显的转型特点。（5）值得注意的是，当前中国的社会流动正在表露出一些不利于社会开放、公正的消极趋向。 第十二章 偏差行为与社会控制第一节 什么是偏差行为一、偏差行为的概念 ★ 偏差行为：指在特定社会中社会成员不同程度地偏离或违反了既有的社会规范的行为，也被称为越轨行为、离轨行为或差异行为等。 二、偏差行为类型：★★★ 按照偏差行为的表现方式可分为：（1）偏差习惯是指个人行为嗜好因不为社会所认可而表现出来的行为。（2）偏差心理是指因为心理或精神的原因导致无法进行常规的社会交往或社会活动所表现出来的行为。（3）偏差文化是指以与社会主流或主导文化所不同的文化表现出来的行为。 按行为所偏离的社会行为准则的标准可分为（1）违法行为是指违反国家法律条文的行为，包括犯罪和未构成犯罪的违法行为。（2）违章行为是指违反有关维护社会治安和公共秩序的规章条例的行为。（3）违规行为是泛指一切违反既定的生活方式、风俗习惯的行为。 三、偏差行为的功能 ★★★ 偏差行为负功能：（1）干扰正常的社会生活秩序； （2）损害个人和社会的利益；（3）减弱他人遵从规范的意愿； （4）破坏社会成员间的相互信任。 偏差行为正功能：（1）有助于人们进一步认识社会规范； （2）有助于加强社会团结；（3）有助于社会预警； （4）有助于促进社会进步。 第二节 偏差行为的理论解释一、偏差行为的生物学解释及其根本缺陷 ★ 偏差行为的生物学解释：生物学解释是从个人的生物性和生理性特征来解释偏差行为发生的原因，它假定有些人天生就是不守规矩的人，因而要着重于寻找偏差行为者的个人生理特质，尤其强调遗传因素的作用。提出者：隆布罗索。 二、偏差行为的心理学解释 ★ 偏差行为的心理学解释：重视个人的精神、情绪、性格等心理因素对行为的影响，认为偏差行为是因为个人心理方面没有能力去学习和遵守有关的社会规范。代表是弗洛伊德，他把偏差行为的理论分为两种：精神分析理论和行为理论。 三、偏差行为的社会学解释 ★★★ 失范理论：认为存在两种社会规范，一种使社会对个人所追求目标的规范；另一种是对个人追求目标所使用手段的规范。代表人物是默顿，分为五种适应方式：遵从、革新、形式主义、退宿主义、反叛。默顿的失范理论：（1）观点：认为存在两种社会规范，一种使社会对个人所追求目标的规范；另一种是对个人追求目标所使用手段的规范。（2）五种适应方式：遵从、革新、形式主义、退宿主义、反叛。A 遵从者，是以社会允许的方式获得社会鼓励的目标。B 革新者，为了追求社会鼓励的目标，采用了社会不被认可的手段，甚至是违法的手段。C 形式主义，是拒绝社会提供的目标，但仍然遵守社会规范的手段行事。D 退缩主义，是既放弃了社会鼓励的目标，也抛弃了社会认可的手段。E 反叛，是指不仅拒绝社会认可的目标和手段，而且试图从个人观念出发，以新的目标和手段来代替。 文化传递理论：又称为亚文化理论，这个理论认为偏差行为者表现出来的偏差行为是从其所处的文化环境中习得的，他们不是偏离了社会规范，而是遵循着所在的团体的社会规范，他们的行为之所以被视为偏差行为，只是因为他们所在团体的规范和主流的社会规范不一致，甚至是矛盾的。代表：弗洛伊德 标签理论：一种行为之所以被视为偏差行为，是因为社会的权力集团给这种行为贴上了偏差的标签，偏差行为只是一种被社会定义为偏差的行为。代表：莱蒙特。类型：初级偏差和次级偏差。 第三节 社会控制一、什么是社会控制 ★★★ 广义的社会控制：是指社会组织通过社会规范以及相应的方式和手段，对社会成员的社会行为进行指导和限制，对各类社会关系加以调节和制约、对社会成员的价值观进行引导和约束的过程。 社会控制的特点：普遍性、规范性、多重性。社会控制的提出者：罗斯。 社会控制必要条性：（1）首先表现在社会生活中个人与个人之间、个人与社会之间的目标不一致上；（2）其次，社会控制的必要性表现在稳定各种社会关系上；（3）最后，社会控制的必要性还体现在制止社会生活中各种失控现象方面。 二、社会控制的类型：★★★ 宏观控制：是指社会利用政权、法律、政策、条令等手段对整个社会在总体上加以控制，包括政治、经济、文化和意识形态等方面的控制。 微观控制：是相对于宏观控制而言，在社会生活的各个具体领域所实现的控制，这些领域涉及人们最基本的社会生活需求。 制度化控制：指按照一整套条文规定，有某种组织体系加以推行的一种社会控制形式。 非制度化控制：指社会控制的形式并不以明文规定的条文来实现，而是通过社会成员日常互动所形成的共识来实现。 外在控制：指利用外部社会力量促使社会成员遵从社会规范。 内在控制：指行为者个人将社会规范内化为自己持有的观点，从而自觉地按照社会规范的要求约束自己的社会行为。 积极性控制：指利用奖赏性手段来鼓励社会成员按照社会规范行事。这些手段包括物质性奖励和精神性奖励。例如学校为了促使学生努力学习，建立奖学金、跳级等激励机制来奖励学习成绩优秀的学生，同时也鼓励其他学生迎头赶上。 消极性控制：指利用惩罚性手段来防治社会成员的偏差行为。 三、社会控制的方式：★ 法律控制、道德控制、习俗控制、宗教控制。 四、社会控制的适度问题：★★★（1）社会控制是对人们的社会行为加以指导和约束的过程，因而涉及个人和社会的关系问题。社会控制过强会牺牲个人的利益，而社会控制过弱会牺牲社会的利益。由此社会控制的适度问题就摆在我们的面前，也就是说，要避免社会“失控”或者社会“过控”。（2）社会过控，是指过分强调了社会控制的一面，忽视了社会成员的个性表达及自由要求的一面。社会失控，是指社会控制相对削弱，社会成员的自由散漫性提高。这两种情况都不利于社会关系的协调，不利于社会整体效应的发挥，应当努力避免，一旦发现要及时克服和纠正。（3）但是，什么情况属于过控，什么情况属于失控，并没有一个绝对的标准。要理解这个问题，必须看到社会控制和个人自由之间的辩证关系。从绝对意义上看，社会控制和个人自由似乎是水火不容的一对矛盾，社会控制总是制约和限制了个人的自由。但是必须认识到，任何社会中个人的自由都不是绝对的，个人的绝对自由也是不可能实现的。因此社会控制仅仅是限制和制约了个人的绝对自由，而并没有限制和制约个人的相对自由。（4）合理适度的社会控制有助于人的个性全面发展以及创造性的发挥，也有助于社会稳定繁荣。反之，则是对个性的压抑，不利于社会进步。 第十三章 社会问题第一节 什么是社会问题一、社会问题的界说 ★★★ 社会问题：是指因个人与社会关系在社会进程中发生了障碍或社会结构与社会环境失调，造成了影响社会全体或部分成员正常生活的问题。1941 年，美国社会学家理查·富勒和理查·麦尔兹在《社会问题的发展》一文中指出，所有社会问题都要经过警觉、政策制定和改革三个阶段。 社会问题与个人困扰的区别:（1）个人困扰必须和个人的自我联系在一起，只关系到个人直接体验的有限的社会生活领域；而“社会问题所牵涉的事情超出个人的局部环境，超出个人的生活领域”。（2）困扰只涉及个人，即个人感到自己所珍重的价值受到威胁；而社会问题涉及的是公众，即公众所共同珍重的某个价值受到威胁。（3）“个人困扰具有个人的特点，它只发生在个人与他人直接构成的关系区域里”；而社会问题具有公众的特点，它常常包含着制度上、结构上的危机，也常常包含着马克思所说的“矛盾”和“斗争”。 二、社会问题的一般特征：★★★ （1）社会性从三方面来理解：社会问题的产生；社会问题的影响；社会问题的消除。 （2）普遍性社会问题无所不在，无时不有。无所不在，是指在空间上普遍性的表现，即社会问题在任何社会、任何民族、任何国家和地区里都是普遍存在的。无时不有，是指时间上普遍性的表现，即从人类社会诞生之时起，社会问题就始终伴随着社会的变化发展。例如贫困问题。 （3）特殊性这是相对于普遍性而言的。在特定的时间、特定的地区，可能会产生特定的社会问题。例如人口问题。 （4）集群性是指社会问题往往不是单个独立地出现，而是呈群状出现，这时的社会问题的破坏性程度更大。 （5）复杂性任何一个社会问题的出现都不是一个单一的孤立的现象，其复杂性表现为问题的产生原因、表现形式、社会后果及解决条件的复杂多样。 三、社会问题研究理论：★★★ （1）社会病理学：理论基础主要是社会有机体理论，它把违背道德期望的人和事物视为“病态的”，也就是社会问题。对于社会病理学来说，社会问题产生的直接原因都是人的社会化的失败，个人的社会化结果违背了社会的道德期望。 （2）社会解组理论：社会问题最有效的解决方法是尽快建立社会规范和秩序，重建社会的均衡体系。所谓社会解组，是指社会中的各种规则对约束个人的行为失去了效力，社会既不能提供给人们以预期的奖赏和回报，也不能对违规的行为加以惩罚。 （3）价值冲突理论：认为由于所处的社会经济地位和既得利益的不同，人们对同一问题可能会有不同的价值评判标准和不同的立场、态度，因此在采取某种行为措施改变某一社会现象时，常常会引起矛盾和冲突，而这种矛盾和冲突往往发生在群体之间。而所谓社会问题，是一种被相当多的人认为是偏离于他们所持有的价值观念的社会状况。这一理论的持有者认为文化价值或兴趣上的冲突是造成社会问题的根本原因，提倡研究社会实际存在的利益关系。 （4）行为偏差理论：把社会问题看作偏离社会规范的偏差行为的结果。 （5）社会构建理论：不存在客观意义上的社会问题，所谓社会问题是人们主观建构出来的，社会问题仅仅是人们对某种社会情况的界定过程的主观产物，因此研究社会问题的社会学家真正面对的研究对象不是社会问题本身，而是某种情况如何被定义为社会问题的社会建构过程及其客观条件。 第二节 当代社会问题一、结构性问题：★指社会制度或政策失调诱发的社会问题。如腐败、失业、老龄化、贫困等问题。 二、偏差性社会问题：★指个体偏离或违反一定社会行为规范造成的社会问题。如毒品、食品安全、贪污等问题。 三．自然性社会问题：★也就是自然灾害问题，指一种人类无法控制的力量造成的社会问题。特征：潜在性、突发性、有限性。 第三节 社会问题的防治一、社会问题防治的性质 ★社会问题防治：对显露或潜在的社会问题进行科学分析，采取相应的对策和手段，避免、减少社会问题的发生或使社会问题得以缓解和解决的综合治理过程。 二、社会问题防治意义：★★（1）可以有效地维护社会秩序与社会稳定问题，增强社会和民众的安全感；（2）可以避免和减少社会问题给社会造成的损失，包括直接的和间接的损失，物质和精神的损失；（3）可以保障社会主义现代化大业；（4）可以促进社会主义精神文明建设；（5）可以改善、提高有关机构的应对能力和效率。 三、社会问题防治的战略措施：★★（1）解放和发展生产力。 （2）改革上层建筑和意识形态。（3）发展科学技术。 （4）完善社保制度，缓解后顾之忧。（5）建立社会预警系统。 （6）发挥舆论监督的作用。 第十四章 社会变迁第一节 什么是社会变迁一、社会变迁的含义与特征 ★★★ 社会变迁：是个人与社会的关系基本形态的变异。 社会变迁特点：（1）必然性。社会变迁是社会运行过程中的一种必然现象，是不可抗拒的，不以人的主观意志为转移的。（2）前进性。社会变迁总的趋势是前进的，即由低级向高级、落后向先进的方向运动。（3）非直线式。社会变迁的具体道路并非直线式的，往往有曲折，呈波浪式的态势。（4）全面性。社会变迁涉及社会的各个方面，是一种全面性的变化。 二、社会变迁的基本类型：★★ .table-c table{border-right:1px solid #dbdbdb;border-bottom:1px solid #dbdbdb} .table-c table td{border-left:1px solid #dbdbdb;border-top:1px solid #dbdbdb} .table-c table td.td1{text-align:center;vertical-align:middle;} 划分标准 类型 含义 社会变迁的发展方向 社会进步 人类社会由低级向高级合乎规律的前进运动，社会形态的更替是社会进步的过程。 社会倒退 社会局部或整体，从已经达到的较高发展阶段向较低发展阶段变化的过程。 社会变迁的性质与特点 社会改革 人们有意识地规划并在较短时间内实现的社会局部调整或全面改良的过程。 社会革命 一种急剧的、对全社会进行根本改造的社会变迁形式。 社会变迁的规模 整体变迁 整个社会体系的变化，是各个社会要素变化合力的结果。 局部变迁 社会要素及它们之间相互关系的变化，如经济体制、政治体制和文化体制等方面发生的变化。 人为参与与控制程度 有计划变迁 被动地参与或盲目地顺从社会变迁。 局部变迁 人类有意识、有目的地参与或控制社会变迁。 三、有计划社会变迁 ★★★ 社会发展计划是对社会发展总的方向、大目标、主要步骤与重大措施的设想。社会有计划地发展与变化是现代社会的基本特征之一。从 1981 年起把“国民经济发展计划”改为“国民经济和社会发展计划”，表明计划工作比以前更加完善、更加提高、更加深入、细致和广泛了。 第二节 社会现代化一、社会现代化的内涵与特征 ★★★ 社会现代化：是指由传统农业社会向现代工业社会的变迁过程,是在社会分化的基础上,以科学技术进步为先导,以工业化、城市化、民主化和知识化等为主要内容,经济与社会协调发展的社会变迁过程。 社会现代化的构成子系统：工业化、城市化、民主化、管理科学化、社会结构分化、人的现代化、生活方式的世俗化。 社会现代化的特征：（1）现代化是一项社会领域的革命进程；（2）现代化是一个长期的、有阶段的历史过程；（3）现代化是一场持续的国际竞赛。 二、社会现代化理论：★★★ 经典现代化理论：二战后以西方发达国家现代化过程为研究对象形成的理论成果统称。 依附理论：二战以后独立的发展中国家没有像经典现代化理论说的那样实现现代化，要么不发达，要么严重依附于发达国家。 世界体系理论：(沃勒斯坦)沃勒斯坦为该理论的代表。该理论指出：发达国家与发展中国家的依附是双向的；把世界划分为“中心”、“半边缘”、“边缘”三个等级；世界体系是变化着的。 信息社会论：(施赖贝尔/法国, 托夫勒, 纳斯比特)1980 年法国的 施赖贝尔 根据巴黎小组研究成果写出的《世界面临挑战》、美国学者 托夫勒 的《第三次浪潮》和美国学者 纳斯比特 的《大趋势》是系统论述信息化社会的代表著作。“信息社会论”认为，人类社会由工业社会进入信息社会是一个重要的转折。信息社会同工业社会相比，有三个主要特征：信息成为战略资源，在国民经济中占主要地位。整个社会以知识价值论为基础，价值的增长主要依靠知识。先进的通讯与信息系统成为社会改革的手段，给人们的生活方式与工作方式带来一场变革。 后工业社会论：(丹尼尔·贝尔 美国)丹尼尔·贝尔认为后工业社会有五个特征：经济方面从产品经济转变为服务性经济；专业与技术人员处于主导地位；理论知识处于社会中心地位；控制技术发展,对技术进行鉴定；创造新的“智能技术”。 第三节 全球化一、全球化的涵义与特征 ★★ 全球化：指在全球范围内展现的涉及政治、经济、文化、社会等各个领域的客观历史进程和趋势，同时也是世界共同体的各个国家和地区彼此之间的交往关系进一步加强、彼此之间的依存性、关联性程度不断加深的过程。 全球化的特征：（1）全球化是一个客观的历史进程；（2）全球化是一个多维度的过程；（3）全球化是世界各国的共同性与差异性相统一的客观要求；（4）全球化过程是一个不断出现矛盾和冲突的过程。 二、全球化的发展阶段：★（1）萌芽阶段。从 15 世纪末期到 18 世纪中期。（2）开始阶段。从 18 世纪中叶到 19 世纪 70 年代。（3）起飞阶段。从 19 世纪 70 年代到 20 世纪 60 年代中期。（4）增强阶段。从 20 世纪 60 年代后期至今。 三、全球化与中国：★★★ 全球化对中国的冲击和挑战：① 中国经济增长过于依赖贸易。② 在政治方面，由于中国是社会主义国家，经济的高速增长动摇了西方霸权的地位，引起它们的恐慌。③ 随着中国对全球化参与程度的加深，中国的文化建设受到了两方面的挑战。④ 国家安全方面，目前还存在着霸权主义、强权政治等影响世界和平的因素，我们所面临的国际安全环境并不太乐观。 面对全球化的应对策略：① 必须明确中国在全球化进程中的位置,以此为制定全球战略的前提。② 要不断解放思想、深化改革、发展自己。③ 增强综合国力以确保国家安全。 第十五章 社会制度第一节 什么是社会制度 概念：基于一定的价值标准而设立和形成的一套相对稳定的、模式化的、被人们习惯和自觉遵守的规范体系。 起源：社会制度产生的基础应当是社会生产和再生产的方式。从人类需要的角度去探究社会制度的起源是比较合适的，因为任何社会制度都是为适应一定条件下的人类需要而产生的。但是如果仅仅把目光停留在人类需要上，忽略满足需要的手段和途径，就无法从根本上解释社会制度的变异性。 形成的途径：① 自发形成，从民俗升格为民德，再从民德发展为制度；② 立法产生，属于上层建筑的社会制度如政治、思想文化等，一般立法产生。 构成要素：(1)价值要素（价值标准）：指主体对客体的有用性以及用出大小的判断。(2)规范要素：标准、规则和模式，是一系列有关角色行为规范的决定。(3)组织要素：是社会制度的实体部分，是价值和规范的载体。包括组织领导、职能机构和组织成员。(4)设备要素：社会制度运行的物质基础。分为：象征性物质设备、运行性物质设备。 基本特征：① 社会制度的核心是价值标准；② 社会制度是非人格化的权威力量；③ 社会制度具有稳定性和差异性；④ 社会制度具有抑扬性。 基本功能：① 行为导向功能；② 行为调控功能；③ 文化创新功能；④ 社会化促进功能 第二节 社会的基本制度(1) 社会制度的分类： 按照形成方式，分为自发产生的制度和根据客观历史需要而有计划建立的制度。 按照形成的历史过程及其对个性形成产生的影响，分为① 本源制度：指反映并决定其他一切关系的基础的原始的关系——生产关系以及与其紧密相连的经济活动的规范和制度，包括婚姻家庭制度和经济制度。② 派生制度：建立在本源制度基础上的其他一切制度，如政治制度、教育科学制度 按照社会制度的具体性质和作用，分为：婚姻家庭制度、经济制度、政治制度、教育制度、思想文化制度 (2) 从人类生存与发展对制度的需求层面看，最基本的社会制度是以下五种： 家庭制度（生育制度）概念：是关于家庭的性质、形式、关系、功能、权利和义务的一整套规范体系。功能：繁衍人口，禁止乱伦，提高人口素质。目前中国家庭制度的主要特征：① 家庭结构和功能的过渡性；② 家庭关系和分工的过渡性；③ 家庭问题的复杂性 经济制度（生存制度）概念：是社会用以限制调节或促进人们生产分配交换和消费行为的社会规范体系。功能：包括规范经济活动调整经济关系保障社会生产和再生产的持续发展，为人类社会的生存与发展提供物质基础内容：① 对财产所有权的规定② 对社会经济活动中的劳动分工的规定③ 对社会经济运行中交换活动的规定④ 对市场运行的规定⑤ 对经济活动中相互承诺的规定。 教育制度（发展制度）概念：是社会的启导延续和发展制度是社会制度体系中的重要组织部分，是社会传授知识与科学提高人的科学文化素质的社会规范体系及其组织机构的总和，它的目的主要是把人类长期积累的知识和科学技术代代相传并使之发扬光大，通过人的素质培养促进社会进步。功能：① 外显功能（传授知识与科学技术的功能；实现社会化的功能；文凭功能；社会选择功能）；② 内潜功能（社会控制功能；调整、协调社会职业体系和社会分层体系；缩小收入差距；吸收剩余劳动力） 政治制度（主导制度）概念：是国家权力如何产生如何行使和有关权力结构的规定，由国家颁布并强制执行的，用以约束社会成员和群体活动的规范体系。功能：① 规范社会秩序 ② 管理公共事务。 宗教制度（信仰制度）概念：是包括宗教观念、信仰、宗教仪式以及宗教组织形式在内的规范体系。 第三节 社会制度的变革与创新 社会制度的生命周期：就是指一种具体的社会制度从产生、发展、成熟、消失，最后被新的制度替代的过程。 社会制度变革与创新的规律：① 偶然性和必然性的统一；② 历史和逻辑的统一；③ 量变和质变的统一；④ 可能性和现实性的统一。 改革开放以来我国社会变革与创新的主要表现转型期我国社会制度变革与创新的特征：① 国家和政府在制度创新中的权威作用加强。② 各种社会群体的利益在制度创新中重新定位。③ 调动人民群众的积极性、主动性、创造性，实现好维护好发展好人民群众的利益，是一切制度创新的出发点和归宿。","link":"/2021/01/14/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/%E7%A4%BE%E4%BC%9A%E5%AD%A6/%E7%A4%BE%E4%BC%9A%E5%AD%A6%E6%A6%82%E8%AE%BA%E6%80%BB%E7%BB%93/"},{"title":"公务员制度知识梳理","text":".table-c table{border-right:1px solid #dbdbdb;border-bottom:1px solid #dbdbdb} .table-c table td{border-left:1px solid #dbdbdb;border-top:1px solid #dbdbdb} .table-c table td.td1{text-align:center;vertical-align:middle;} 第一章 公务员制度的产生知识点总结 我国推行公务员制度的意义(1) 为坚持党的基本路线提供组织保证(2) 为国家机关的廉政建设提供有效保障(3) 对国家机关的民主化、科学化、法制化建设起促进作用。 我国公务员制度产生的原因(1) 市场经济需要职业化、高素质的人才 (2) 我国原有干部人事制度不能适应市场经济的需要。 资本主义国家公务员制度形成的原因(1) 从经济上看，公务员制度适应了资本主义市场经济发展的需要(2) 从政治上看，公务员制度适应了资产阶级正常政治的需要(3) 从管理方式变革上看，公务员制度适应了资产阶级保持局面稳定和提高行政效率的需要 我国推行公务员制度的指导思想(1) 坚持邓小平理论与三个代表重要思想(2) 继承和发展我国干部人事管理的优良传统，并吸收和总结了十多年来我国干部人事制度改革的成功经验。(3) 学习和借鉴国外人事管理的有益经验和科学做法。 我国公务员制度对原干部人事制度的继承(1) 坚持党的基本路线(2) 坚持党管干部的原则(3) 坚持德才兼备的用人标准(4) 坚持全心全意为人民服务的宗旨(5) 坚持中国特色的分类制度。 我国公务员制度对原有干部人事制度的发展(1) 实行分类管理体制 (2) 实行激励竞争机制 (3) 实行新陈代谢机制 (4) 实行勤政廉政保障机制 (5) 法制化管理体制。 一、公务员制度的概念公务员的含义：在我国，除港澳台以外的内地或大陆上，公务员是指依法履行公职、纳入国家行政编制、由国家财政负担工资福利的工作人员。 公务员制度的含义：指国家对公务员的管理制度，包括通过制定法律规范，对公务员的“进口”管理、使用管理与“出口”管理的各项管理制度。 我国公务员的范围：政府机关、共产党机关、人大机关、政协机关、民主党派机关、审判机关、检察机关中除工勤人员以外的工作人员。在我国“参照管理”的机关：人民团体，如工会机关、共青团机关、妇联机关等。 应用：运用公务员概念，从工作人员中正确挑选出具有公务员身份的人员。 二、我国推行公务员制度的指导思想指导思想包括的内容：(1) 坚持邓小平理论与“三个代表”重要思想(2) 继承和发展我国干部人事管理的优良传统，并吸收和总结了十多年来我国干部人事制度改革的成功经验(3) 学习与借鉴国外人事管理的有益经验和科学做法。 坚持马克思主义中国化理论为指导的重要性：坚持马克思主义中国化理论为总的指导思想，贯穿在公务员法的总则、权利与义务以及各个管理环节中。通过建立和推行公务员制度，达到有利于我国社会主义国家政权的巩固和长治久安，有利于改革开放事业的发展和解放与发展生产力，有利于社会主义市场经济充分发展，有利于全面建设小康社会和构建社会主义和谐社会。因此，坚持正确指导思想是公务员制度的灵魂。 三、英国公务员制度的产生英国市场经济的形成与发展 英国资本主义市场经济与公务员制度产生的关系 四、我国公务员制度的产生 我国原干部人事制度的弊端：随着社会主义现代化建设事业的发展，特别是党的十五届三中全会以来改革开放的深入进行，这种干部人事制度的弊端开始明显地暴露出来，诸如干部范围过宽，缺乏科学分类 管理权限过分集中，管人与管事脱节 管理方式单一陈旧，阻碍人才成长 管理制度不健全，科学化、民主化、法制化程度不高等等。 我国公务员制度与社会主义市场经济的关系：我国在 1993 年被告公务员制度以后，政府与企业的关系已逐步从过去的运用行政手段直接管理转变为间接管理，政企分开了，企业得以走向市场，平等竞争、优胜劣汰，成为自主经营、自负盈亏、自我约束、自我发展的商品生产者与经营者，成为市场的主体。因此，大部分亏损的国营企业已经扭亏为盈。这种市场经济的发展，客观上要求有一个符合现代化要求，具有功能齐全、结构合理、运转协调、灵活高效的政府人事管理体系，对其进行宏观规划、协调与监督，而我国推行公务员制度 10 多年来的事实证明，这种新型的政府人事管理制度，正适应了经济管理现代化的要求，已经大大促进了社会主义市场经济的发展。因此，我国社会主义市场经济与具有中国特色的公务员制度，是两种相互协调，促进社会主义事业发展的经济与政治制度。 五、我国公务员制度对原干部人事制度的继承 我国原干部人事制度的优良传统：坚持党的基本路线 坚持党管干部的原则 坚持德才兼备的用人标准 坚持全心全意为人民服务的宗旨 坚持中国特色的分类制度 我国公务员制度的特点与原干部人事制度优良传统的一致性 六、我国公务员制度对原干部人事制度的发展我国公务员制度对资本主义诸国公务员制度借鉴的管理原则 应用：将我国借鉴西方诸国公务员的五种管理制度与我国原干部人事制度对比，说明其科学性： 实行分类管理体制：这是针对我国传统的高度集中的人事管理制度弊端所进行的改革。实行分类后，公务员只包括各级政府机关与共产党、权力、审判、检察、政协机关中除工勤人员以外的工作人员，而工、青、妇机关及其他一些机关的干部只是参照公务员制度进行管理，但不在公务员的范围之内。 实行激励竞争机制：这是针对我国原干部人事管理长期存在的端“铁饭碗”、坐“铁交椅”，而缺乏生机和活力所进行的改革。实行公务员激励机制，从公务员“进口”管理到使用管理的诸个环节，都鼓励竞争。对公务员的考核，依德、能、勤、绩、廉全面进行，重点是考绩，按优秀、称职、基本称职与不称职等四个等效确定其年度考核结果，以此作为奖惩、培训、辞退以及调整职务和工资的依据。 实行新陈代谢机制：针对我国原干部人事管理遗留的能进不能出、能上不能下以及领导任职年龄偏高等弊端而进行的改革。实行公务员的新陈代谢机制后，公务员的录用、交流、晋升等规定，从“进口”上严格把关，选拔优秀人才充实公务员队伍，较好地解决了吸收新鲜血液、增加新的活力的问题。 实行勤政廉政保障机制：针对我国原国家机关及其工作人员中滋生的消极、腐败现象所进行的改革。从制度上促进公务员勤政为民，廉洁奉公，保证了各级国家机关及公务员队伍形成既有一心为公的高效率的工作作风，又有为政清廉、为民谋福利的良好形象，从而使以往那种“出勤不出力”的陋习得以纠正与克服，为政不廉的腐败现象得以防止和消除。 实行法制化管理体制：针对原干部人事制度存在着人治弊端所进行的改革。以前国家机关人事管理体制与运行机制中，从总体上来看缺乏配套的法律化、制度化的规范体系，带有一定的主观随意性。建立公务员制度后，可以改变过去人事管理中法规不健全的状况。 第二章 公务员义务与权利知识点总结 规定公务员义务与权利的意义(1) 有利于形成一支优化、廉洁、稳定、高效的公务员队伍(2) 既是对公务员执行公务的有力约束，也是对公务员执行公务的有力保障(3) 有利于实现公务员管理的法制化、民主化、科学化。 规定公务员义务的原则(1) 违法必究原则 (2) 平等原则 (3) 服务与稳定原则。 我国公务员的义务(1) 忠于宪法的义务：模范遵守宪法和法律(2) 依法履职的义务：按照规定的权限和程序认真履行职责，努力提高工作效率(3) 为民服务的义务：全心全意为人民服务，接受人民监督(4) 忠于国家的义务：维护国家的安全、荣誉和利益(5) 服从命令的义务：忠于职守，勤勉尽责，服从和执行上级依法作出的决定和命令(6) 保守秘密的义务：保守国家秘密和工作秘密(7) 保持操行的义务：遵守纪律，恪守职业道德，模范遵守社会公德(8) 公正清廉的义务：清正廉洁，公道正派(9) 法律规定的其他义务。 公务员的法律责任(1) 身份处分：丧失公务员身份(2) 行政处分：承担行政责任，包括名誉、职级等(3) 赔偿责任：公务员因故意或过失使所管财务遭到损失，或因执行公务不当给行政相对人带来财产损失(4) 刑事责任：公务员因职务犯罪承担刑事责任。 规定公务员权利的原则(1) 保护原则 (2) 民主原则 (3) 权利可放弃和不可放弃原则。 我国公务员的权利(1) 获得工作条件权：获得履行职责应当具有的工作条件(2) 身份保障权：非因法定事由、非经法定程序，不被免职、降职、辞退或者处分(3) 获得报酬权：获得工资报酬，享受福利、保险待遇(4) 参加培训权(5) 批评建议权：对机关工作和领导人员提出批评和建议(6) 申诉、控告权：提出申诉和控告(7) 申请辞职权(8) 法律规定的其他权利。 公务员权利的法律保障(1) 行政复议 (2) 申诉 (3) 控告 (4) 诉讼。 一、公务员义务权利的含义与意义公务员义务：是国家通过法律规定的，对公务员必须作出一定行为或不得作出一定行为的约束和强制。具有非自主性、规范性和强制性三个要素。 公务员权利：是国家通过法律规定，对公务员可以享受某种利益或者可以作出某种行为的许可与保障。具有自主性、规范性和保障性。 了解公务员义务与权利的意义：(1) 规定公务员的权利与义务有利于形成一支优化、廉洁、稳定、高效的公务员队伍。(2) 规定公务员的权利与义务，既是对公务员执行公务的有力约束，也是对公务员执行公务的有效保障。(3) 规定公务员的权利与义务有利于实现公务员管理的法制化、民主化、科学化。 二、公务员义务的内容(1) 规定公务员义务的原则：违法必究原则 平等原则 服务与稳定原则。(2) 依法履职义务：中国《公务员法》对此项义务的表述：公务员应当履行“按照规定的权限和程序认真履行职责，努力提高工作效率”的义务。(3) 服从命令的义务：中国《公务员法》对此项义务的表述：公务员应当履行“忠于职守，勤勉尽责，服从和执行上级作出的决定和命令”的义务。 九项义务各自的核心要求： (1) 忠于宪法义务：要求公务员树立宪法至上和法律至上的思想，应该成为遵守宪法和法律的楷模，以自身的言论与行为维护宪法的权威与促进宪法的落实。 (2) 依法履职的义务： 两项要求：一是“按照规定的权限和程序认真履行职责”，二是“努力提高工作效率”。 (3) 为人民服务的义务： 公务员应当履行“全心全意为人民服务，接受人民监督”的义务。 (4) 忠于国家的义务： 应当履行：“维护国家的安全，荣誉和利益”的义务。 核心要求：忠于国家，就是说，作为公务员，无论是在对内执行公务过程中，还是在对外交往过程中，都要站在国家和政府的立场上， 一方面要保证自己的每项工作和每个行为不会危害国家的安全、荣誉和益，另一方面要抵制他人危害国家安全、荣誉和利益的言论和行为。 (5) 服从命令的义务：应当履行“忠于职守，勤勉尽责，服从和执行上级依法作出的决定和和命令”的义务。 (6) 保守秘密的义务：应当履行“保守国家秘密和工作秘密”的义务。 (7) 保持操行的义务：应当履行“遵守纪律，恪守职业道德，模范遵守社会公德”的义务。 本质是要求公务员不论职务内外，要重廉耻，不得有失信于人民的行为，重点是要求公务员知廉耻。 (8) 公正清廉的义务：应当履行“清正廉洁，公道正派”的义务。 (9) 其他法定的义务：“法律规定的其他义务”。 按照规定的权限和程序认真履行职责：是法治国家和法治政府的基本要求，公务员的权限只能是法律明文规定的、只能在法律明文规定的范围内行使并且只能根据规定的步骤、顺序和方式行使，不存在法外权限，不存在法外程序。 服从和执行上级依法作出的决定和和命令：服从命令的义务要求公务员在执行职务的过程中，必须遵从上级依法作出的决定、决议、指示(令) 、通告(知) 等一般性命令和针对特定公务员的个别性命令，以保证行政事务执行的统一性和效率性。一般性命令是上级行政机关或其领导人员发布的对下级行政机关及其公务员普遍适用的，通常以书面形式发布，发布的上级不仅仅指直接上级，而指具有指挥命令关系的各层上级机关及其领导人员 个别性命令是上级行政机关或其领导人员针对特定的下级行政机关或特定公务员发布的，通常指直接上级通过书面形式或口头形式发布。 上级命令应当具有合法性：即权限合法、内容合法、程序合法。 保守秘密的义务涉及的两对矛盾：一是公务员保守秘密义务和公民享有知情权之间的矛盾 (解决：要求国家通过法律明确规定什么信息是国家秘密，要求国家通过规章制度明确规定什么信息是工作秘密)二是公务员保守秘密和依法作证之间的矛盾。(解决：法律对此作出明确的规定) 不履行义务的法律责任：(1) 身份处分：即丧失公务员身份。(2) 行政处分：即承担行政责任，包括名誉、职级等处分。(3) 赔偿责任：即管理特定财物的公务员因故意或过失使所管财物遭到损失，或因执行公务不当给行政相对人带来财产损失的，则往往需与国家机关共同承担。(4) 刑事责任：即公务员对其职务犯罪要承担刑事责任。 应用：运用公务员义务的相关知识分析现实中与公务员义务相关的问题。 三、公务员权利的内容(1) 规定公务员权利的三原则：保护原则 民主原则 权利可放弃与不可放弃原则。(2) 身份保障权：又称职务保障权，即国家的任命行为一经产生，公务员的职务或身份就受到国家法律的保障，非因法定事由和非经法定程序不受职务或身份处分(免职、降职、辞退、处分) 。(3) 劳动报酬权：即公务员在履行法定职责基础上，享有工资报酬、享受保险和福利待遇的权利，它包括两个方面内容：劳动报酬的决策参与权(中国公务员不享有) (主要是工资决策参与权) 和劳动报酬的获得权。 (1) 八项权利各自的具体表达： 获得工作条件权：享有“获得履行职责应当具有的工作条件”的权利。把握：第一，公务员所享有的工作条件与公务员所履行的工作职责相应相称 第二，工作条件的变动性 第三，工作条件的公用性。 身份保障权：享有“非因法定事由、非经法定程序，不被免职、降职、辞退和处分” 获得报酬权：“获得工资报酬，享受福利、保险待遇” 参加培训权：享有“参加培训”的权利。 批评建议权：“对机关工作和领导人员提出批评和建议” 申诉控告权：享有 “提出申诉和控告” 的权利。申诉人事处理，控告侵犯合法权益。 申请辞职权：“申请辞职” 其他法定权：“法律规定的其他权利” 身份保障权的意义：法律赋予公务员身份保障权是当代公共人事制度的重要特征之一，是对传统人事制度中有任免权者拥有完全自由免职权和处分权的否定，其基本目的是限制有任免权者的免职权和处分权，以确保公务员职务或身份上的独立性或相对独立性。 劳动报酬获得权和工资决策参与权：批评建议权：以“公民”身份活动时可以对任何国家机关及其工作人员提出批评建议权。 (2) 公务员权利的法律保障：行政复议 申诉 控告 诉讼权。 应用：运用公务员权利的相关知识分析现实中与公务员义务相关的问题。 第三章 公务员职务与级别知识点总结 我国设置公务员级别的目的(1) 为公务员管理提供科学的管理基础 (2) 增强职务和级别的激励作用 (3) 便于借鉴国外公务员分类制度的合理因素。 职位分类的作用(1) 为职务设置提供基础 (2) 为各项管理提供依据 公务员职位类别的标准与类别的划分(1) 专业技术类：纯技术性 不可替代性 技术权威性。(2) 行政执法类：纯执行性 现场强制性(3) 综合管理类。(4) 法官、检察官类。(5) 其他。 公务员的职务序列(1) 公务员职务分为领导职务和非领导职务。领导职务层次分为：国家级正职、国家级副职、省部级正职、省部级副职、厅局级正职、厅局级副职、县处级正职、县处级副职、乡科级正职、乡科级副职。(2) 综合管理类的非领导职务分为：巡视员、副巡视员、调研员、副调研员、主任科员、副主任科员、科员、办事员。 公务员级别的功能(1) 确定工资及其他待遇的依据 (2) 平衡比较各类职务序列的标尺。 公务员级别与职务的对应关系(1) 合理增加级别数量 (2) 一职数级，上下交叉 (3) 向基层倾斜。 公务员职位设置依据的四大要素：(1) 职能(2) 规格(3) 编制限额(4) 职数以及结构比例 一、职务与级别的含义。我国设置公务员职务与级别的目的 (1) 职务：是公务员所承担的应该完成的任务，是机关对公务员职权、职责的委托。(2) 级别：是反映公务员职务、能力、业绩、资历的综合标志。职务与级别是“一职数级，上下交叉”的对应关系。 我国设置公务员职务与级别的三个目的： 1. 为公务员管理提供科学的管理基础 2. 增强职务与级别的激励作用 3. 便于借鉴国外公务员分类制度的合理因素。 二、职位分类与品位分类的含义。我们公务员职位分类的内容职位分类：以“事”为对象进行分类，侧重职位的职务、职责和职权。分类依据是公务员职位的工作性质、难易程度、责任大小和所需资格条件。品位分类：以“人”为对象进行分类，侧重人的资历条件。依据是公务员个人所具备的条件(学历、资历) 与身份(官职地位的高低) 和应获得报酬的多少。 (1) 划分公务员职位类别的标准：分类必须符合标准的统一性和类别的排他性原则，必须能够涵盖所有公务员范围。我们坚持以职位分类为导向的管理制度，划分职位类别的标准，不仅要依据职位的性质和特点，还要取决于管理的需要。 (2) 我国公务员的职位类别划分(5) ：专业技术类职位：指机关中人事专业技术工作，履行专业技术职责，为实施公共管理提供专业技术和技术手段保障的职位。三个特征：一，具有只对专业技术本身负责的纯技术性 二，专业技术类职位与其他职位相比具有不可替代性 三，技术权威性。 行政执法类职位：指政府部门中直接履行监管、处罚、强制、稽查等现场执法职责的职位。二特点：一，纯粹的执行性 二，现场强制性。 综合管理类职位：指机关中除行政执法类职位、专业技术类职位以外的履行综合管理以及内部管理等职责的职位。 法官、检察官类职位：具有司法强制性与较强的专业性。其他类别职位。 三、我国公务员的职务序列(1) 领导职务序列(10 个) ：国家级正、副职 省部级正、副职 厅局级正、副职 县处级正、副职 乡科级正、副职。 (2) 非领导职务序列(8 个) ：巡视员、副巡视员、调研员、副调研员、主任科员、副主任科员、科员、办事员。 我国公务员两种职务序列的职责 四、我国公务员的级别(1) 级别的功能： 1. 确定工资及其他待遇的重要依据 2. 平衡丝袜各类职务序列的标尺。 (2) 确定级别的依据：根据公务员所任职务及德才表现、工作实绩和资历确定与晋升。 (3) 对应幅度：国家级正职 1国家级副职 2-4省部级正职 4-8省部级副职 6-10厅局级正职 8-13厅局级副职 10-15县处级正职 12-18县处级副职 14-20乡科级正职 16-22乡科级副职 17-24科员 18-26办事员 19-27 怎样在对应幅度内晋升公务员的级别：一种是当公务员晋升职务时，原级别没有达到新任职务对应级别的，相应晋升级别 另一种是不晋升职务，也可以在对应的级别范围内，根据德才表现、工作实绩和资历晋升级别。 应用：从一批公务员职务与所列的级别中，正确排出其对应关系。 第四章 公务员录用知识点总结 我国公务员录用的意义(1) 有利于为国家机关选拔一批高素质的优秀人才，更好地为发展社会主义市场经济与构建和谐社会服务(2) 有利于抵制用人上的不正之风，加强国家机关的廉政建设(3) 有利于激励人们积极进取，奋发向上，形成良好的社会风气 公务员录用的资格条件A－基本条件(1) 具有中华人民共和国国籍(2) 年满十八周岁(3) 拥护中华人民共和国宪法(4) 具有良好的品行(5) 具有正常履行职责的身体条件(6) 具有符合职位要求的文化程度和工作能力(7) 法律规定的其他条件。B－限制性条件下列人员不得录用为公务员：(1) 曾因犯罪受过刑事处罚的(2) 曾被开除公职的(3) 有法律规定不得录用为公务员的其他情形的 公务员录用的原则(1) 公开考试 (2) 平等竞争 (3) 严格考察：(4) 择优录用。 公务员录用考试的内容(1) 知识测验 (2) 智力测验 (3) 技能测验。 公务员录用的程序(1) 发布考试公告(2) 资格审查(3) 对审查合格者进行公开考试(4) 对考试合格者进行考察(5) 体检(6) 录用：提出拟录用人员名单，公示 审批、备案。 公务员录用工作过程中，承担违纪责任的条件(1) 不按编制限额录用 (2) 不按所需职位要求录用 (3) 不按规定的资格条件录用 (4) 不按规定的程序录用 公务员录用考试的种类：(1) 公开竞争性考试(2) 非公开竞争性考 适用非公开竞争性考试办法的情况有：(1) 因职位特殊不宜公开招考的(2) 因专业特殊，难以形成竞争的(3) 录用主考机关规定的其他情况 公务员录用考试的内容：(1) 知识测验(2) 智力测验，或叫能力测验(3) 技能测验 公务员录用考试的方式：(1) 笔试(2) 面试(3) 实际操作(4) 情景模拟和心理测试 务员录用的主管部门：(1) 中央国家机关公务员录用主管部门(2) 省级公务员录用主管部门(3) 设区的市级公务员录用主管部门 工作中违纪工作人员的处罚：(1) 取消工作人员资格(2) 调离考录工作岗位(3) 给予行政处分 一、录用的概念公务员录用的含义：根据公务员法规定，按照法定的标准与条件，经过规定的程序，面向社会，通过竞争性考试与考察方式，择优抗选拔国家机关中担任主任科员以下及其他相当职务层次的非领导职务公务员的一种人事管理制度。 (1) 公务员录用考试起源于英国的依据(2) 实行公务员录用的意义：有利于为国家机关选拔一批高素质的优秀人才，更好地为发展社会主义市场经济与构建和谐社会服务有利抵制用人上的不正之风，加强国家机关的廉政建设有利于激励人们积极进取，奋发向上，形成良好的社会风气。 二、公务员录用的资格条件(1) 公务员录用的基本条件(7 个) ：具有中华人民共和国国籍 年满十八周岁 拥护中华人民共和国宪法 具有良好的品行 具有正常履行职责的身体条件 具有符合职位要求的文化程度和工作能力 法律规定的其他条件。(2) 公务员录用的限制性条件(3 个) ：曾因犯罪受过刑事处罚的 曾被开除公职的 有法律规定不得录用为公务员的其他情形的。 (1) 了解公务员录用的 7 个基本条件的内容(2) 理解制定 3 个限制性条件的意义 三、公务员录用的原则 了解“公开、平等、竞争、择优”四项原则的内涵：即公开考试、平等竞争、严格考察、择优录用。 (1) 对四项原则的具体要求： 公开考试：录用考试的政策、法规要公开，不允许搞“内部掌握” 录用考试的基本信息要公开，如时、地、科目、类别，报考部门的职位名称、性质、职责、缺员数量以及报考所需资格条件等。 平等竞争：指公民参加录用考试的法律地位平等，凡具有应试资格的公民均可报考。在平等的条件下参加竞争和被择优录用 任何公民不因民族、性别、家庭出身、个人成分、宗教信仰、婚姻状况等原因或享有特权或受到歧视。 严格考察：指按照录用主管部门的统一规定，录用前对应试者所做的必要的考察与了解并作出评价。包括录用考察的前提、内容和方式。 前提：由用人单位在笔试与面试合格者中，按一定比例所确定的预选对象中进行。 六方面内容：政治思想 道德品质 廉洁自律 工作表现 工作实绩 需要回避的情况。 三种方式：查阅档案法 交谈考察法 座谈会考察法。择优录用：德才兼备，既要重视他的政治思想表现和工作作风，也要重视他的实际工作能力。 (2) 实行这些原则的意义：实行公开考试可以使所有具备资格参加录用考试的公民，有机会了解录用的信息，以便本人决定是否参加考试 也可以使录用工作全面接受公民监督，有利于预防或制止录用中的不正之风。实行平等竞争能使各类优秀人才脱颖而出，采取公开考试，择优任用的办法，既得到了第一流的人才，又使广大群众与报考者心悦诚服。 四、公务员录用的考试内容考试内容涵盖哪些方面：知识测验 智力测验(能力测验) 技能测验。 (1) 知识与技能测验的重要性：考察应试者的知识和专业水平，和考察他们记忆能力、分析观察能力、综合归纳能力、数目能力、文字表达能力以及语言关系能力等一般能力。(2) 能力测验的必要性：考察应试者处理实际问题的速度与质量，检验应试者对知识与智力运用的程度和能力。 应用：运用录用的原则分辨实际录用中的案例。 五、公务员录用考试的方式录用考试中笔试与面试的优缺点：笔试的优点：经济性，可以在同一时间对大批人员在不同地点进行考试 客观性，主考人与应试者不直接接触，评卷有客观尺度 广博性，一张试卷可以出多学科的不同类型的题目。缺点：不易考察应试者的实际工作能力。 面试的优点：可以弥补笔试内容的不足，易于观察应该者的口头表达能力、社交能力、诚实程度、开拓精神、应变能力、举止、仪表、气质等。缺点：评分时易受主考人员主观印象的影响。 情景模拟与心理测验的必要性：情景模拟可以考察应试者的治事、领导、适应、创造和言谈等能力，从而获得应试者实际工作能力的直观印象。能考察应试者的真实能力。心里测试可以了解面试合格应试者的性格、气质、情感、仪表和反应，以评定应试者的心理素质。 六、公务员录用的程序对各项程序的表述：⑴ 发布公告 ⑵ 资格审查 ⑶ 对审查合格者进行公开考试 ⑷ 对考试合格者进行考察 ⑸ 体检 ⑹ 录用 对录用标准的掌握 应用：模拟面试的情景与答题的技巧。 七、试用期试用期的内涵：用人部门对被试用人员的政治思想水平和适应工作的能力等进行深入的考察，使试用人员在正式任职前获得职务上所需要的知识和能力。 对试用期满考核合格与不合格与否的不同处理方式：合格，正式任职 不合格，取消录用。 第五章 公务员考核知识点总结 公务员考核的含义与类型公务员考核，是指公务员主管部门和各机关按照管理权限，依据一定的程序和方法，对所管理的公务员的政治业务素质和履行岗位职责、完成工作目标的情况，进行了解、核实和评价。 公务员考核的类型包括：(1) 平时考核 (2) 定期考核。 公务员年度考核与录用考察、晋升考察的区别 区别 年度考核 录用考察 晋升考察 目的不同 评价公务员的全年表现 评价拟录用公务员的一贯表现，以确定是否录用 为晋升公务员职务而评价 法律依据不同 《公务员法》 公务员录用相关规定，如《公务员录用规定》 公务员晋升相关法规 考核组织不同 行政首长或考核委员会 用人部门 任免机关 考核方法和程序不同 规范 简单 严格 公务员年度考核的特点(1) 范围广泛：考核的范围全员性 考察则针对一部分特定对象(2) 定期进行：年度考核为一年一度 考察则视情况需要进行(3) 目的单一：年度考核针对公务员一年的工作情况进行 考察针对公务员的职业倾向、工作表现、个性特征等。 公务员考核的意义(1) 有利于客观公正地评价公务员，激励公务员提高自身素质，改进工作绩效(2) 有利于对公务员严格管理和严格监督(3) 为公务员管理其他环节提供依据。 公务员考核的原则(1) 全面考核和重点考核相结合(2) 客观公正与民主公开(3) 分类考核(4) 考用结合。 公务员考核的内容《公务员法》规定，“对公务员的考核，按照管理权限，全面考核公务员的德、能、勤、绩、廉，重点考核工作实绩。”(1) 德，是指思想政治素质及个人品德、职业道德、社会公德等方面的表现。(2) 能，是指公务员从事本职工作所需具备的业务素质和工作能力。(3) 勤，是指公务员的责任心、工作态度、工作作风和勤奋精神。(4) 绩，是指公务员的工作实绩。(5) 廉，是指公务员的廉洁自律等情况。 公务员确定为优秀等次须具备下列条件(1) 思想政治素质高(2) 精通业务，工作能力强(3) 工作责任心强，勤勉尽责，工作作风好(4) 工作实绩突出(5) 清正廉洁。 公务员确定为称职等次须具备下列条件(1) 思想政治素质较高(2) 熟悉业务，工作能力较强(3) 工作责任心强，工作积极，工作作风较好(4) 能够完成本职工作(5) 廉洁自律。 公务员具有下列情形之一的，应确定为基本称职等次(1) 思想政治素质一般(2) 履行职责的工作能力较弱(3) 工作责任心一般，或工作作风方面存在明显不足(4) 能基本完成本职工作，但完成工作的数量不足、质量和效率不高，或在工作中有较大失误(5) 能基本做到廉洁自律，但某些方面存在不足。 公务员具有下列情形之一的，应确定为不称职等次(1) 思想政治素质较差(2) 业务素质和工作能力不能适应工作要求(3) 工作责任心或工作作风差(4) 不能完成工作任务，或在工作中因严重失误、失职造成重大损失或者恶劣社会影响(5) 存在不廉洁问题，且情形较为严重。 我国公务员考核的基本方法(1) 领导考核和群众考核相结合(2) 平时考核和定期考核相结合(3) 定性考核和定量考核相结合。 对非领导成员公务员的定期考核程序(1) 被考核公务员按照职位职责和有关要求进行总结，并在一定范围内述职(2) 主管领导在听取群众和公务员本人意见的基础上，根据平时考核情况和个人总结，写出评语，提出考核等次建议和改进提高的要求(3) 对拟定为优秀等次的公务员在本机关范围内公示(4) 由本机关负责人或者授权的考核委员会确定考核等次(5) 将考核结果以书面形式通知被考核公务员，并由公务员本人签署意见。 公务员考核委员会的主要职责(1) 根据年度考核的统一要求和本部门工作的实际情况，制定考核工作计划(2) 拟定考核的具体方法和标准(3) 向本部门公务员公布考核计划，组织学习(4) 审核主管领导人员对公务员所写的评语和提出的考核等次意见，并将审核后的意见报部门负责人审定(5) 组织、指导、协调本部门各单位的考核工作(6) 监督考核程序(7) 受理公务员不服考核结果所提出的复核申请。 对领导成员公务员的定期考核程序(1) 考核准备 (2) 述职 (3) 民主测评 (4) 个别谈话(5) 调查核实 (6) 撰写考核材料 (7) 综合分析，评定考核结果 (8) 反馈。 公务员考核结果的使用A.公务员年度考核被确定为称职以上等次的，按照下列规定办理：(1) 累计两年被确定为称职以上等次的，在所定级别对应工资标准内晋升一个工资档次(2) 累计五年被确定为称职以上等次的，在所任职务对应级别范围内晋升一个级别(3) 确定为称职以上等次，且符合规定的其他任职资格条件的，具有晋升职务的资格 连续三年以上被确定为优秀等次的，晋升职务时优先考虑(4) 被确定为优秀等次的，当年给予嘉奖 连续三年被确定为优秀等次的，记三等功(5) 享受年度考核奖金。 B.公务员年度考核被确定为基本称职等次的，按照下列规定办理：(1) 对其诫勉谈话，限期改进(2) 本考核年度不计算为按年度考核结果晋升级别和级别工资档次的考核年限(3) 一年内不得晋升职务(4) 不享受年度考核奖金 C.公务员年度考核被确定为不称职等次的，按照下列规定办理：(1) 降低一个职务层次任职(2) 本考核年度不计算为按年度考核结果晋升级别和级别工资档次的考核年限(3) 不享受年度考核奖金(4) 连续两年年度考核被确定为不称职等次的，予以辞退。 一、公务员考核的含义与意义(1) 公务员考核的概念：指公务员主管部门和各机关按照管理权限，依据一定的程序和方法，对所管理的公务员的政治业务素质和履行岗位职责、完成工作目标的情况，进行了解、核实和评价。分平时考核和定期考核。(2) 年度考核与录用考察、晋升考察的区别(表 1) ： 年度考核 录用考察 晋升考察 目的不同 对公务员的全年表现进行评价 对被录用人员的一贯工作表现进行评价，以确定能否录用为公务员 为晋升公务员职务进行的评价 法律依据不同 《中华人民共和国公务员法》 公务员录用相关法规 公务员晋升相关法规 考核组织不同 行政首长或考核委员会 由用人部门组织实施考核 由任免机关进行 考核方法和程序不同 方法和程序比较规范，有法律明确规定，程序严谨 方法和程序相对简单 方法和程序严格 建立公务员考核制度的意义：有利于客观公正地评价公务员，激励公务员提高自身素质，改进工作绩效 有利于对公务员的严格管理和严格监督 为公务员管理的其他环节提供了依据。 二、公务员考核成绩的原则考核的四项原则：全面考核和重点考核相结合的原则 客观公正与民主公开的原则 分类考核的原则 考用结合的原则。 客观公正原则的重要性：客观原则指对公务员的考核，必须从被考核者德、能、勤、绩、廉等方面的实际表现出发，严格按照考核标准，实事求是地确定考核结果，避免以偏概全。公正原则指考核要严格按照既定的程序和标准进行，一视同仁，考核结果不因考核对象的不同而有所分别。 应用：对违反考核原则事例的正确分析。 三、公务员考核的内容五个方面的考核内容：德：思想政治素质、职业道德、社会公德和个人品德。能：从事本职工作所需具备的业务素质和工作能力。勤：责任心、工作态度、工作作风和勤奋精神。绩：工作实绩。廉：廉洁自律等情况。 重点考核工作实绩：在全面考核德、能、勤、绩、廉的基础上，对公务员的考核要着重考核工作实绩，把工作实绩作为评价公务员的主要依据。并不是说德、能、勤、廉四个方面的考核就不重要。事实上，五个方面是相互关联、互为补充、不可分割的统一体。缺少任何一方面的考核都不可能得出全面准确的考核结果。况且，工作实绩有时还会受到客观因素的限制而不能完整如实地表现出来。因此，考核既要注重和突出对工作实绩的考核，又不能简单地用实绩考核代替对公务员德、能、勤、廉的考核。 应用：对正确掌握考核内容案例的分析。 四、考核的范围关于考核范围的九个补充规定：(1) 请病假、事假的公务员的考核：因病假、事假累计超过半年的公务员，不进行考核(2) 调任或转任的公务员的考核：调任或转任的公务员，由其调任或转任的现工作单位进行考核并确定等次。其调任或转任前的有关情况，由原单位提供。(3) 挂职锻炼的公务员，在挂职锻炼期间由挂职单位进行考核并确定等次。不足半年的，由派出单位进行(4) 单位派出学习、培训的公务员，由派出单位进行考核，主要根据学习、培训表现确定等次。其学习、培训的相关情况，由所在学习、培训单位提供(5) 新录用公务员在试用期内参加年度考核，不确定等次，只写评语，作为任职、定级的依据(6) 无故不参加考核的经教育后仍然拒绝参加的，直接确定其考核结果为不称职等次(7) 受处分的公务员的考核：受警告处分当年，参加年度考核，不得确定为优秀等次 受记过、记大过、降级、撤职处分的期间，参加年度考核，只写评语，不定等次。在解除处分的当年及以后，其年度考核不受原处分的影响(8) 对不进行考核或参加年度考核不定等次的公务员的考核管理：不进行考核或参加年度考核不定等次的，本考核年度不计算为按年度考核结果晋升级别和级别工资档次的考核年限(9) 对在考核中违纪行为的处理：在考核过程中有徇私舞弊、打击报复、弄虚作假等违法违纪行为的，依照有关规定予以严肃处理。 应用：对违规的公务员年度考核的各种综合性案例，能够作出正确的分析和判断。 五、考核的等次与标准优秀、称职、基本称职、不称职四个等次：年度考核四个等次的基本标准：优秀：思想政治素质高 精通业务，工作能力强 工作责任心强，勤勉尽责，工作作风好 工作实绩突出 清正廉洁。称职：思想政治素质较高 熟悉业务，工作能力较强 工作责任心强 工作积极，工作作风较好 能够完成本职工作 廉洁自律。基本称职：思想政治素质一般 履行职责的工作能力较弱 能基本完成本职工作，但完成工作的数量不足、质量和效率不高，或在工作中有较大失误。不称职：思想政治素质较差 业务素质和工作能力不能适应工作要求 工作责任心或工作作风差 不能完成工作任务，或在工作中因严重失误、失职造成重大损失或恶劣社会影响 存在不廉洁问题，且情形较为严重。 六、考核的方法考核的三个基本方法：领导考核与群众考核相结合 平时考核与定期考核相结合 定性考核与定量考核相结合。 (1) 领导与群众相结合的重要性：这是我党多年来实行群众路线工作方法与民主集中制原则在考核工作中的具体体现和运用。首先，公务员考核要在有关行政领导人员主持下进行，他们对考核结果拥有最后决定权。领导人员主持考核工作是行政首长负责制原则的具体体现，是最基本、最主要的考核形式。其次，公务员考核还必须走群众路线，让群众参与考核。有关行政领导人员在考核公务员时，要通过不同形式向群众了解公务员的有关表现，听取群众的意见和要求。 (2) 影响考核结果的四心理因素：从众心理：由于考核主体过多地考虑与被考核者的利害关系，受外部环境压力束缚，在考核中，放弃自己对被考核者的意见，而采取“随大流”的方式，人云亦云趋中误差：考核主体不愿或没有将被考核人员工作业绩的差异性表现出来，而是把被考核者的成绩集中在同等水平的分数界限内，导致了考核结果的平均化倾向近因效应：人在判断事物中，由于知觉局限性而出现的误差。由于最近发生的事情在考核者头脑中记忆深刻，因而考核者常常以对最近表现的评价代替对公务员的全面评价晕轮效应：判断者往往偏重于事物的某一方面的特征，并人为地放大它的作用，甚至忽略事物的其他方面或全部，在考核中主要表现为考核者由于特别看重某人的某项特性，而影响他其他方面作出客观的评定。 七、考核的程序对公务员定期考核的程序： 1. 对非领导成员公务员的定期考核程序：采取年度考核的方式，一般在当年年底或翌年年初进行。(1) 被考核公务员按照职位职责和有关要求进行总结，并在一定范围内述职(2) 主管领导在听取群众和公务员本人意见的基础上，根据平时考核情况和个人总结，写出评语，提出考核等次建议和改进提高的要求(3) 对拟定为优秀等次的公务员在本机关内公示(4) 由本机关负责人或授权的考核委员会确定考核等次(5) 将考核结果以书面形式通知被考核公务员，并由公务员本人签署意见。 对领导成员公务员的定期考核：考核主体：主管机关(党委及其组织部门)方式：届中、届末考核，没有明确届期的每两年或三年进行一次定期考核，8 项程序：(1) 考核准备 述职 民主测评 个别谈话 调查核实 撰写考核材料 综合分析，评定考核结果 反馈。 八、考核结果的反馈与使用(1) 考核结果反馈的方式：以书面形式通知本人。体现了公务员权利保障原则和考核的公开性，使公务员能够了解组织对自己的基本评价，看到自身的优点与不足，明确今后的努力方向。(2) 考核结果使用的有关规定：公务员法规定，公务员定期考核结果是对公务员进行奖惩、培训、辞退以及调整职务、级别和工资的直接或间接依据。 被确定为称职以上等次的：(1) 累计 2 年被确定为称职以上等次的，在所定级别工资标准内晋升一个工资档次(2) 累计 5 年被确定为称职以上等次的，在所任职务对应级别范围内晋升一个级别(3) 确定为称职以上等次，且符合规定的其他任职资格条件的，具有晋升职务的资格 连续 3 年以上被确定为优秀等次的，晋升职务时优先考虑(4) 被确定为优秀等次的，当年给予嘉奖 连续 3 年被确定为优秀等次的记三等功(5) 享受年度考核奖金。 被确定为基本称职等次的：(1) 对其诫勉谈话，限期改进(2) 本考核年度不计算为按年度考核结果晋升级别和级别工资档次的考核年限(3) 一年内不得晋升职务(4) 不享受年度考核奖金。 被确定为不称职等次的：(1) 降低一个职务层次任职(2) 本考核年度不计算为按年度考核结果晋升级别和级别工资档次的考核年限(3) 不享受年度考核奖金 连续 2 年被确定为不称职等次的，按规定予以辞退。 应用：对考核结果按照有关处理规定的具体应用。 第六章 公务员职务任免与升降知识点总结 公务员职务任免与升降的意义(1) 对于机关来说，是保证机关中各职位获得合适人选的主要途径(2) 对于公务员来说，是有效的激励手段(3) 是实现职务管理的保证 公务员委任制的优缺点A.优点：(1) 体现治事与治人相统一 (2) 保证公务员队伍相对稳定 (3) 操作简便。B.缺点：(1) 用人上主要根据上级领导的意志，容易滋生主观随意性,缺乏透明度 (2) 对委任制公务员中不胜任职务者不易调整，容易造成能上不能下、能进不能出的弊端等 委任制公务员的任职程序(1) 提出拟任职的人选 (2) 考察 (3) 决定任命 (4) 下发任职通知 聘任制公务员的特点(1) 合同管理 (2) 平等协商 (3) 任期明确。 实行职位聘任的意义(1) 有利于健全用人机制，增强公务员制度的生机、活力。(2) 有利于满足机关吸引和使用多样化人才的需求(3) 有利于提高公务员的整体素质，提高公务员队伍的专业化水平。 实行聘任制的条件(1) 工作需要 (2) 机关选择 (3) 省级以上公务员主管部门的批准 (4) 在规定的编制限额和工资经费限额内进行。 委任制公务员免职的情形A.(1) 转任职位 (2) 晋升和降低职务 (3) 调出机关 (4) 被辞退、开除、撤职等。B. 单纯性免职的情形：(1) 离职学习超过一年以上 (2) 因健康原因，不能坚持正常工作一年以上的 (3) 退休的。C. 自行免职的情形：(1) 受到刑事处罚或劳动教养 (2) 受到行政撤职或开除处分 (3) 被辞退 (4) 因机构变动失去职位 (5) 死亡。 委任制公务员免职的程序(1) 提出拟任职的建议 (2) 审核 (3) 提出免职决定 (4) 发布免职通知。 公务员职务晋升的原则(1) 德才兼备，任人唯贤 (2) 注重工作实绩 (3) 公开、公平、竞争、择优 (4) 逐级晋升。 公务员职务晋升的程序(1) 民主推荐 (2) 组织考察 (3) 讨论决定 (4) 按照规定履行任职手续。 公务员竞争上岗的程序(1) 制定并公布实施方案 (2) 报名与资格审查 (3) 笔试、面试 (4) 民主测评，组织考察(5) 党委(党组) 讨论决定 (6) 办理任职手续。 公务员公开选拔的程序(1) 发布公告 (2) 报名与资格审查 (3) 统一考试(4) 组织考察，研究提出人选方案 (5) 党委党组讨论决定。(6) 办理任职手续。 公务员降职的程序(1) 所在单位提出降职安排意见(2) 对降职事由进行审核，并听取降职公务员的意见(3) 按照管理权限由有关领导集体研究决定，并依法任免。 选任制公务员的范围：(1) 中国共产党机关(2) 人大机关(3) 行政机关(4) 审判机关(5) 检察机 关(6) 政协机关(7) 民主党派机关选任制公务员的任职情形：(1) 通过选举方式任职(2) 有些选举产生的职务，在一定条件下也可决定任命 委任制方式的优点：(1) 体现治事与用人相统一(2) 保证公务员队伍相对稳定(3) 操作简便委任制 公务员的任职情形：(1) 新进入公务员队伍的，需要进行任职(2) 公务员职位发生变化，任免机关应及时予以任职，以确认新的职务关系 委制制的任职程序：(1) 提出拟任职人选(2) 考察(3) 决定任命(4) 下发任职通知 聘任制的特点：(1) 合同管理(2) 平等协商(3) 任期明确 实行职位聘任的作用：(1) 实行聘任制有利于健全用人机制、增强公务员制度的生机和活力(2) 实行聘任制有利于满足机关吸引和使用多样化人才的需求(3) 实行聘任制有利于提高公务员整体素质，提高公务员队伍的专业化水平 可以实行聘任制的范围：(1) 专业性较强的职位(2) 辅助性职位 实行聘任制的条件：(1) 工作需要(2) 机关的选择(3) 省级以上公务员主管部门批准(4) 在规定的编制限额和工资经费限额内进行 聘任人选的产生：(1) 公开招聘(2) 直接选聘 对领导成员职务实行任期制，具有重要意义：(1) 有利于实现领导职务的能上能下，形成正常的新老交替机制，建立充满生机与活力的用人机制(2) 有利于加强对领导成员的监督管理，增强领导班子的整体能力(3) 有利于保持领导班子相对稳定 国外公务员的任职权属大致分三种情形：(1) 由国家元首任用(2) 按层次高低分别任用(3) 由各部委首长任用 选任制公务员的免职：(1) 任期届满不再连任，所任职务自然免除(2) 任期内辞职、被罢免、被撤职的，所任职务免除 委任制公务员的免职：(1) 程序性免职的情形(2) 单纯性免职的情形(3) 自行免职的情形 免职的程序：(1) 提出拟免职的建议(2) 审核(3) 作出免职决定(4) 发布免职通知 公务员职务晋升的原则：(1) 德才兼备、任人唯贤原则(2) 注重工作实绩原则(3) 公开、平等、竞争、择优原则(4) 逐级晋升原则 公务员职务晋升的条件：(1) 具有履行职责所需要的马克思列宁主义、毛泽东思想、邓小平理论的水平，认真实践“三个代表”重要思想，努力用马克思主义的立场、观点、方法分析和解决实际问题，坚持讲学习、讲政治、讲正气，经得起各种风浪的考验(2) 具有共产主义远大理想和中国特色社会主义坚定信念，坚决执行党的基本路线和各项方针、政策，立志改革开放，献身现代化事业，在社会主义建设中艰苦创业，作出实绩(3) 坚持解放思想，实事求是，与时俱进，开拓创新，认真调查研究，能够把党的方针、政策同本地区、本部门的实际相结合，卓有成效地开展工作，讲实话，办实事，求实效，反对形式主义(4) 有强烈的革命事业心和政治责任感，有实践经验，有胜任领导工作的组织能力、文化水平和专业知识(5) 正确行使人民赋予的权力，依法办事，清正廉洁，勤政为民，以身作则，艰苦朴素，密切联系群众，坚持党的群众路线，自觉接受党和群众的批评和监督，做到自重、自省、自警、自励，反对官僚主义，反对任何滥用职权、谋求私利的不正之风(6) 坚持和维护党的民主集中制，有民主作风，有全局观念，善于集中正确意见，善于团结同志，包括团结同自己有不同意见的同志一道工作。晋升领导职务的资格 竞争上岗工作的程序：(1) 制定并公布实施方案(2) 报名与资格审查(3) 笔试、面试(4) 民主测评、组织考察(5) 党委(党组) 讨论决定(6) 办理任职手续 公开选拔工作的程序：(1) 发布公告(2) 报名与资格审查(3) 统一考试(4) 组织考察，研究提出人选方案(5) 党委(党组) 讨论决定 (6) 办理任职手续 国外公务员的职务晋升制度有：年资晋升制、功绩晋升制、考试晋升制、委任晋升制、越级晋升制、自荐晋升制等。 公务员降职的原则：(1) 能上能下原则(2) 逐级降职原则 公务员降职的条件：(1) 本人不称职(2) 不能胜任现职工作 公务员降职的方式：(1) 职薪同时降(2) 降职不降薪 一、公务员职务任免、升降的含义与意义任职：有任免权的机关依照有关法律规定和任职条件，通过法定的程序和手续，任用公务员担任某一职务的管理活动。免职：有任免权的机关依照有关法律规定和任职条件，通过法定的程序和手续，免除公务员所担任职务的管理活动。晋升：管理机关，依照国家有关法律规定，根据机关工作的需要和公务员本人的工作表现与业绩情况通过法定的程序和手续，降职：管理机关，依照国家有关法律规定，对由于不能胜任现任职务的公务员，依一定程序，降低其原有的职务，改任一种较低职务的管理活动。 公务员职务任免、升降的意义： 1. 对机关来说，职务任免与升降是保证机关中各个职位获得适宜人选的主要途径 2. 对于公务员来说，职务任免与升降是一种有效的激励手段 3. 公务员职务任免与升降是实现职务管理的保证。 二、公务员任职的方式与原则适用的对象：选任制(1) 中国共产党机关： 1. 中央政治局委员、候补委员，中央政治局常务委员会委员和中央委员会总书记 中央纪律检查委员会常委和书记、副书记。 2. 地方各级委员会常务委员会委员和书记、副书记 地方各级纪律检查委员会常委和书记、副书记。 3. 乡镇、街道党委书记、副书记 乡镇、街道纪律检查委员会书记、副书记。 (2) 人大机关： 1. 全国人大委员长、副委员长、秘书长。 2. 县级以上地方各级人大常委会主任、副主任、秘书长。 3. 乡镇人大主席、副主席。 (3) 行政机关：地方各级人民政府的领导人员。 (4) 审判机关：最高人民法院院长，地方各级人民法院院长。 (5) 检察机关：最高人民检察院检察长，地方各级人民检察院检察长。 (6) 政协机关：政协全国委员会主席、副主席、秘书长。政协地方各级委员会主席、副主席、秘书长(县级地方委员会根据具体情况也可不设秘书长) 。 (7) 民主党派机关：中央和地方各级委员会主席(主委) 、副主席(副主委) 、秘书长。 委任制：我国以委任制为主，除上述七类机关中选举产生以及少数实行聘任的职务外，其他公务员。 聘任制：专业性较强的职位 辅助性职位 应用：运用公务员任职的原则，分析公务员任职中的典型案例。 三、公务员的兼职公务员兼职的内容：机关内兼职：原则上一人一职，确因工作需要，经任免机关批准，可以在国家行政机关内兼任一个实职机关外兼职：规定公务员不得在企业和营利性事业单位兼任职务。 应用：运用兼职的规定，对现时存在的各种兼职情形，作出正确的判断。 四、公务员的免职公务员免职的程序：提出拟免职的建议 审核 作出免职决定 发布免职通知。 公务员免职的几种情形：选任制公务员的免职：任期届满不再连任，所任职务自然免除 任期内辞职、被罢免、被撤职的，所任职务免除委任制公务员的免职：程序性免职的情形(1. 转任职位 晋升或降低职务 调出机关 因其他原因需要免职，如因犯错被辞退、撤职、开除公职等) 单纯性免职的情形(非公派、组织选派离职学习连续一年以上 因健康原因不能坚持工作一年以上 退休) 自行免职的情形(受到刑事处罚或劳动教养 受到行政撤职或开除处分 被辞退 因机构变动失去职位 死亡) 五、公务员职务晋升的原则、条件、资格和程序公务员职务晋升的程序：民主推荐 组织考察 讨论决定 按照规定履行任职手续。 晋升的条件 1. 具有履行职责所需要的马克思列宁主义、毛泽东思想、邓小平理论的水平，认真实践“三个代表”重要思想，努力用马克思主义的立场、观点、方法分析和解决实际问题，坚持讲学习、讲政治、讲正气，经得起各种风浪的考验。 具有共产主义远大理想和中国特色社会主义坚定信念，坚决执行党的基本路线和各项方针、政策，立志改革开放，献身现代化事业，在社会主义建设中艰苦创业，作出实绩。 坚持解放思想，实事求是，与时俱进，开拓创新，认真调查研究，能够把党的方针、政策同本地区、本部门的实际相结合，卓有成效地开展工作，讲实话，办实事，求实效，反对形式主义。 有强烈的革命事业心和政治责任感，有实践经验，有胜任领导工作的组织能力、文化水平和专业知识。 正确行使人民赋予的权力，依法办事，清正廉洁，勤政为民，以身作则，艰苦朴素，密切联系群众，坚持党的群众路线，自觉接受党和群众的批评和监督，做到自重、自省、自警、自励，反对官僚主义，反对任何滥用职权、谋求私利的不正之风。 坚持和维护党的民主集中制，有民主作风，有全局观念，善于集中正确意见，善于团结同志，包括团结同自己有不同意见的同志一道工作。 应用：运用公务员职务晋升的原则，分析、判断公务员职务晋升的典型案例。四原则：德才兼备、任人唯贤 注重工作实绩 公开、平等、竞争、择优 逐级晋升。 六、公务员竞争上岗、公开选拔竞争上岗对象：选拔任用中央、国家机关内设的司局级、处级机构领导成员，县级以上地方各级党委、人大常委会、政府、政协、纪委、人民法院、人民检察院机关或工作部门的内设机构领导成员。 公开选拔对象：地方党委、人大常委会、政府、政协、纪委、工作部门或工作机构的领导成员或其人选，以及其他适于公开选拔的领导成员或其人选。副调研员以上及其他相当层次的非领导职务出现空缺，也可以公开选拔。 程序竞争上岗：制定并公布实施方案 报名与资格审查 笔试、面试 民主测评、组织考察 党委(党组) 讨论决定 办理任职手续。公开选拔：发布公告 报名与资格审查 统一考试 组织考察，研究提出人选方案 党委(党组) 讨论决定 办理任职手续。 七、任职公示和任职试用期制度任职公示制度的含义：将党委(党组) 集体讨论研究确定拟提拔或调整的公务员的有关情况，通过一定的方式，在一定范围和期限内进行公布，广泛听取群众的反映和意见，再正式实施对公务员的任职。 具体规定任职公示： 公示对象：地(厅) 级以下(含) 委任制领导职务的拟任人选，除特殊岗位外 选任制干部的推荐提名人选、非领导职务改任同级领导职务的人选、平缓转任重要职务的人选，根据实际情况，也可列为公示对象。 公示范围：党政领导班子、工作部门领导成员的选拔任用应向社会公示 部门内设机构中层原则上在其所在工作部门或系统内公示，也可根据岗位特点在更大范围内公示 易交流提拔任职在原工作所在地或单位公示。 公示内容：公示对象的姓名、性别、出生年月、籍贯、学历学位、政治面貌、现任职务等自然情况和工作简历。 公示方式：向社会，一般报纸、电视、广播等新闻媒体发布公告 在部门或系统内，可采取发公示通知或会议公布、张榜公告等形式。 公示时间：七至十五天。 公示程序：四步骤(1) 党委研究确定拟任人选后，以一定方式予以公示(2) 以组织部门为主受理群众意见(3) 调查核实群众反映的问题，并向署名或当面反映问题的群众反馈调查核实结果(4) 根据调查核实情况提出处理意见，决定是否实施对干部的任用，并予以公布。 任职试用期制度：可以在较长题意的实际工作中，更全面更客观地考察干部，延长考察期，拓展考察面，有利于提高干部选拔任用工作的准确性。适用于：提拔担任非选举产生的司厅局级以下(含) 领导职务的干部：党委、政府工作部门(含派出机构) 的副职和内设机构的领导职务 人大、政协工作机构(含派出机构) 的副职和内设机构的领导职务 纪委内设机构的领导职务 法院、检察院内设机构的非国家权力硬骨头依法任命人领导职务。此外，由非领导职务转任上述同级领导职务的，也可实行任职试用期制度。 八、公务员降职的原则、条件原则：能上能下原则 逐级降职原则。 条件：本人不称职 不能胜任现职工作。 方式：职薪同时降 降职不降薪。 程序：所在单位提出降职安排意见 对降职事由进行审核并听取降职公务员的意见 按照管理权限由有关领导集体研究决定，并依法任免。(不服，一个月内向上级主管机关申诉) 降职与行政处分的区别：首先，引起降职的原因，有相当一部分是客观上造成的，如工作需要、机构调整或职位变迁等。其次，即使降职是由于公务员主观因素引起的，如不称职，不胜任现职等，它所依据的条件与行政处分依据的条件也截然不同。再次，受行政处分，如降级、撤职的公务员，与受降职管理的公务员，在其所受的待遇也不同。 第七章 公务员奖励与惩戒知识点总结 公务员奖励的基本特征(1) 公务员奖励的主体是公务员所在机关或上级机关，即具有授奖权限的机关(2) 公务员奖励的对象是公务员个人或集体(3) 公务员奖励必须依法进行。 实施公务员奖励与惩戒的意义(1) 公务员管理体系的必要环节(2) 保证党和国家的路线、方针、政策和各项法规落实的有效措施(3) 提高公务员素质的重要保障(4) 实现党政机关廉洁、高效运行的切实需要。 公务员奖励的原则(1) 精神奖励与物质奖励相结合，以精神奖励为主(2) 公平、公正、公开(3) 定期奖励与及时奖励相结合。 公务员纪律的内容A.政治纪律：(1) 不得散布有损国家声誉的言论，组织或者参加旨在反对国家的集会、游行、示威等活动(2) 不得组织或者参加非法组织，组织或者参加罢工(3) 不得在对外交往中损害国家荣誉和利益。B.组织纪律：(1) 公务员不得拒绝执行上级依法作出的决定和命令(2) 旷工或者因公外出、请假期满无正当理由逾期不归C.工作纪律：(1) 公务员不得玩忽职守，贻误工作(2) 公务员不得压制批评，打击报复。(3) 公务员不得弄虚作假，误导、欺骗领导和公众(4) 公务员不得滥用职权，侵害公民、法人或者其他组织的合法权益(5) 公务员不得泄露国家秘密或者工作秘密D.廉政纪律：(1) 公务员不得贪污、行贿、受贿，利用职务之便为自己或者他人谋取私利(2) 公务员不得违反财经纪律，浪费国家资财(3) 公务员不得从事或者参与营利性活动，在企业或者其他营利性组织中兼任职务。 E.道德纪律：(1) 公务员不得参与或者支持色情、吸毒、赌博、迷信等活动(2) 公务员不得违反职业道德、社会公德。 公务员惩戒的程序(1) 初步调查 (2) 立案 (3) 正式调查 (4) 陈述和申辩 (5) 决定 (6) 告知 (7) 归档和备案。 务员奖励种类：(1) 嘉奖(2) 记三等功(3) 记二等功(4) 记一等功(5) 授予荣誉称号 行政机关公务员奖励程序：(1) 公务员所在单位提出奖励意见，上报审批机关(2) 审批机关的人事部门审核(3) 审批机关批准，并予以公布 撤销奖励的情形：(1) 弄虚作假，骗取奖励的(2) 申报奖励时隐瞒严重错误或者严重违反规定程序的(3) 有法律、法规规定应当撤销奖励的其他情形的 惩戒的条件：(1) 政治纪律，主要包括① 公务员不得散布有损国家声誉的言论，不得组织或者参加旨在反对国家的集会、游行、示威等活动② 公务员不得组织或者参加非法组织，不得组织或者参加罢工③ 公务员不得在对外交往中损害国家荣誉和利益 (2) 组织纪律① 公务员不得拒绝执行上级依法作出的决定和命令② 公务不得旷工或者因公外出、请假期满无正当理由逾期不归 (3) 工作纪律① 公务员不得玩忽职守，贻误工作② 公务不得压制批评，打击报复③ 公务员不得弄虚作假，误导、欺骗领导和公众④ 公务员不得滥用职权，侵害公民、法人或者其他组织的合法权益⑤ 公务员不得泄露国家秘密或者工作秘密 (4) 廉政纪律① 公务员不得贪污、行贿、受贿，利用职务之便为自己或者他人谋取私利② 公务员不得违反财经纪律，浪费国家资财③ 公务员不得从事或者参与营利性活动，不得在企业或者其他营业性组织中兼任职务 (5) 道德纪律① 公务员不得参与或者支持色情、吸毒、赌博、迷信等活动② 公务员不得违反职业道德、社会公德 (6) 其他纪律 惩戒的种类：(1) 警告(2) 记过(3) 记大过(4) 降级(5) 撤职(6) 开除 行政任免机关处分公务员的程序：(1) 初步调查(2) 立案(3) 正式调查(4) 陈述和申辩(5) 决定(6) 告知(7) 归档和备案 不同惩戒的处分期间：(1) 警告：六个月(2) 记过：十二个月(3) 记大过：十八个月(4) 降级：二十四个月(5) 撤职：二十四个月(6) 开除：不存在有限的处分期间 一、奖励惩戒的含义与意义奖励：机关依照法律法规的规定，对工作表现突出，有显著成绩和贡献，或者有其他突出事迹的公务员或公务员集体所给予的精神或物质的鼓励。渊源于干部奖励制度。 纪律：是政党、机关、团体、企事业单位等为维护本组织利益、实现其宗旨并保证其内部秩序而制定的要求每个成员遵守的行为准则。公务员纪律：是国家为保障各个机关实现其职能、维护机关的秩序和政党运转而制定的，要求每个公务员都必须遵守的行为准则。惩戒：指有关机关根据法定条件和法定程序，对违纪公务员给予的纪律处分。渊源于干部惩戒制度。 奖励的基本特征：授奖主体是公务员所在机关或上级机关，即拥有授奖权限的机关 受奖对象是公务员个人或公务员集体 公务员奖励必须依法进行，即公务员奖励的条件、种类、方式、权限等由法律法规规定，奖励主体必须按照这些规定实施奖励，不能随意改变法律法规规定的这些内容。 公务员纪律与义务的关系：都是以法律形式规定的，此处的纪律规定不同一般组织的纪律规定，它在本质上是另一种形式的义务规定，故二者是完全一致的。义务是相对权利而言的，它从下面要求公务员应当怎么做并从宏观上支配和约束着公务员行为，纪律则是义务的具体化，从反面要求公职人员不应当怎么做并从微观上支配和约束着公务员的行为。简单来说，义务规定积极性的作为要求，纪律则规定消极性的不作为要求 义务为纪律规定了前提，纪律则是义务的具体展开，二者相辅相成，相互补充，完整地构成约束公务员行为的法律体系，为公务员惩戒规定了条件。 实施奖励与惩戒的意义： 1. 建立和健全奖励与惩戒制度是公务员管理体系的必要环节 2. 是保证党和国家的路线、方针、政策和各项法规的落实的有效措施 3. 是提高公务员素质的重要保障 4. 是实现各级党政机关廉洁、高效运行的切实需要。 二、奖励的原则、条件与种类原则：精神奖励与物质奖励相结合、以精神奖励为主的原则 公平、公正、公开的原则 定期奖励与及时奖励相结合的原则。 条件： 三项原则：精神奖励：对受奖者给予荣誉的激励，如记功、授予荣誉称号等，增强其光荣感，满足其精神需求物质奖励：给予实物的激励，如颁发奖品、奖金等，满足其物质需求。公平：公务员在奖励制度面前平等，符合公务员相应奖励条件的都能获得相应的奖励种类，不存在双重的或多重的奖励标准公正：奖励主体在实施奖励的过程中，不能偏私，严格地遵守法定奖励条件和法定奖励程序公开：奖励标准、奖励结果保持高度透明，不搞“暗箱操作”。 定期奖励：以年度为时间单位且年度考核为基础的奖励，针对公务员在履行日常本职工作中作出突出成绩的奖励 及时奖励：随时奖励，针对公务员完成专项任务、处理突发事件或在特定环境中作出突出贡献的奖励。 十类条件(表 2) ： 序号 受奖行为(受奖内容+受奖程度(判断权授予了授奖主体) ) 1 显著工作成就奖 忠于职守，积极工作，成绩显著 2 廉洁奉公模范奖 遵守纪律，廉洁奉公，作风正派，办事公道，模范作用突出 3 创造发明奖 合理化建议奖 在工作中有发明创造或提出合理化建议，取得显著经济效益或社会效益 4 民族团结贡献奖 为增进民族团结、维护社会稳定作出突出贡献 5 节约资源贡献奖 爱护公共财产，节约国家资财有突出成绩 6 防止事故有功奖 防止或消除事故有功，使国家和人民群众利益免受或减少损失 7 抢险救灾贡献奖 在抢险、救灾等特定环境中奋不顾身，作出贡献 8 英勇斗争功绩奖 同违法行为作斗争有功绩 9 外交贡献奖 在对外交往中为国家争得荣誉和利益 10 其他功绩奖 有其他突出功绩 五种类型(表 3) ： 奖励种类 成就和贡献 审批机关(权限共配置) 嘉奖 表现突出，取得优良成绩 县级以上人民政府或市(地) 级以上人民政府工作部门 记三等功 作出较大贡献，取得显著成绩 记二等功 作出重大贡献，取得优异成绩 市(地) 级以上人民政府或省级以上人民政府工作部门 记一等功 作出重大贡献，取得优异成绩 省级以上人民政府或国务院工作部门 授予荣誉称号 功绩卓著，有特殊贡献 省级以上人民政府国务院 应用：运用奖励的基本知识分析现实中与公务员奖励相关的问题。 三、奖励的权限、程序与撤销权限：指公务员奖励的决定权和审批权，即奖励权限问题就是什么样的奖励种类由什么样的机关来决定或审批的问题。 撤销：指受奖对象受奖后，授奖主体或其上级机关发现公务员奖励不符合规定要件(主要是法定奖励条件和法定奖励程序) 而取消奖励的行为。 行政机关奖励权限的配置：(表 3) 奖励的程序：公务员所在单位提出奖励意见，上报审批机关 审批机关的人事部门审核 审批机关批准，并予以公布。撤销奖励的效力(表 4) ： 应用：运用奖励的基本知识分析现实中与公务员奖励相关的问题。 四、惩戒的条件与种类惩戒条件：指公务员纪律的内容，即公务员法确定的公务员应当遵守的基本行为准则。包括：政治纪律、组织纪律、工作纪律、廉政纪律、其他纪律。 政治纪律：在政治方面应当遵守的行为准则，即政治纪律是限制公务员政治行为的准则，包括三项：(1) 不得散布有损国家声誉的言论，不得组织或者参加旨在反对国家的集会、游行、示威等活动(2) 不得组织或参加非法组织，不得组织或参加罢工(3) 不得在对外交往中损害国家荣誉和利益。 公务员不得拒绝执行上级依法作出的决定和命令：公务员执行公务时，认为上级的决定或命令有错误的，可以向上级提出改正或撤销该决定或命令的意见 上级不改变或要求立即执行的，公务员应当执行，执行的后果由上级负责，公务员不承担现任但，公务员执行明显违法的决定或命令的，应当依法承担相应现任。 公务员不得人事或者参与营利性活动，不得在企业或者其他营利性组织中兼任职务：营利性活动是一种“私人”活动，是追逐利润的活动，而公务性活动则是一种“公共”活动，是维护社会公平和正义的活动，二者有各自活动的边界，不能相互融合，否则就是官商不分，容易出现官商勾结、权钱交易的腐败现象。营利性活动不等于经济活动，如购买股票是允许的。 惩戒种类：警告：六个月记过：十二个月记大过：二八个月降级：二十四个月撤职：二十四个月开除：不存在有限的处分期间。 应用：运用公务员惩戒的知识分析现实中与公务员奖励相关的问题。 五、惩戒的程序、法律后果与解除程序：初步调查 立案 正式调查 陈述和申辩 决定 告知 归档和备案。 解除：指公务员受开除以外的处分，在受处分期间有悔改表现，并且没有再次发生违纪行为的，处分期满后，终止处分的执行。 程序：法律后果：受警告处分的，在处分期间内不得晋升职务和级别，但可以晋升工资档次 受记过、记大过、降级、撤职处分的，不得晋升职务和级别、工资档次，其中受撤职处分的还要降低一定职务层次任职，并且按照新任职务确定相应的级别。 解除：三处条件：悔改表现，没有再次违纪行为，以及处分 期满。程序：提出解除申请(单位提) ——审查并决定(原处分机关) ——以书面通知本人应用：运用公务员惩戒的知识分析现实中与公务员奖励相关的问题。 第八章 公务员培训知识点总结 公务员培训的含义公务员培训是指国家行政机关根据经济、社会发展需要和公务员的职位要求，以政治理论、政策法规、业务知识、文化素养和技能训练为基本内容，以提高和改进公务员的素质能力为目的，通过各种形式，有组织地为公务员提供教育训练活动。 公务员培训的特点：(1) 公务员培训目标的时代性(2) 公务员培训内容的实用性(3) 公务员培训手段的多样性(4) 公务员培训方式的法定性(5) 公务员培训的持续性 公务员培训的意义(1) 提高政府服务意识，实现政府战略任务的重要保障(2) 提高政府效能，加强政府自身建设和廉政、勤政建设的重要措施(3) 建设高素质、专业化公务员队伍，提升人力资源能力的重要途径(4) 公务员的权利之一，公务员管理的重要组成部分。 公务员培训的基本原则(1) 理论联系实际 (2) 学用一致 (3) 按需施教 (4) 讲求实效。 公务员培训规划与设计(1) 了解组织的工作性质、技能要求，组织绩效的理想状况与实际状况的差距等因素，明确它们如何决定培训的必要性(2) 对培训对象、内容、方式进行分析(3) 培训主管部门所接受的培训对象的范围(4) 培训对象的规模(5) 培训工作的费用支出。(6) 确定承担培训的教育机构(7) 确定教师的素质(8) 确定培训的方式，集中或分散。 公务员培训的评估(1) 培训总体评估：注重考察三方面，即培训需求、培训规划设计、培训机制(2) 受训者的反应评估：对培训内容方面的评估 对培训方法的评估 对培训后勤保障的评估。(3) 受训者的知识、技能学习成果评估：学员在培训中的学识增长情况 学员行为方式的改进。(4) 个人绩效评估：观察法 比较法调查法(5) 组织绩效的评估：客观指标测量法 主观评价法。 公务员培训的相关法律法规和文件规定：(1) 国家法律(2) 党内条例(3) 党和政府相关文件 公务员培训的种类：(1) 初任培训(2) 任职培训(3) 专门业务培训(4) 在职培训(5) 其他培训，包括专项培训，对口培训，MPA 专业学位教育，境外培训，通用知识和技能培训 公务员培训的内容：(1) 政治理论和政策法规培训(2) 业务知识培训(3) 文化素养培训和技能训练 业务知识培训的课程：(1) 公共必修课，包括公共管理，法律法规，市场经济，现代科技和行为规范(2) 专业选修课(3) 选修课 公务员培训的施教机构：(1) 国家行政学院(2) 地方行政学院(2) 其他培训机构 公务员培训施教机构的管理：(1) 加强培训师资队伍和管理者队伍建设(2) 建立统一规范、科学实用的教材体系(3) 加强培训工作研究，积极推广培训工作中先进经验和做法(4) 建立公务员培训施教机构准 入制度和评估制度我国公务员培训的管理体制培训需求分析的基本要素：(1) 个体层次的培训需求分析(2) 组织层次的培训需求分析(3) 国家或地区战略层次的培训需求分析 培训需求分析的主要方法：(1) 培训需求的问题分析法(2) 培训需求的全面分析法(3) 引入行为科学或社会调查的一系列方法 问题分析法的环节：(1) 发现和确认问题阶段(2) 收集资料或直接观察(3) 分析、判断和证实造成问题的主要原则(4) 培训需求的分析(5) 说明培训需求分析的结果 全面分析法的环节：(1) 进行工作分析(2) 编写出组织任务和所需技能的目录清单(3) 分析组织现实的绩效水平状况(4) 培训规划设计 公务员培训规划设计的内容：(1) 了解组织工作性质、技能要求、组织绩效的理想状况与实际状况差距等因素，明确它们是如何决定培训的必要性的(2) 对培训对象、内容和方式的分析(3) 培训主管部门所接受的培训对象的范围(4) 培训对象的规模(5) 培训工作的费用支出(6) 确定承担培训的教育机构(7) 确定教师的素质(8) 确定培训是采用集中的还是分散的形式进行 公务员培训的技术方法：(1) 课堂讲授法(2) 研讨法(3) 案例分析法(4) 角色扮演法(5) 合作研究法 公务员培训评估的环节：(1) 培训总体评估(2) 受训者反应评估(3) 受训者知识、技能学习成果评估(4) 个人绩效的评估(5) 组织绩效的评估 一、公务员培训的含义与意义含义：国家行政机关根据经济、社会发展需要和公务员职位要求，以政治理论、政策法规、业务知识、文化素养和技能训练为基本内容，以提高和改进公务员素质能力为目的，通过各种形式、有组织地为公务员提供的教育、训练活动。 培训自身的特点：公务员培训目标的时代性 内容的实用性 手段的多样性 方式的法定性 时间的持续性。 意义：作为干部队伍的重要组成部分，加强公务员培训对促进我国经济社会发展提高政府能力和公务员素质具有十分重要的意义： 公务员培训是提高政府服务意识，实现政府战略任务的重要保障 是提高政府效能，加强政府自身建设和廉政、勤政建设的重要措施 是建设高素质专业化公务员队伍，提升人力资源能力的重要信息途径 是公务员的权利之一，是公务员管理的重要组成部分。 二、公务员培训的基本原则、相关法律法规和文件规定基本原则：理论联系实际原则 学用一致原则 按需施教原则 讲求实效原则。 应用：运用公务员培训的国家法律：《公务员法》第十章的第六十条——每六十二条、党内工作条例、党和政府相关文件，分析我国公务员培训的法定依据。 三、公务员培训的种类公务员培训四大类的含义： 四大类公务员培训的含义及其对象、目的和内容、结果使用等 四、公务员培训的内容三内容： 政治理论和政策法规培训 业务知识培训：(1) 公共必修课：公共管理 法律法规 市场经济 现代科技 行为规范 (2) 专业必修课 (3) 选修课 文化素养培训和技能培训。应用：分析公务员培训的内容与当前经济社会发展、政府管理的相关性。参照《干部教育培训工作条例(试行) 》的有关规定，公务员培训的内容应当根据经济社会发展需要，结合岗位职责要求和不同层次、不同类别公务员的特点，以政治理论、政策法规、业务知识、文化素养和技能训练等为基本内容，促进公务员素质和能力的全面提高。 五、公务员培训施教机构与管理施教机构的种类：国家行政学院 地方行政学院 其他培训机构。 公务员培训施教机构的管理：根据培训需求，深化教学改革，创新培训内容，改进培训方式，科学设置培训班次和学制，完善学科结构和课程设计，提高教学水平。各类公务员培训施教机构要围绕本地区、本部门的中心工作和和队伍建设的实际开展培训工作。加强培训师资队伍和管理者队伍建设 建立统一规范、科学实用的教材体系 加强培训工作研究，积极推广培训工作中先进经验和做法 建立公务员培训施教机构准入制度和评估制度。 公务员培训的管理体制：我国整个干部教育培训的管理体制实行的是统一领导、分工负责的体制：(1) 全国干部培训工作实行在党中央领导下，由中央组织部主管，中央和国家机关有关工作部门分工负责，中央和地方分级管理的体制。(2) 中组部履行全国干部教育培训工作的整体规划、宏观指导、协调服务、督促检察、制度规范等职能。(3) 地方各级党委领导本地区干部教育培训工作，贯彻执行党和国家干部教育培训工作的方针政策，把干部教育培训工作纳入本地区经济社会发展规划，研究部署本地区干部教育培训工作。(4) 干部所在单位按照干部管理权限，负责组织实施本单位的干部教育培训工作。(5) 部门与地方双重管理的干部教育培训工作由主管方负责组织 经协商，也可由雷管方负责组织。 六、公务员培训的需求分析概念：组织在培训活动之前,从长远发展目标或近期目标出发,采用各种方法和技术,对组织及其成员的现有素质构成知识和技能种类等方面进行的系统鉴别和分析。 三大基本要素：个体层次：了解组织内员工的现有知识、素质能力等方面的状况和结构，找出与应有状况之间的差距组织层次：通过对组织总体目标、资源状况和环境等各种因素的判断，发现组织在培训工作中存在的问题，明确组织应有的员工素质结构状况与现有实际素质结构状况之间的差距，并说明培训是否解决现有差距的最有效的方法国家或地区战略层次：随着经济社会发展的迅速京华以及政府工作所面临的全局性特点，公务员培训需求还必须要从国家或所在的发展战略角度来加以分析，以适应变革时代和改革开放形势的要求。 三主要方法：(1) 培训需求的问题分析法：主要集中于组织或组织成员中存在的问题，即在分析组织及其工作人员现在状况和理想状况差距的基础上，确认和提出造成差距的症结和根源，明确培训是否是解决这些问题、提高组织绩效的有效途径。五环节：发现和确认问题阶段 收集资料或直接观察 分析、判断和证实造成问题的主要原因 培训需求的分析 说明培训需求分析的结果。 (2) 培训需求的全面分析法：通过对组织内部各个层面进行全面、系统地调查、分析，确定理想状态与现实状态的差距，从而进一步决定是否进行培训，培训什么以及如何培训等。 四环节：进行工作分析，研究组织工作的性质，以此制定出组织岗位评价标准和职位规范 编写组织任务和所需技能的目录清单 分析组织现实的绩效水平状况，找出差距，认识问题的性质和造成问题的原因，这样又回到上述问题分析方法的过程 培训规划设计。 (3) 引入行为科学或社会调查的一系列方法。 七、公务员培训的规划与设计的概念概念：根据组织根据发展的目标和对公务员未来培训需求状况的预测，制定专门计划，设计组织近期与未来培训活动的方案。 应考虑的因素： 了解组织工作性质、技能要求、组织绩效的理想状况与实际状况差距等因素，明确它们是如何决定培训的必要性的 对培训对象、内容与方式的分析 培训主管部门所接受的培训对象的范围 培训对象的规模 培训工作的费用支出 确定承担培训的教育机构 确定教师的素质 确定培训是采用集中的还是分散的形式进行。 应用：运用公务员培训规划与设计方法，对具体公务员培训案例进行规划和设计。 八、公务员培训的技术方法种类：5 种公务员培训技术方法的特点：课堂讲授法(组织简单性、易操作性、经济性以及讲课老师的习惯性)研讨法(灵活性大)案例分析法( 案例量刑一般来自组织的实际问题 尽量让参加者陈述他们的看法，并倾听他人意见，正视不同看法并作出决策 可以将学员对教师的依赖程度降到最低限度 教师很少回答“对”或“不对”，力求学员自己作出独立判断 教师主要通过创造讨论气氛和控制讨论过程来推进案例分析的深入。) 角色扮演法：(可以发现学员的管理才能和解决问题的能力，还可以了解学员中存在产问题，指导他们修正行为) 合作研究法(对学员培训后的一种综合性理论以及智力、技能的训练，是对学员培训结果的总结和成果反映) 。 九、公务员培训的评估概念：贯穿于公务员整个培训过程的管理控制活动，是对公务员培训全过程和最终效果的综合评估，它对于改进公务员培训质量、提高公务员培训效果具有十分重要的作用。 5 主要环节： 培训总体评估(培训需求、培训的规划设计、培训机制) 受训者反应评估(对培训内容方面、方法、后勤保障的评估) 受训者知识、技能学习成果评估(学员在培训中的学识增长情况 学员行为方式的改进) 个人绩效的评估(通过观察、比较、调查) 组织绩效的评估(是最终目标，分客观指标测量法 主观评价法) 第九章 公务员交流与回避知识点总结 公务员交流的含义公务员交流，是指国家机关根据工作需要或公务员的个人意愿，通过调任、转任、挂职锻炼等形式变换公务员的工作职位，从而产生或变更公务员职务关系或工作关系的一种人事管理活动与过程。(1) 公务员交流的法定形式包括调任、转任、挂职锻炼，每种形式都有特定目的、范围、对象与相应的条件、程序。(2) 交流是机关对公务员的一种管理活动和手段，必须经过机关决定安排或批办手续(3) 交流的原因包括：一是工作需要 二是通过交流锻炼提高领导能力 三是避免在一个地方或部门工作时间较长产生腐败行为 四是根据规定需要回避 五是照顾公务员的个人愿望。(4) 公务员交流，一般属于同一职务层次的平级调动，但也要与提拔使用、降职相结合。 公务员交流的意义(1) 有利于开阔公务员的视野，使公务员得到等方面的锻炼(2) 促进人才的合理使用(3) 有利于防止腐败行为的发生，突进廉政建设(4) 解决公务员的实际生活困难。 公务员回避的意义(1) 有利于防止腐败产生，促进国家机关廉政建设(2) 有助于公务员健康成长(3) 有助于消除政治上的不稳定因素，提高国家机关工作效率。 公务员的回避具有以下特征：(1) 强制性(2) 预防性 公务员交流的原则(1) 依法进行原则 (2) 适才使用原则 (3) 个人服从组织原则 (4) 合理原则。 挂职锻炼管理中应当注意的问题(1) 应选好锻炼人选(2) 应选好锻炼去向(3) 应掌握好锻炼时间(4) 应加强对锻炼人员的管理。 公务员回避的原则(1) 政策配套原则 (2) 依法回避原则 (3) 内外监督原则 (4) 自我约束原则。 我国公务员回避的形式(1) 任职回避：对有特定亲属关系的公务员，在担任某些某些关系密切的职务方面做出的限制(2) 地域回避：担任一定职务的公务员，为了公正履行职务，不得在亲属比较集中的原籍、成长地等任职(3) 公务回避：公务员在执行公务的过程中，遇有法定情形，避免影响正当履行公务而进行的回避。 公务回避的特点(1) 时限性 (2) 范围更广泛 (3) 对象改更广泛。 国外公务员交流的种类：(1) 部门内同一职系的调动 (2) 跨部门跨职类调动 (3) 竞职式交流 (4) 跨地域交流 我国公务员交流的形式：(1) 调任(2) 转任(3) 挂职锻炼 调任的条件：(1) 调任人选要符合公务员法第十一条所规定的担任公务员的七项基本条件，这是所有公务员都应当具备的条件(2) 调任人选要符合拟任职位所要求的资格条件(3) 调任人选还必须符合公务员法第二十四条的规定，即不能是因犯罪受到刑事处罚、被开除公职或有法律规定不得成为公务员的其他情形的人员 转任原因包括：(1) 机关根据工作需要决定公务员转任(2) 经公务员个人申请、机关批准同意的转任 转任必须符合三方面的要求：(1) 转任公务员必须具备拟任职位所要求的资格条件(2) 转任必须在规定的编制限额和职数内进行(3) 转任中如果出现职务升降，应当按照公务员职务升降的有关规定，履行必要的程序 理解领导成员的转任要求，需要把握以下几点：(1) 在领导干部转任的问题上，公务员法充分吸收了《党政领导干部选拔任用工作条例》的成果(2) 公务员法特别强调领导成员交流的重要性，专门规定了领导成员转任的要求(3) 领导成员转任指“省部级正职以下”的领导 理解对担任机关内设机构领导职务和工作性质特殊的非领导职务的公务员转任要求，应当从以下几个方面入手：(1) “工作性质特殊的非领导职务”是指，直接经管“人、财、物”和执行执法监督职能的职务(2) 这类转任的范围主要在本机关内部，一般不跨地区、跨部门进行(3) 这类转任是具有强制性的，公务员个人有义务服从组织决定(4) 这类转任要有计划性，应事先制订计划，确定转任的具体人员、转任去向、转任时机等 与调任、转任相比，挂职锻炼的特殊性：(1) 挂职锻炼不办理调动手续(2) 挂职锻炼有时间性(3) 挂职锻炼是一种内外混合型的交流形式 挂职锻炼的种类：(1) 进行实践锻炼(2) 进行培养锻炼(3) 进行使用锻炼 挂职锻炼管理中应注意的问题：(1) 应选好锻炼人选(2) 应掌握好锻炼时间(3) 应加强对锻炼人员的管理 在国外，需要回避的亲属关系主要有：(1) 血亲关系(2) 夫妻关系(3) 姻亲关系(4) 拟制亲关系 我国公务员回避的形式：(1) 任职回避(2) 地域回避(3) 公务回避 公务回避的特点：(1) 公务回避具有时限性(2) 公务回避的范围更广泛(3) 公务回避的对象更广泛 公务回避的范围：(1) 涉及本人利害关系的(2) 涉及与本人有夫妻关系、直系血亲关系、三代以内旁系血亲关系、近姻亲关系人员的利害关系的(3) 其他可能影响公正执行公务的情形 公务员回避的提起有两种情形：(1) 公务员本人主动申请回避(2) 利害关系人发现公务员有法律规定的应当回避的情形，可以提出要求公务员回避 一、公务员交流的含义与意义含义：指国家机关根据工作需要或公务员个人愿望，通过调任、转任、挂职锻炼等形式变换公务员的工作职位，从而产生或变更公务员职务关系或工作关系的一种人事管理活动与过程。 意义：是公务员管理的一项不可缺少的环节，它充分体现了国家机关的开放性，能够很好地推进人力资源的全面发展：(1) 有利于开阔公务员的视野，使公务员得到多方面的锻炼(2) 促进人才的合理使用(3) 有利于防止腐败行为的发生，推进廉政建设的发展(4) 解决公务员的实际生活困难。 二、公务员交流的原则交流的 4 原则：依法进行原则; 适才适用原则; 个人服从组织原则; 合理原则。 三、公务员交流的形式：从流向看分：地域性交流、跨部门交流、岗位交流调任：指国有企业事业单位、人民团体和群众团体中从事公务员的人员调入国家机关担任领导职务或副调研员以上及其他职务已将的非领导职务 即指让公务员队伍以外的其他从事公务的人员变成公务员的一种方式，是公务员队伍除“录用”以外的另一个“入口”。 转任：公务员因工作需要或其他正当理由在机关系统内跨地区、跨部门的调动，或在同一部门内的不同职位之间进行的转换任职。 挂职锻炼：指机关有计划地选派公务员在一定时间内到下级机关或上级机关、其他地区机关以及国有企业事业单位担任一定职务，经受锻炼，在丰富经验，增长才干。 调任对象：国有企业事业单位、人民团体和群众团体中担任一定职务，已经具备进入机关后所担任职务的德、才条件的人员。 转任对象：机关根据工作需要决定公务员转任 公务员个人申请、机关批准同意的转任。 挂职锻炼对象：新录用公务员(进行实践锻炼) 有一定工作经验和社会阅历，综合素质比较高，工作成绩比较突出，但缺乏领导经验的中青年公务员(培养锻炼) 准备提拔使用或准备离开公务员队伍到国有企业事业单位任职的公务员(使用锻炼)应用：正确分析调任、转任、挂职锻炼的正误案例。 四、党政领导干部的交流制度党政领导干部交流对象：P185交流范围和方式：P186 五、公务员回避的含义与意义含义：通过对公务员所任职务、执行公务和任职地区等方面作出限制性规定，减少亲属关系等人为因素对工作的干扰，保证公务员公正廉洁地执行公务的法律制度。 意义：是公务员管理制度中一项重要内容，它以公务员对亲属的回避为中心，体现了公务员管理制度的公正、公开、公平，能有效地防止机关内腐败现象的发生，帮助公务员摆脱各种人情关系的纠缠，更好地履行职责：(1) 回避有助于防止腐败的产生，促进国家机关的廉政建设(2) 有助于公务员健康成长(3) 有助于消除政治上的不安定因素，促进国家机关工作效率的提高。 六、公务员回避的原则：政策配套原则 依法回避原则 内外监督原则 自我约束原则 七、公务员回避的形式任职回避：指对有特定亲属关系的公务员，在担任某些关系密切的职务方面作出的限制。地区回避：指担任一定职务的公务员，为了公正履行职务，不得在亲属比较集中的原籍、成长地等任职。公务回避：指公务员在执行公务的过程中，遇有法定情形，避免影响正当履行公务而进行的回避。 任职回避对象、范围：夫妻关系、直系血亲关系(祖父母、外祖父母、父母、子女、孙子女、外孙子女等自然血缘亲属；养父母、养子女等法律拟制直系血亲) 、三代以内旁系血亲关系、近姻关系(配偶的父母和兄弟姐妹、子女的配偶及其父母、兄弟姐妹的配偶等) 地区回避对象：担任县(市) 委书记、县(市) 长职务以及县(市) 纪检机关、组织部门、人民法院、人民检察院和公安部门主要领导职务的，一般不得在本人成长地担任这些部门的正职领导成员。 范围：担任乡级机关、县级机关及其有关部门主要领导职务的，应当实行地域回避，法律另有规定的除外。 公务回避对象、范围：涉及本人利害关系的；涉及与本人有夫妻关系、直系血亲关系、三代以内旁系血亲关系、近姻关系人员利害关系的；其他可能影响公正执行公务的情形。 应用：正确区分种类有亲属关系的人员及其所任职的情况、区域，判定其应不应回避，属何种回避？ 第十章 公务员工资、福利与保险知识点总结 建立公务员工资保险福利制度的意义 (1) 有利于保障公务员的基本需求 (2) 有利于调动公务员的积极性 (3) 有利于吸纳高素质人才。 制定公务员工资制度的基本原则 (1) 按劳分配原则：体现工作职责、工作能力、工作实绩、资历等因素；体现不同职务、级别之间合理的工资差距。 (2) 正常增资原则：定期增加公务员的工资； (3) 平衡比较原则：公务员工资水平与企业单位相当人员的工资水平大体保持平衡。 (4) 法律保障原则：公务员工资制度以法律形式确定。 在落实平衡比较原则过程中，如何建立工资调查制度 (1) 确定相当人员的界定条件，并对工资收入、福利待遇等进行比较； (2) 确定如何应用工资调查比较结果考虑公务员工资水平，主要考虑国民经济发展水平、财政承受能力、企业相当人员工资水平等因素； (3) 确定机构、人员的抽样条件； (4) 建立调查系统，确定调查方式。 公务员工资构成 (1) 基本工资：包括职务工资、级别工资； (2) 津贴：包括地区附加津贴、艰苦边远地区津贴、岗位津贴； (3) 补贴； (4) 奖金。 公务员福利的作用 (1) 对公务员的基本生活需要给予必要的保障； (2) 提高公务员的物质文化生活需要水平； (3) 增加公务员队伍的吸引力和凝聚力。 公务员福利制度存在的问题和改革趋势 A. 存在的问题： (1) 福利制度比较陈旧，总体水平偏低 (2) 福利发放差距大和平均主义并存； (3) 改革滞后，与各项制度不配套。 B. 改革趋势：按照“职务与级别相结合的制度，建立公务员激励和保障机制”的要求，将提高工资和改革福利相结合，坚持福利货币化、透明化、规范化的方向，实行合理的福利待遇。 公务员保险的作用 (1) 为丧失劳动能力的公务员提供基本生活保障； (2) 为暂时丧失劳动能力的公务员提供必要的物质帮助，进而促进经济发展，稳定社会 (3) 使公务员亲身感觉到职业的优越性，工作自豪感和荣誉感，进而调动公务员的工作积极性。 公务员保险制度存在的问题和改革的趋势 A. (1) 没有建立基金积累制度 (2) 保险制度不健全，失业保险尚未建立起来 (3) 管理不科学，缺乏有效的约束监督机制。医疗等经费增长过快，浪费严重。 B. (1) 改变离退休费由国家统包、现收现付的状况，建立养老保险基金由国家、个人共同合理负担，符合机关特点的社会养老保险积极的筹集和运营机制。 (2) 建立失业保险制度。 (3) 实行工伤保险制度。 (4) 按照行政管理和基金运营分开原则，实行养老、实业、工伤、医疗等保险基金管理。 英国公务员的津贴主要有：(1) 伦敦补贴(2) 超时勤务补贴(3) 假日勤务津贴(4) 夜间勤务津贴(5) 技能津贴 美国公务员的津贴主要有：(1) 地区津贴(2) 特殊工作津贴(3) 其他津贴 公务员福利的项目：(1) 休假制度(2) 优抚制度(3) 其他福利制度(4) 公务员工时制度 现阶段公务员福利制度存在的问题：(1) 福利制度比较陈旧，总体水平偏低(2) 福利发放差距大和平均主义并存(3) 改革滞后，与各项制度改革不配套 公务员保险的项目：(1) 基本医疗保险制度(2) 生育保险制度 新西兰公务员的养老体系主要包括：(1) 养老金制度(2) 政府养老金基金制度(3) 节俭计划 公务员保险制度存在的问题：(1) 没有建立基金积累制度(2) 保险制度不健全，失业保险尚未建立起来(3) 管理不科学，缺乏有效的约束监督机制 一、公务员工资福利保险的含义与意义1．识记：工资：国家以法定货币支付给公务员个人的劳动报酬，是公务员劳动创造价值的货币表现，用惊人保障公务员生活消费支出的需要，激励公务员更好地完成任务。福利：国家机关向公务员提供的除工资、奖金之外的各种补贴、服务以及实物报酬。保险：国家对因生育、年老、疾病、伤残等原因，暂时或永久丧失劳动能力的公务员给予物质帮助的一种保障制度。 2．领会： 公务员工资福利保险的意义：有利于保障公务员的基本要求；有利于调动公务员的积极性；有利于吸纳高素质人才。 二、公务员工资识记：现行工资结构的主体构成： 基本工资：即职务工资、级别工资，是工资的主体，是确定公务员退休金、抚恤金等项目的主要依据。 津贴：对在特殊劳动条件下或工作环境下付出额外劳动消耗和生活费支出所给予的适当补偿，是工资的一种补充形式和工资制度的重要组成部分。分：(1) 地区津贴：又分：地区附加津贴、艰苦边远地区津贴 (2) 岗位津贴。 补贴：国家适应职务消费和福利等改革的需要，提高公务员的改革承受能力，对公务员进行的适当进行的适当弥补，包括住房补贴、医疗补贴。 奖金：即年终一次性奖金，是对公务员的工作表现和工作业绩的奖励。 职务级别工资制的概念：按照公务员的职务、级别、年功和实际贡献，确定工资标准的一种工资制度。 津贴及地区津贴的概念：对公务员在特殊劳动条件下或工作环境下付出额外劳动消耗和生活费支出所给予的适当补偿，是工资一种补充形式和工资制度的重要组成部分。类型： 地区津贴：(1) 地区附加津贴：主要反映地区间经济发展水平、物价消费水平差异，同时考虑机关工作人员工资水平与企业职工工资水平的差距。(2) 艰苦边远地区津贴：主要体现不同专区间自然地理环境、社会发展等方面的差异，是对公务员在艰苦边远环境下工作生活的补偿。 岗位津贴：根据公务员岗位性质及工作条件确定的，主要发给那些苦、脏、累、险岗位上工作的公务员。 领会：(1) 了解公务员职能工资制不同发展阶段的情况特点：第一阶段：1993. 10. 1—2005. 12. 31：实行职级工资制；第二阶段：2006. 1. 1 以后：实行职务和级别相结合的工资制度，特点：增强级别工资的激励功能，从原来的 15 个级别增加到现在的 27 个级别，重点增加了县以下基层公务员所对应的级别数量。 确定公务员工资的原则： 按劳分配原则：(1) 体现工作职责、工作能力、工作实绩、资历等到因素(2) 保持不同职务、级别之间合理的工资差距。 正常增资原则：定期增加公务员的工资，即每年的财政预算中，按照法律规定保证必要的经费用于增加公务员的工资。这样，一方面可以使公务员的工资水平年年有所增长，另一方面，公务员之间由于工作年限、能力水平等不同，工资报酬也拉开了差距，从而能够调动公务员的积极性，提高工作效率。包括正常晋升工资；调整工资标准。 平衡比较原则：在确定公务员的工资时，应参照国有企业相当人员的工资水平，使公务员的工资水平与企业单位相当人员的工资水平大体保持平衡，是协调公务员与外部系统分配关系的主要原则。应当确定：(1) 相当人员的界定条件及对工资收入、福利待遇的哪些内容进行比较(2) 如何应用工资调查比较结果考虑公务员工资水平，主要考虑国民经济发展水平、财政承受能力、企业相当人员工资水平等因素(3) 机构和人员的抽样条件(4) 建立调查系统，确定调查的具体方式。 法律保障原则：公务员的工资制度以法律的形式确定下来，公务员的工资管理以法律为依据，受到法律的保障。 应用：运用公务员工资的知识分析现实中与工资有关的问题。 三、公务员福利(1) 主要内容：休假制度；优质制度；其他福利制度；公务员工时制度(2) 法定节假日：(3) 工时制的含义：每日 8 小时，每周 40 小时。 福利制度存在的问题： 1. 福利制度比较陈旧，总体水平偏低； 2. 福利发放差距大和平均主义并存； 3. 改革滞后，与各项制度改革不配套。 应用：就改革公务员福利待遇提出你的议。按照“完善公务员职务与级别相结合的制度，建立公务员激励和保障机制”的要求，将提高工资与改善福利待遇，鼓励公务员长期为国家服务，使公务员的福利与现行工资制度相配套，与时代同步。 四、公务员保险(1) 基本医疗保险制度的概念：公务员因患病暂时丧失劳动能力时，从国家或所在单位获得物质帮助的制度，主要由患病期间医疗待遇和治疗期间的生活待遇两部分组成。 (2) 生育保险制度的概念：P213 领会：(1) 保险的作用： 为丧失劳动能力的公务员提供了基本生活保障； 为暂时丧失劳动能力的公务员提供必要的物质帮助，使他们尽快恢复劳动能力，保证了劳动力再生产的顺利进行，这对促进经济发展，维护社会稳定，都具有重要作用 使公务员亲身感觉到职业的优越性，工作的自豪感和荣誉感，对于保护公务员的切身利益，提高公务员的健康水平，稳定公务员队伍，调动公务员工作的积极性，都有十分重要的作用。 保险制度存在的主要问题： 1. 没有建立基金积累制度； 2. 保险制度不健全，失业保险尚未建立起来； 3. 管理不科学，缺乏有效的约束监督机制。 保险改革的趋势： 改变离退休费由国家统包、现收现会的状况，建立养老基金由国家、个人共同合理负担，符合机关特点的社会养老保险基金的筹集和运营机制。 建立失业保险制度； 完善工伤制度； 按照行政管理与基金运营分开的原则，进行养老、失业、工伤、医疗保险基金的管理。 第十一章 公务员辞职、辞退与退休知识点总结 建立公务员辞职制度的意义(1) 有利于畅通公务员队伍的出口，形成能进能出的更新机制(2) 落实了自由选择职业的权利，有利于提高员工的积极性(3) 有利于规范机关的人事管理行为。 建立公务员辞退制度的意义(1) 体现优胜劣汰的竞争机制(2) 保证公务员队伍充满活力(3) 建立高效廉洁政府的有效措施。 建立公务员退休制度的意义(1) 有利于公务员队伍新老交替的正常化，增强公务员队伍的生机或活力(2) 是宪法赋予公务员老有所养权利的真正体现，是对公务员履行退休义务的监督(3) 是调节公务员领导职务、克服公务员领导职务终身制的重要形式(4) 有利于廉政勤政建设。 公务员辞去公职的特征(1) 辞去公职是公务员自主择业的权利(2) 辞去公职必须经过法律程序(3) 辞去公职的公务员享受法定的辞职待遇(4) 辞去公职权利的限制性。 辞去公职与擅自离职的区别辞去公职与擅自离职都是公务员本人意愿的表现，其区别包括：(1) 公务员辞去公职的意愿得到法律确认，受法律保护；擅自离职的意愿没有得到法律认定，公务员必须承担不履行义务的后果(2) 辞去公职是公务员自主择业的权利，公务员是否行使该权利及其法律后果，由公务员自行处理；擅自离职是一种违纪行为，要被追究责任。 辞去公职与免职的区别免职是公务员任免机关依照法定事由和法定程序，免除公务员所担任职务的人事行政行为。二者差别：(1) 性质不同：辞去公职是公务员自主择业的权利，是公务员自愿的法律行为；免职是机关的人事行政行为，是任免机关等单方面的法律行为，公务员必须服从。(2) 原因不同：辞去公职出于公务员的个人意愿；免职基于法定事由，如转任。(3) 法律后果不同：辞去公职是公务员与机关职务关系的废除；免职包括两种情况，一是因退休、离休、辞退等原因的免职，终止公务员与机关的职务关系；二是由于公务员职务变更、工作职位变换引起的免职，公务员的职务关系不变，为了任新职。 公务员辞去公职的限制性条件公务员有下列情形之一的，不得辞去公职：(1) 未满国家规定的最低服务年限的(2) 在涉及国家秘密等特殊职位任职或者离开上述职位不满国家规定的脱密期限的(3) 重要公务尚未处理完毕，且须由本人继续处理的(4) 正在接受审计、纪律审查，或者涉嫌犯罪，司法程序尚未终结的(5) 法律、行政法规规定的其他不得辞去公职的情形。 公务员自愿辞去领导职务的限制性条件(1) 在涉及国家安全、重要机密等特殊职位上任职或者离开上述职位不满解密期限的(2) 有重要公务尚未处理完毕，而且须由本人继续处理的(3) 由人大、政协选举、任命、决定任命的领导干部任职不满一年的(4) 正在接受纪检机关(监察部门) 、司法机关调查或者审计机关审计的； 党政领导干部引咎辞去领导职务的程序党政领导干部引咎辞职应当经过下列程序：(1) 干部本人按照干部管理权限， 以书面形式向党委(党组) 提出辞职申请，说明辞职原因和思想认识等。(2) 组织(人事) 部门对辞职原因等情况进行了解审核，并提出初步意见。 (3) 按照干部管理权限，党委(党组) 集体研究，作出同意辞职、不同意辞职或者暂缓辞职的决定。党委(党组) 的决定应当及时通知干部所在单位和干部本人。(4) 党委(党组) 作出同意辞职决定后，按照有关规定办理辞职手续。辞去公职的法律后果：(1) 职务关系废除、公务员身份消失(2) 失去公职待遇辞去领导职务的类型：(1) 因公辞去领导职务(2) 自愿辞去领导职务(3) 引咎辞去领导职务(4) 责令辞去领导职务 责令辞去领导职务的程序责令辞职应当经过下列程序：(1) 党委(党组) 作出责令干部辞职的决定，并指派专人与干部本人谈话。责令干部辞职的决定应当以书面形式通知干部本人。 (2) 被责令辞职的干部应当在接到责令辞职通知后 15 日内向任免机关提出书面辞职申请。 (3) 按照有关规定办理辞职手续。由人大、政协选举、任命、决定任命的领导干部，依照法律或者政协章程的有关规定办理。 建立辞去领导职务的相关措施(1) 妥善安置辞去领导职务的公务员(2) 建立科学的岗位责任制和科学的考核评价体系(3) 加强职业道德建设，增强责任意识。 公务员辞退的特点(1) 辞退公务员是国家机关法定的用人权利(2) 辞退公务员基于法定事实(3) 辞退公务员必须基于法定程序(4) 被辞退的公务员享受法定的辞退待遇。 辞退与开除的差别辞退和开除都终止了公务员与机关的职务关系，公务员身份消失，是行政机关的单方面行为。二者差别： (1) 性质不同：开除是行政处分，具有惩戒性；辞退不是行政处分，无惩戒性(2) 原因不同：辞退的原因是公务员的德才表现或主观努力不够而不能胜任公务员职务，无法履行公务员义务；开除的原因是公务员违法乱纪行为。(3) 法律后果不同：辞退的公务员可以获得辞退费，并享受失业保险；被开除的公务员享受失业保险，但不享受其他待遇。 公务员可被辞退的条件公务员有下列情形之一的，予以辞退：(1) 在年度考核中，连续两年被确定为不称职的； (2) 不胜任现职工作，又不接受其他安排的； (3) 因所在机关调整、撤销、合并或者缩减编制员额需要调整工作，本人拒绝合理安排的； (4) 不履行公务员义务，不遵守公务员纪律，经教育仍无转变，不适合继续在机关工作，又不宜给予开除处分的； (5) 旷工或者因公外出、请假期满无正当理由逾期不归连续超过十五天，或者一年内累计超过三十天的。 公务员不能被辞退的条件对有下列情形之一的公务员，不得辞退： (1) 因公致残，被确认丧失或者部分丧失工作能力的； (2) 患病或者负伤，在规定的医疗期内的； (3) 女性公务员在孕期、产假、哺乳期内的； (4) 法律、行政法规规定的其他不得辞退的情形。 确定公务员退休待遇的原则(1) 国家保障原则(2) 法律保障原则(3) 退休待遇与社会发展水平相适应原则(4) 退休金免税原则。 辞退公务员的法定程序：(1) 由拟被辞退公务员所在单位提出建议，陈述辞退事实和理由(2) 所在单位按管理权限报任免机关审批(3) 任免机关批准了辞退的，应以书面形式通知被辞退公务员本人 公务员辞退的法律后果：(1) 公务员与机关的职务关系废除，公务员身份消失(2) 按照规定享受辞退待遇 提前退休的条件有：(1) 工作年限满 30 年的(2) 距国家规定的退休年龄不足五年，且工作年限满 20 年的(3) 符合国家规定的可以提前退休的其他情形的 公务员的退休待遇：(1) 退休公务员的政治待遇 (2) 退休金待遇 (3) 其他待遇 一、公务员辞职辞退退休的含义与意义识记：(1) 辞职：公务员根据本人意愿提出，并经任免机关的批准，依法解除公务员与机关职务关系的一种人事行为。辞退：公务员所在机关依照法律规定的条件，通过一定的法律程序，在法定的管理权限内作出解除公务员全部职务关系的行政行为。退休：公务员达到规定的年龄，工作时间达到一定的年限，或丧失工作能力，办理有关的手续离开工作岗位，享受相应的政治待遇和领取一定养老保险金，以安度晚年的一种人事管理制度。 (2) 辞职制度：辞职条件、办理原则、辞职程序、辞去公职的限制条件等一系列规定的总称。辞退制度：辞退条件、辞退程序、辞退后待遇等一系列规定的总称。退休制度：关于退休方式、退休条件、退休待遇、退休审批和退休安置管理等方面的法律、法规和相关政策的总称。 领会：建立()的意义：辞职： 1. 有利于畅通公务员队伍的“出口”，形成能进能出的更新机制； 2. 落实了个人自由选择职业的权利，有利于提高员工的积极性； 3. 有利于规范机关的人事管理行为，既保障了公务员的合法权利，又维护了国家和公众利益。 辞退： 1. 辞退制度体现优胜劣汰的竞争机制； 2. 保证公务员队伍充满活力； 3. 是建立高效廉洁政府的有效措施。 退休：#1. 有利于公务员队伍新老交替的正常化，增强公务员队伍的生机和活力；#2. 是宪法赋予公务员老有所养权利的真正体现，也是对公务员履行退休义务的监督；#3. 退休制度是调节公务员领导职务、克服公务员领导职务终身制的重要形式；#4. 有利于廉政勤政建设。 二、公务员辞职识记：辞去公职：根据本人意愿提出，并经过任免机关批准，依法解除其与机关的职务关系，丧失公务员身份。辞去领导职务：只限于承担领导职务的公务员，直接结果是公务员职务的变更，而非公务员身份的消失。 领会：(1) 辞去公职的特征： 1. 是公务员自主择业的权利； 2. 必须经过一定的法律程序； 3. 作为公务员自主择业的权利受到法律的保障； 4. 辞去公职权利的限制性。 条件：限制性条件： 1. 未满国家规定的最低服务年限； 2. 在涉及国家秘密等特殊职位任职或离开上述职位不满国家规定的脱密期限；重要公务尚未处理，且须由本人继续处理的； 4. 正在接受审计、纪律审查，或涉嫌犯罪，司法程序尚未终结的； 5. 法律、行政法规规定的其他不得辞去公职的情形。 程序： 1. 提出辞去公职书面申请； 2. 任免机关进行审批； 3. 普通公务员 30 日内进行审批，领导成员 90 日内进行审批。 (2) 辞去领导职务的类型： 因公辞去领导职务：工作需要变动职务，依照法律或政协章程的规定，向本级人民代表大会、人大常委会或政协提出辞去现任的领导职务。 自愿辞去领导职务：因个人或其他原因不愿意继续在领导岗位工作时，自行提出辞去现任领导职务。 引咎辞去领导职务：因工作严重失误、失职造成重大损失或恶劣影响，或对重大事故负有重要领导责任的，不宜再担任现职，由本人主动提出辞去现任领导职务。 责令辞去领导职务：按照管理权限的管理主体根据领导成员任职期间的表现，认定其已不再适合担任现职，通过一定程序责令其辞去现任领导职务。 应用：对公务员辞去领导职务的案例进行分析、判断。 三、公务员辞退识记：辞退概念：特点： 1. 是国家机关的一种法定的用人权利，一般无须事先征求公务员的意见，而是公务员所在机关在一定条件下依法作出的一种单方面的人事行政行为； 2. 必须是基于法定事实，即只有当公务员的某些行为表现符合《公务员法》的条件时，机关才能单方面终止公务员的职务关系； 3. 必须遵循法定的程序； 4. 被辞退的公务员享有法定的辞退待遇，可以领取辞退费及失业保险。 领会：(1) 辞退与开除的区别： 1. 性质不同：开除是对公务员的一种行政处分行为，具有明确的惩戒性质；而辞退不是行政处分，不具有任何惩戒性质，是公务员管理中的正常行为。 2. 原因不同：辞退是由于公务员的德才水平或本人主观努力不够而不能胜任公务员职务，无法履行公务员义务而产生的；开除则是由于公务员在行使公务中的违法违纪行为造成的。 3. 法律后果不同：辞退的公务员依法可以获得辞退费和享受失业保险；而被开除的公务员只能享受失业保险，而不能享受其他待遇。 (2) 辞退的条件： 1. 年度考核中，连续两年被确定为不称职的； 2. 不胜任现职工作，又不接受其他安排的； 3. 因所在机关调整、撤销、合并或缩减编制名额需要调整工作，本人拒绝合理安排的； 4. 不履行公务员义务，不遵守公务员纪律，经教育仍无转变的，不适合继续相关工作，又不宜给予开除处分的； 5. 旷工或因公外出，请假期满无正当理由逾期不归连续超过十五天，或者一年内累计超过三十天的，应予以辞退。 限制辞退的规定： 1. 因公致残，被确认丧失或部分丧失工作能力的； 2. 患病或负伤，在规定动的医疗期内的； 3. 女性公务员在孕期、产假、哺乳期内的； 4. 法律、行政法规规定的其他不得辞退的情形。 (3) 辞退的法律后果： 1. 公务员与机关的职务关系废除，公务员身份消失； 2. 按照规定享受辞退待遇。 四、公务员退休识记：(1) 退休：(2) 方式： 领会：(1) 应当退休的条件： 1. 年龄条件：女 55 周岁，男 60 周岁； 2. 身体条件。提前退休的3 条件：工作年限满 30 年的；距国家规定的退休年龄不足 5 年，且工作年限满 20 年的；符合国家规定的可以提前退休的其他情形。 (2) 确定公务员退休待遇的原则：国家保障原则；法律保障原则；退休待遇与社会发展水平相应原则；退休金免税原则。 (3) 退休后的政治待遇：原则上与同级在职公务员享受同等的政治待遇，如阅读机密文件、听重要报告、看必要的学习资料、参加党和国家组织的有关会议，为加强和改善党的领导，改善政府行政工作，提高工作效率作出贡献等。 福利待遇：退休金待遇：不以按劳分配为原则，但与公务员过去的累积贡献有关系，累计越大金额超高。其他待遇：P236 应用：综合分析，列举公务员“出口”的主要渠道。 第十二章 公务员申诉与控告知识点总结 公务员申诉的含义公务员申诉，是指公务员依照公务员法的规定，对国家机关做出的涉及本人合法权益的人事处理决定不服时，向有关机关说明和陈述，并要求采取措施予以纠正和保护的行为。 公务员申诉与其他申诉的不同之处在于： (1) 申诉者仅限于对机关做出的人事处理决定不服的公务员(2) 申诉事由是指机关做出的人事处理决定(3) 申诉对象是具有行政隶属关系或管理关系的行政机关(4) 受理申诉的机关由公务员法确定。 公务员申诉与控告的主要区别(1) 目的不同：申诉目的是使机关改变或撤销人事处理决定，以恢复自己的合法权益，弥补损失；控告目的是为了恢复和补偿自己的合法权益，并追究有关机关或人员的责任。(2) 原因不同：引起申诉的原因是公务员对已经发生效力的人事处理决定不服，要求重新审理；控告的原因是公务员的合法权益受到不法侵害，要求对有关责任人进行惩处。 公务员申诉与控告的意义(1) 实现公务员权利的重要保障(2) 调动公务员积极性的重要保证(3) 有利于促进公务员管理机关公正廉政建设。 申诉事由包括：(1) 处分 (2) 辞退或者取消录用 (3) 降职(4) 定期考核定为不称职 (5) 免除(6) 申请辞职、提前退休未予批准(7) 未按规定确定或者扣减工资、福利、保险待遇 (8) 法律、法规规定可以申诉的其他情形 在中国，受理公务员申诉的机关为：(1) 原处理机关 (2) 同级公务员主管部门 (3) 上一级机关 (4) 行政监察机关 公务员申诉程序A. 一般申诉程序：(1) 公务员对涉及本人的人事处理决定不服(2) 向原处理机关提出复核申请(3) 公务员对复核决定不服(4) 向同级公务员主管部门、上一级行政机关提出申诉(5) 公务员对省级以下机关做出的申诉处理决定不服(6) 向上一级机关提出再申诉。 B. 径直申诉程序：(1) 公务员对涉及本人的人事处理决定不服(2) 向同级公务员主管部门或上一级行政机关提出申诉(3) 公务员对省级以下机关做出的申诉处理决定不服(4) 向上一级机关提出再申诉。 C. 特别申诉程序：(1) 公务员对涉及本人的人事处理决定不服(2) 向行政监察机关提出申诉(3) 公务员对省级以下行政监察机关做出的申诉处理决定不服(6) 向上一级机关提出复核申请。 公务员控告的处理程序？(1) 立案(2) 调查(3) 审理(4) 做出处理决定或建议(5) 执行。 人事争议仲裁的原则(1) 合法原则：以事实为依据，以法律为准绳(2) 公正：秉公执法，一视同仁(3) 及时处理：在法定期限内，尽快裁决。 人事争议仲裁书应当载明下列事项： (1) 申请人姓名、性别、年龄、职业、工作单位和住所(2) 被申请人的姓名、性别、年龄、职业、工作单位和住所(3) 仲裁请求和所根据的事实、理由(4) 证据和证据来源、证人姓名和住所 一、公务员申诉控告的含义与意义识记：申诉：依据法律规定，对国家机关作出的涉及本人合法权益的人事处理决定不服时，向有关机关说明和陈述，并要求采取措施予以纠正和保护的行为，属于非司法上的申诉和国家机关工作人员的申诉。控告：公务员认为国家机关及其领导人员侵犯其合法权益，依法要求上级机关或有关的专门机关，对这种侵权行为进行调查、作出停止侵权行为的决定、追究侵权者现任的行为。 领会：公务员申诉与其他申诉的差异： 1. 申诉者仅限于对机关作出的涉及本人的具体人事处理决定不服的公务员； 2. 申诉事由指向的是机关的人事处理决定，这种决定是机关的内部行政行为； 3. 申诉的对象在行政上有隶属关系或管理关系的党政机关； 4. 受理申诉的机关是由公务员确定的。 公务员控告应当具备的条件：公务员的合法权益受到不法侵害且侵害权益的行为是违法违纪的；有明确的被控告机关或被控告人员；被控告机关和被控告人员属于受理控告机关管辖。 公务员控告与公务员申诉的区别： 目的不同：申诉的目的是使处理机关改变或撤销对自己的处理决定，以便恢复自己的合法权益，并使已经受到的损失得到补偿；控告的目的不仅仅是为了使自己的合法权益得到恢复和补偿，而且还要求追究实施不法侵害机关或人员的责任； 原因不同：引起申诉的原因是公务员对已发生效力的处理决定不服而要求重新审查处理，控告是公务员因合法权益受到不法侵害而要求对责任人进行惩处。 公务员申诉和控告的意义：是公务员整个管理体系中的重要一环，对公务员其他制度顺利推行有重要的保障和监督作用： 1. 建立公务员申诉控告制度是实现公务员权利的重要保障； 2. 是调动公务员积极性的重要保证； 3. 用于促进公务员管理机关公正廉洁建设。 二、申诉的事由与受理机关领会：八个方面的申诉事由：处分；辞退或取消录用；降职；定期考核为不称职；免职；申请辞职、提前退休未予批准；未按规定确定或扣减工资、福利、保险待遇；法律、法规规定可以申诉的其他情形。 四类受理机关：原处理机关(复核) ；同级公务员主管部门；上一级机关(与原处理机关有隶属关系机关) ；行政监察机关。 应用：运用公务员申诉的知识分析现实中和公务员申诉有关的问题。 三、申诉的程序、期限与审理识记：申诉程序：公务员在提出申诉和受理机关在处理申诉时必须遵循的步骤和要求：有一般申诉程序；径直申诉程序；特别申诉程序。 申诉期限：公务员在提出申诉和受理机关在处理申诉时必须遵循的时间要求。 领会：三类申诉程序：P242申诉期限的规定：P244申诉案件的审理：P244 应用：运用公务员申诉的知识分析现实中和公务员申诉有关的问题。 四、控告的事由与受理机关识记：控告事由：国家机关及其领导人员侵犯公务员合法权益的行为。受理机关：拥有控告管辖权的法定机关，与公务员所在机关具有领导、监督、监察或检查关系的机关。 领会：公务员可以控告的事由有哪些：八项权利和公务员应该获得的其他法定利益。 公务员控告的受理机关有哪些：上级机关或有关的专门机关(主要指行政监察机关和党的纪律检查机关) 五、控告的处理程序识记：控告处理程序：立案；调查；审理；作出处理决定或建议；执行。 领会：公务员控告的处理程序有哪些具体步骤 应用：运用公务员控告的知识分析现实中与公务员控告相关的问题。 六、申诉控告中各方的义务与责任领会：(1) 申诉人和控告人的义务：提出申诉、控告应当实事求是；不能提出过高或无理的要求；要遵守法定的申诉、控告程序。责任：对捏造事实、弄虚作假、诬陷他人的，机关根据情节轻重给予批评或处分、触犯刑法的，应当依法追究刑事责任。给国家或他人造成经济损失的，应负责赔偿；给他人造成名誉损害的，应当公开赔礼道歉，挽回影响。 (2) 被申诉、控告机关及其领导人员的义务与责任：及时纠正错误的人事处理决定，及时终止侵犯公务员合法权益的行为；机关及其领导人员的错误处理决定和侵权行为造成公务员经济损失的，应当负经济赔偿的责任；造成名誉损害的，应当负责恢复名誉、消除影响和赔礼道歉。(3) 受理申诉、控告机关及其工作人员的义务和责任 应用：分析现实中公务员申诉、控告案件中各方的义务和责任。 七、人事争议仲裁概念与原则识记：人事争议：具有人事关系的单位与其所属工作人员之间，执行人事政策法规或履行聘任合同，持不同主张或要求而产生的争执。 人事争议仲裁：人事争议仲裁委员会对申请仲裁的人事争议案件依法进行调解和裁决的活动。 领会：人事争议仲裁的合法、公正、及时处理三项原则： 1. 合法原则：指承担仲裁职责的人事争议仲裁委员会，在对人事争议进行仲裁时，必须坚持以事实为依据和以法律为准绳的准则，对争议案件进行审查和处理。 2. 公正原则：指人事仲裁委员会应秉公执法，对当事人双方在适用法律上一律平等，一视同仁，对任何一方不偏袒，不歧视，一切都依据客观实际作出判断和裁决，对争议双方都予以同样的保护。 3. 及时处理原则：指在人事争议发生后，人事仲裁委员会应在法律规定的时限内，尽快调查并作出裁决，不得无故拖延。","link":"/2021/01/25/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/%E5%85%AC%E5%8A%A1%E5%91%98%E5%88%B6%E5%BA%A6/%E5%85%AC%E5%8A%A1%E5%91%98%E5%88%B6%E5%BA%A6%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"}],"tags":[{"name":"http","slug":"http","link":"/tags/http/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"redux","slug":"redux","link":"/tags/redux/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"websocket","slug":"websocket","link":"/tags/websocket/"},{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"配置","slug":"配置","link":"/tags/%E9%85%8D%E7%BD%AE/"},{"name":"社会学","slug":"社会学","link":"/tags/%E7%A4%BE%E4%BC%9A%E5%AD%A6/"},{"name":"中国政治制度","slug":"中国政治制度","link":"/tags/%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB%E5%88%B6%E5%BA%A6/"},{"name":"公务员制度","slug":"公务员制度","link":"/tags/%E5%85%AC%E5%8A%A1%E5%91%98%E5%88%B6%E5%BA%A6/"},{"name":"公共政策","slug":"公共政策","link":"/tags/%E5%85%AC%E5%85%B1%E6%94%BF%E7%AD%96/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"js_逻辑题","slug":"js-逻辑题","link":"/tags/js-%E9%80%BB%E8%BE%91%E9%A2%98/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"}],"categories":[{"name":"http","slug":"http","link":"/categories/http/"},{"name":"react","slug":"react","link":"/categories/react/"},{"name":"js","slug":"js","link":"/categories/js/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"配置","slug":"配置","link":"/categories/%E9%85%8D%E7%BD%AE/"},{"name":"行政管理","slug":"行政管理","link":"/categories/%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86/"},{"name":"小程序","slug":"小程序","link":"/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"script","slug":"script","link":"/categories/script/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"html","slug":"html","link":"/categories/html/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"}]}